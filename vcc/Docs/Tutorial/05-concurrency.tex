\section{Atomics}

Writing concurrent programs is generally considered to be harder than writing
sequential programs.
Similar opinions are held about verification.
Surprisingly, in VCC the leap from verifying sequential programs to
verifying fancy lock-free stuff is not that big.
This is because the verification in VCC is inherently based on invariants:
conditions that attached to data and need hold \emph{no matter which thread}
accesses it.

But let us move from words to actions, and verify a canonical example
of a lock-free algorithm, which is the implementation of a spin-lock itself.
The spin-lock data-structure is really simple -- it contains just a single
field, meant to be interpreted as a boolean stating whether the spin-lock
is currently acquired.
However, in VCC we would like to attach some formal meaning to this boolean.
We do that through ownership -- the spin-lock will protect some object,
and will own it whenever it is not acquired.
Thus, the following invariant should come as no surprise:

\vccInput[linerange={lock-init}]{c/08_lockw.c}

\noindent
We use a ghost field to hold a reference to the object meant to be protected
by this lock.
If one wishes to protect multiple objects with a single lock, one can make
the object referenced by \vcc{protected_obj} own them all.
The \vcc{locked} filed is annotated with \vcc{volatile}.
It has the usual meaning for the regular C compiler (\ie it makes the compiler
assume that the environment might write to that field, while the compiler
is not looking).
For VCC it means that the field can be written also when the object is
consistent.
The idea is that we will not unwrap the object, but write it atomically,
while preserving its invariant.
The attribute
\vcc{_(volatile_owns)} means that we want the \vcc{\owns} set
to be treated as a volatile field (\ie we want to be able to write
it while to object is consistent; normally this is not possible).

Now we can see how one operates on volatile fields.
We shall start with the function releasing the lock, as it is simpler.

\vccInput[linerange={release-out}]{c/08_lockw.c}

\noindent
First, let's have a look at the contract.
\vcc{Release()} requires the lock to be wrapped.
You might wonder how multiple threads can all own the lock (to have it
wrapped), we will fix that later.
Second, we require that the protected object is wrapped.
We need it to be consistent because we will want to make the lock own it, and
lock can only own consistent objects.
We need the current thread to own it, because ownership transfer can
only happen between the current thread and an object.
Third, we say we're going to write the protected object.
This allows for the transfer, and prevents the calling function from assuming
that the object stays wrapped after the call.
Note that this contract is much like the contract of the function
adding an object to a container data-structure (see TODO).

The \vcc{atomic} block is similar in spirit to the \vcc{unwrapping} block ---
it allows for modifications of listed objects and checks if their invariants
are preserved.
The difference is that the entire update happens instantaneously from the point
of view of other threads.
We needed the unwrapping operation because we wanted to mark that we temporarily
break the object invariants.
Here, there is no point in time, where other threads can observe that the invariants
are broken.
Invariants hold before the beginning of the atomic block (by our principal reasoning
rule, \secref{TODO}), and we check the invariant at the end of the atomic block.

The question arises, what guarantees that other threads won't interfere with the atomic
action?
VCC allows only one physical memory operation inside of an atomic block,
which is indeed atomic from the point of view of the hardware.
Here, that operation is writing to the \vcc{l->locked}.
Other possibilities include reading from a volatile field, or a performing
a primitive operation supported by the hardware, like interlocked
compare-and-exchange.
However, inside our atomic block we can also see the update of the owns set
(remember that \vcc{\union_with(\owns(A), B)} is a shorthand for \vcc{\set(\owns(A), \union(\owns(A), B))}).
\todo{need better explanation}
This is fine, because the ghost code is not executed by the actual hardware.
If we were to imagine a VCC machine, which would actually execute the 
ghost code, we could say that it blocks other threads when the ghost
code is executing.
Because the real machine doesn't execute any ghost code, it doesn't need to do
any such blocking.

It is not particularly difficult to see that this atomic operation preserves the
invariant of the lock.
But this isn't the only condition imposed by VCC here.
To transfer ownership of \vcc{l->protected_obj} to the lock, we also need
write permission to the object being transferred, and
we need to know its consistent.
For example, should we forget to mention \vcc{l->protected_obj}
in the writes clause VCC will complain about:

\vccInput[linerange={out-999}]{c/08_lockw_wrong.c}

\noindent
Should we forget to perform the ownership transfer inside of \vcc{Release()}, we'll get complain
about the invariant of lock.

\vccInput[linerange={out-999}]{c/08_lockw_wrong2.c}

Let's then move to \vcc{Acquire()}. 
The specification is not very surprising: it requires the lock to be wrapped,
and ensures that after the call the thread will own the protected object,
and moreover, that the thread didn't own it before.
\todo{is-fresh should be explained earlier}

\vccInput[linerange={acquire-release}]{c/08_lockw.c}

\noindent
The \vcc{InterlockedCompareAndExchange()} function is a compiler built-in,
which on the x86/x64 hardware translates to \vcc{cmpxchg} assembly instruction.
It takes a memory location and two values.
If the memory location contains the first value, then it is replaced with the second.
It returns the old value.
The entire operation is performed atomically (and is also a write barrier).

\subsection{Atomic inline}

VCC doesn't have all the primitives of all the C compilers predefined.
One can define them by suppling a body.
It is presented only to the VCC compiler (it is enclosed in
\vcc{_(atomic_inline ...)}) so that the normal compiler doesn't get confused
about it.

\vccInput[linerange={xchg-acquire}]{c/08_lockw.c}

\noindent
This is one of the places where one needs to be very careful,
as there is no way for VCC to know if the definition you provided matches
the semantics of your regular C compiler.
Make sure to check with the regular C compiler manual for exact semantics
of its built-in functions.

The header files coming with VCC provide a handful of popular operations,
you can just rename them to fit your compiler.

\subsection{Using claims}

The contracts of functions operating on the lock require that the lock
is wrapped.
This is because one can only perform atomic operations on objects
that are consistent. 
If object is inconsistent, then the owning thread is in full control of it.
However, wrapped means not only consistent, but also owned by the current thread,
which defeats the purpose of the lock --- it should be possible
for multiple threads to compete for the lock.
Let's then say, there is a thread which owns the lock.
Assume some other thread got to know that the lock is consistent.
How would it know that the owning thread won't unwrap (or worse yet, deallocate) the lock, just
before the thread tries an atomic operation on the lock?
The owning thread thus needs to somehow promise the other thread
that lock will stay consistent.
In VCC such a promise takes form of a \Def{claim}.
Later we'll see that claims are more powerful, but for
now consider the following to be the definition of a claim:

\begin{VCC}
_(ghost 
typedef struct {
  \ptrset claimed;
  _(invariant \forall \object o; o \in claimed ==> \consistent(o))
} \claim_struct, *\claim;
)
\end{VCC}

\noindent
Thus, a claim is an object, with an invariant stating that a number of other objects
(we call them \Def{claimed objects}) are consistent.
As this is stated in the invariant of the claim, it only needs to be true
as long as the claim itself stays consistent.

One will ask, how is this admissible
\todo{probably insert some back-reference to admissibility;
people will have forgotten it by here}
--- the claim doesn't own the claimed
objects, so how should it know it will stay consistent?
This is ensured by an implicit invariant, defined on all types
marked with \vcc{_(claimable)} attribute.
This invariant states that the object cannot be unwrapped when
when there are consistent claims on it.
More precisely, each claimable object keeps track of the count of outstanding
claims.
The number of outstanding claim on object \vcc{o} is given by
the \vcc{\claim_count(o)} function.

Now we getting back to our lock example, the trick is that there can be
multiple claims claiming the lock (note that this is orthogonal to
the fact that a single claim can claim multiple objects).
The thread that owns the lock will need to keep track of who's using
the lock.
The owner won't be able to destroy the lock (which requires unwrapping it),
before it makes sure there is no one using the lock.
Thus, we need to add \vcc{_(claimable)} attribute to our lock
definition, and change the contract on the functions operating
on the lock. As the changes are vary similar we'll only
show \vcc{Release()}.
\todo{ghost parameters should be explained earlier}

\vccInput[linerange={release-struct_data}]{c/08_lock_claimsobj.c}

\noindent
We pass a ghost parameter holding a claim.
The claim should be wrapped.
The function \vcc{\claims_obj(c, l)} is defined to be
\vcc{l \in c->claimed}, \ie that the claim claims the lock.
We also need to know that the claim is not the protected object,
otherwise we couldn't ensure that the claim is wrapped after the call.
This is the kind of weird corner case that VCC is very good catching
(even if it's bogus in this context).
Other than the contract, the only change is that we list the claim
as parameter to the atomic block.
\todo{our current syntax is horrible, we need something different}
Listing a normal object as parameter to the atomic makes VCC know you're
going to modify the object.
For claims, it is just a hint, that it should use this claim when trying
to prove that the object is consistent.

\subsection{Creating claims}

When creating (or destroying) a claim one needs to list the claimed objects.
Let's have a look at an example.

\vccInput[linerange={create_claim-out}]{c/08_lock_claimsobj.c}

We initialize the lock, which leaves the lock wrapped (we'll get to that in a minute),
we create a claim on the lock, acquire it, release, destroy the claim, and unwrap the lock
(which allows it to be destroyed when the function activation record is popped off the stack).
The \vcc{\make_claim(...)} function takes the set of objects to be claimed
and a property (an invariant of the claim, we'll get to that in the next section).
Let us give desugaring of \vcc{\make_claim(...)} for a single object
in terms of the \vcc{\claim_struct} defined in the previous section.

\begin{VCC}
// c = \make_claim({o}, true) expands to
\claim_count(o) = \claim_count(o) + 1;
c = malloc(sizeof(\struct_claim));
c->claimed = {o};
_(wrap c);

// \destroy_claim(c, {o}) expands to
assert(o \in c->claimed);
\claim_count(o) = \claim_count(o) - 1;
_(unwrap c);
free(c);
\end{VCC}


Because creating or destroying a claim on \vcc{c} assigns to
\vcc{\claim_count(c)}, it requires write access to that memory ``location''.
One way to obtain such access is getting sequential write access to \vcc{c} itself:
in our example the lock is created on the stack and thus sequentially writable.
We can thus create a claim and immediately use it.
A more realistic scenario is when a thread creates an object, constructs
a number of claims on it, and stores the claims in some shared, possibly global, data-structures
(\eg a work-queue) where other threads can access them.

The \vcc{true} in \vcc{\make_claim(...)} is the claimed property (an invariant
of the claim), which will be explained in the next section.

The destruction can possibly leak claim counts, \ie one could say:
\begin{VCC}
\destroy_claim(c, {});
\end{VCC}
\noindent
and it would verify just fine.
This avoids the need to have write access to \vcc{o}, but on the other hand prevents
\vcc{o} from unwrapping forever (which might be actually fine if \vcc{o} is a ghost object).
%It seems clear why the claimed objects need to be listed when creating a claim, but
%why do we need them for destruction?

\subsection{Two-state invariants}

Sometimes it is not only important what are the valid states of objects,
but also what are the allowed \emph{changes} to objects.
For example, let's take a counter keeping track of certain operations
since the beginning of the program.

\vccInput[linerange={counter-reading}]{c/09_counter.c}

\noindent
Its first invariant is plain single-state invariant -- for some reason
we decided to exclude zero as the valid count.
The second invariant says that for any atomic update of (consistent)
counter, \vcc{v} can either stay unchanged or increment by exactly one.
The syntax \vcc{\old(v)} is used to refer to value of \vcc{v} before
an atomic update, and plain \vcc{v} is used for the value of \vcc{v}
after the update.
That is, when checking that an atomic update preserves the invariant
of a counter \vcc{n}, we will take the state of the program right
before the update, the state right after the update, and check
that the invariant holds for that pair of states.

\begin{note}
In fact, it would be easy to prevent any changes to some field \vcc{f}, by
saying \vcc{_(invariant \old(f) == f)}.
This is roughly what happens under the hood when a field is
declared without the \vcc{volatile} modifier.
\end{note}

As we can see there is no syntactic distinction between single-
and two-state invariants in VCC.
The single-state invariants are just two-state invariants, which do not use
\vcc{\old(...)}.
However, we often need an interpretation of an object invariant in a single state \vcc{s}.
For that we use the \Def{stuttering} transition from \vcc{s} to \vcc{s} itself.
VCC enforces that all invariants are \Def{reflexive} that is if they hold
over a transition \vcc{s0, s1}, then they should hold in just \vcc{s1}
(\ie over \vcc{s1, s1}).
In practice,
this means that \vcc{\old(...)} should be only used to describe
how objects change, and not what are their proper values.
In particular,
all invariants of the form \vcc{\old(E) == E || ...}, for any expression \vcc{E}, are reflexive.
On the other hand, the invariant \vcc{\old(f) < 7} is not reflexive.

Let's now discuss where can you actually rely on invariants being preserved.

\begin{VCC}
void foo(struct Counter *n)
  _(requires \wrapped(n))
{
  int x, y;
  atomic(n) { x = n->v; }
  atomic(n) { y = n->v; }
}
\end{VCC}

\noindent
The question is what do we know about \vcc{x} and \vcc{y}
at the end of \vcc{foo()}.
If we knew that nobody is updating \vcc{n->v} while \vcc{foo()}
is running we would know \vcc{x == y}.
This would be the case if \vcc{n} was mutable not wrapped.
In our case, because \vcc{n} is consistent, other threads can update it,
while \vcc{foo()} is running, but they will need to
adhere to \vcc{n}'s invariant.
So we might guess that at end of \vcc{foo()} we know
\vcc{y == x || y == x + 1}.
But this is incorrect: \vcc{n->v} might get incremented
by more than one, in several steps.
The correct answer is thus \vcc{x <= y}.
Unfortunately, in general, such properties are very difficult to deduce
automatically, which is why we use common object invariants and admissibility
check to express such properties in VCC.

\begin{note}
An invariant is \emph{transitive} if it holds over states \vcc{s0, s2},
provided that it holds over \vcc{s0, s1} and \vcc{s1, s2}.
Transitive invariants could be assumed over arbitrary
pairs of states, provided that the object stays consistent
in between them. 
VCC does not require invariants to be transitive though.

Some invariants are naturally transitive (\eg we could say
\vcc{_(invariant old(x) <= x)} in \vcc{struct Counter},
and it would be almost as good our current invariant).
Some other invariants, especially the more complicated ones,
are more difficult to make transitive.
For example, an invariant on a reader-writer lock might say
\begin{VCC}
_(invariant writer_waiting ==> old(readers) >= readers)
\end{VCC}
\noindent
To make it transitive one needs to introduce version numbers.
Some invariants describing hardware (\eg a step of physical CPU)
are impossible to make transitive.
\end{note}

Consider the following structure definition:

\vccInput[linerange={reading-endreading}]{c/09_counter.c}

\noindent 
It is meant to represent a reading from a counter.
Let's consider its admissibility.
It has a pointer to the counter, and a owns a claim, which
claims the counter.
So far, so good.
It also states that the current value of the counter is no less than \vcc{r}.
Clearly, the reading doesn't own the counter, so our previous rule
that you can mention in your invariant everything that you own doesn't apply.
It would be tempting to extend that rule to say ``everything that you own
or have a claim on'', but VCC actually uses a more general rule.
In a nutshell, the rule says that every invariant should be preserved
under changes to other objects, provided that these other objects change
according to their invariants.
When we look at our \vcc{struct Reading}, its invariant cannot be broken when
its counter increments, which is the only change allowed by counters invariant.
On the other hand, an invariant like \vcc{r == n->v} or \vcc{r >= n->v}
could be broken by such a change.
But let us proceed with somewhat more precise definitions.

First, assume that every object invariant holds when the object is inconsistent.
This might sound counter-intuitive, but remember that consistency is controlled
by a field.
When that field is set to false, we want to \emph{effectively} disable the invariant,
which is the same as just forcing it to be true in that case.
Alternatively, you might try to think of all objects as being consistent for a while.

An atomic action, which updates state \vcc{s0} into \vcc{s1}, is \Def{legal} if and only if the invariants of
objects that have changed between \vcc{s0} and \vcc{s1} hold over \vcc{s0, s1}.
In other words, a legal action preservers invariants of updated objects.
This should not come as a surprise: this is exactly what VCC checks
for in atomic blocks.

An invariant is \Def{stable} if and only if it cannot be broken by legal updates.
More precisely, to prove that an invariant of \vcc{o} is stable,
one needs to ``simulate'' an arbitrary legal update:
\begin{itemize}
\item Take two arbitrary states \vcc{s0} and \vcc{s1}.
\item Assume that all invariants (including \vcc{o}'s) hold over \vcc{s0, s0}.
\item Assume that all fields of \vcc{o} are the same in \vcc{s0} and \vcc{s1}.
\item Assume that for all objects, fields of which are not the same in \vcc{s0} and \vcc{s1},
their invariants hold over \vcc{s0, s1}.
\item Check that invariant of \vcc{o} holds over \vcc{s0, s1}.
\end{itemize}
The first assumption comes from the fact that all invariants are reflexive.

An invariant is \Def{admissible} if and only if its stable and reflexive.

First, let's see how our previous notion of admissibility relates to this one.
If \vcc{o} owns \vcc{p}, then \vcc{p \in \owns(o)}.
By the second admissibility assumption, because \vcc{\owns(o)} resides
in a field of \vcc{o}, after the simulated action \vcc{o} still owns \vcc{p}.
Because of that, we know that \vcc{p} is consistent in both \vcc{s0} and \vcc{s1}.
Therefore its non-volatile fields do not change between \vcc{s0} and \vcc{s1}.
Additionally, if \vcc{p} owned \vcc{q} before the atomic action, and the owns set of \vcc{p} is non-volatile,
it will keep owning \vcc{q}, and thus non-volatile fields of \vcc{q}
will stay unchanged.
Thus our previous notion of admissibility is no stronger than this one.

Getting back to our \vcc{foo()} example, to deduce that \vcc{x <= y}, after
the first read one could create a ghost \vcc{Reading} object, and
use its invariant in the second action.

\subsection{Guaranteed properties}

When constructing a claim, one can specify additional invariants of the claim
structure.
Such invariants are subject to admissibility check as usual.

\itodo{explain claims about properties -- possibly use counter as an example,
also for two-state invariants}

\subsection{Dynamic claim management}

\itodo{a rundown as a bigger example}

