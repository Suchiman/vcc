\section{Function Contracts}
\label{sect:functions}

Next we turn to the specification of functions. We'll take the example
from the previous section, and pull the computation of the minimum of
two numbers out into a separate function:

\vccInput[linerange={begin-}]{c/01_min2.c}

(The listing above presents both the source code and the output
of VCC, typeset in a different fonts, and 
the actual file name of the example is replaced with \vcc{/*`testcase`*/}.)
VCC failed to prove our assertion, even though it's easy to see that
it always holds. This is because verification in VCC is \Def{modular}: 
VCC doesn't look inside the body of a function (such as the definition of \vcc{min()}) 
when understanding the effect of a call to the function (such as 
the call from \vcc{main()});
% We actually don't have that (except for atomics) --MM
%\footnote{We will see later how to selectively override this default
%  and perform such inlining during verification.}; 
all it knows about the effect of calling \vcc{min()} is that the call 
satisfies the specification of \vcc{min()}. 
%This is just because we have chosen the default to be so. It thus doesn't
% contradict that specification needs to say everything --M
%\footnote{
%  Actually, VCC does know one important thing from this specification
%  of \vcc{min()}: it knows that a call do \vcc{min()} has no side
%  effects that are visible to the caller. We'll see in \secref{writes} that
%  any such side effects have to be explicitly specified.
%}.
Since the correctness of \vcc{main()} clearly depends on what \vcc{min()}
does, we need to specify \vcc{min()} in order to verify \vcc{main()}.

The specification of a function is sometimes called its \Def{contract},
because it gives obligations on both the function and its callers. It
is provided by three types of annotations:
\begin{itemize}
\item A requirement on the caller (sometimes called the
  \Def{precondition} of the function) takes the form \vcc{_(requires E)}, 
  where \vcc{E} is an expression. It says that callers of the
  function promise that \vcc{E} will hold on function entry. 

\item A requirement on the function (sometimes called a
  \Def{postcondition} of the function) takes the form \vcc{_(ensures E)}, 
  where \vcc{E} is an expression. It says that the function
  promises that \vcc{E} holds just before control exits the
  function. 

\item The third type of contract annotation, a \Def{writes clause}, is described
  in the next section.
\end{itemize}

For example, we can provide a suitable specification for \vcc{min()} as
follows:
\vccInput[linerange={min-endmin,out-}]{c/01_min3.c}
\noindent
(Note that the specification of the function comes after the header and
before the function body; you can also put specifications on function
declarations (\eg in header files).)
The precondition \vcc{_(requires \true)} of \vcc{min()} doesn't
really say anything (since \vcc{\true} holds in every state), but is included
to emphasize that the function can be called from any state and
with arbitrary parameter values.
The postcondition states that the value returned from \vcc{min()} 
is no bigger than either of the inputs.
Note that \vcc{\true} and \vcc{\result} are spelled with a backslash
to avoid name clashes with C identifiers.%
\footnote{
  All VCC keywords start with a backslash; 
  this contrasts with annotation tags (like \vcc{requires}),
  which are only used at the beginning of annotation
  and therefore cannot be confused with C identifiers
  (and thus you are still free to have, \eg
  a function called \lstinline{requires} or \lstinline{assert}).}

VCC uses function specifications as follows. When verifying the body of a
function, VCC implicitly assumes each precondition of the function on
function entry, and implicitly asserts each postcondition of the
function (with \vcc{\result} bound to the return value and each
parameter bound to its value on function entry) just before the
function returns. For every call to the function, VCC replaces the
call with an assertion of the preconditions of the function, sets the
return value to an arbitrary value, and finally assumes each
postcondition of the function. 
For example, VCC translates the program above roughly as follows:
\vccInput[linerange={begin-end}]{c/01_min_assert.c}

%The problem with the following explanation is that it doesn't make
%sense to say that these assumptions are "never" violated, because that
%assumes they have been implicitly added to the original program, without removing
% the function calls. A better explanation would be to show the translation 
% as first introducing the assumptions and assertions into the program
% without getting rid of the function calls (so that each assumption is
% justified by a preceding assertion in execution of the same program),
% and then replacing the function call with a nondeterministic assignment
% (which is just replacing a function call with a less deterministic piece of code). 
% This can be made more transparent by moving the precondition assertion
% of the call to min to before the declaration of _res.

Note that the assumptions above are ``harmless'', that is in a fully
verified program they will be never violated, as each follows
from the  assertion that proceeds it in an execution.
For example, the  assumption generated by a precondition could fail only if the 
assertion generated from that same precondition  before it fails.

\todo{Isn't the following important enough to put in the main text? -E}
\begin{note}
\notehd{Why modular verification?}
Modular verification brings several benefits. 
First, it allows verification to more easily scale to
large programs. Second, by providing a precise interface between
caller and callee, it allows you to modify the implementation of
a function like \vcc{min()} without having to worry about breaking the
verifications of functions that call it (as long as you don't change
the specification of \vcc{min()}). This is especially important
because these callers normally aren't in scope, and the person
maintaining \vcc{min()} might not even know about them (e.g., if
\vcc{min()} is in a library). Third, you can verify a function like
\vcc{main()} even if the implementation of \vcc{min()} is unavailable
(\eg if it hasn't been written yet). 
\end{note}

\subsection*{Exercises}
\begin{enumerate}
\item
Try replacing the \vcc{<} in the return statement of \vcc{min()} with
\vcc{>}. Before running VCC, can you guess which parts of the
verification will fail?
%% One way to illustrate that the verification of \vcc{main()} 
%% depends only on the specification of \vcc{min()} is to 
%% replace \vcc{<} with \vcc{>} in the return statement of \vcc{min()}.
%% The output of verification shows that \vcc{main()} is still correct---only 
%% \vcc{min()} is broken:
%% \vccInput[linerange={out-}]{c/01_min4.c}

\item
What is the effect of giving a function the specification
\vcc{_(requires \false)} ? How does it effect verification of
the function itself? What about its callers? Can you think of a good 
reason to use such a specification?
%% When verifying function body it translates to an assumption.
%% As we have noted this will make the body of function verify,
%% regardless what it contains.
%% On the other hand, you will be unable to verify call to such a function
%% from outside.
%% Conversely, \vcc{_(ensures \false)} will prevent verification
%% of the body of the function, but will make the function that calls
%% it verify.

%% As we can see, in each case there is something that does not verify.
%% However, because of this you should be careful when interpreting
%% VCC answers: successful verification of a function is only meaningful
%% if everything it calls was verified.

\item
Can you see anything wrong with the above specification of \vcc{min()}?
Can you give a simpler implementation than the one presented? Is this 
specification strong enough to be useful? If not, how might it be
strengthened to make it more useful?

\item
Specify a function that returns the (int) square root of its (int)
argument. (You can try writing an implementation for the function, but
won't be able to verify it until you've learned about loop
invariants.)

\item
Can you think of useful functions in a real program that might
legitimately guarantee only the trivial postcondition \vcc{_(ensures \true)}?
\end{enumerate}

\subsection{Reading and writing memory}
\label{sect:writes}
\todo{I think that bringing pointers explicitly into the title of this section is a mistake.
The problem is that if we take the address of a local, even in an assertion, all of the previously
non-pointer accesses magically become reading and writing through pointers. We are better off
saying that these are the rules for all memory access, and mentioning the special handling of
locals whose address is never taken.}
%\subsection{Reading and writing through pointers}

When programming in C, it is important to distinguish two kinds of
memory access. \Def{Sequential} access, which is the default, is appropriate when
interference from other threads (or the outside world) is not an
issue, \eg when accessing unshared memory. Sequential accesses can be
safely optimized by the compiler by breaking it up into multiple
operations, caching reads, reordering operations, and so on. 
\Def{Atomic} access is required when the access might race with other
threads, \ie write to memory that is concurrently read or written,
or a read to memory that is concurrently written. Atomic access is typically
indicated in C by accessing memory through a volatile type (or through atomic 
compiler intrinsics). We consider only sequential 
access for now; we consider atomic access in section \secref{concurrency}.

To access a memory object, the object must reside at a valid memory address%
\footnote{VCC actually uses a somewhat stronger validity condition because of 
its typed view of memory \secref{typed-memory}.
}%
. (For example, on typical hardware, its virtual address must be suitably aligned,
must be mapped to existing physical memory, and so on.) 
In addition, to safely access memory sequentially, the memory must not be concurrently
written by other threads (including hardware and devices); in VCC, this condition is written
\vcc{\thread_local(p)}, where \vcc{p} is a pointer to the memory object. VCC asserts this 
before any sequential memory access to the object. 



The three simple ways of specifying this are as follows:
\todo{There are some problems here. First, we have unnecessarily 
tangled up the classification of memory with the specification of functions
by saying that they have to be in preconditions; they should instead be 
presented as assertions. Second, as far as i can find, we never define thread locality
anywhere, and define mutability only in passing; we should give at least 
intuitive meanings here. Third, saying that a pointer is considered thread-local
when you specify that it is thread-local just sounds vacuously stupid.-E
}

\begin{itemize}
\item A pointer \vcc{p} is considered \Def{thread-local}
when you specify:
\begin{VCC}
_(requires \thread_local(p))
\end{VCC}
When reading \vcc{*p} (without additional annotations) you will need to prove \vcc{\thread_local(p)}.

\item A pointer \vcc{p} is considered \Def{mutable} when you specify:
\begin{VCC}
_(requires \mutable(p))
\end{VCC}
All mutable pointers are also thread local.
Writing via pointers different than \vcc{p} cannot make \vcc{p} non-mutable.

\item A pointer \vcc{p} is considered \Def{writable} when you specify:
\todo{We should introduce writability as a predicate.}
\begin{VCC}
_(writes p)
\end{VCC}
Additionally, freshly allocated pointers are are also writable.
All writable pointers are also mutable.
To write through \vcc{p} you will need to prove that the pointer is writable.
Deallocating \vcc{p} requires that it is writable, and afterwards
the memory is not even thread-local anymore.
\end{itemize}

\begin{note}
If VCC doesn't know why an object is thread local, then it has
hard time proving that the object stays thread local after an operation
with side effects (\eg a function call).
Thus, in preconditions you will sometimes want to use
\vcc{\mutable(p)} instead of \vcc{\thread_local(p)}.
The precise definitions of mutability and thread locality
is given in \secref{ownership},
where we also describe another form of guaranteeing thread locality
through so called ownership domains.
\end{note}

The \vcc{NULL} pointer, pointers outside bounds of arrays,
the memory protected by the operating system, or outside
the address space are never thread local (and thus also never mutable
nor writable).
Access to thread local memory will never crash the program.
The memory that is not thread-local is covered in 
\secref{concurrency}.

Let's have a look at an example:
\vccInput[linerange={begin-}]{c/01_rw.c}
\noindent
The function \vcc{write_wrong} fails because \vcc{p} is only
mutable, and not writable.
In \vcc{read_wrong} VCC complains that it does not know
anything about \vcc{p} (maybe it's \vcc{NULL}, who knows),
in particular it doesn't know it's thread-local.
\vcc{read2} is fine because \vcc{\mutable} is stronger
than \vcc{\thread_local}.
Finally, in \vcc{test_them} the first three assertions succeed
because if something is not listed in the writes clause
of the called function it cannot change.
The last assertion fails, because \vcc{write()} listed \vcc{&a}
in its writes clause.

%\noindent Without the \vcc{\thread_local()} annotation you would
%get the following:
%\vccInput[linerange={begin-}]{c/01_read_wrong.c}

% the concept of validity (typed pointers) is gone from VCC3 --MM
%For each memory access within a program, VCC checks that the access is accessing a 
%\Def{valid} memory object. Validity implies that the object address
%points to memory that is actually in the address space of the program
%(i.e., it has been allocated, either on the stack or on the heap, and
%has not been freed). (Validity in VCC additionally requires that the
%access is appropriately typed; this aspect is 
%described in more detail in \secref{type-safety}). 

Intuitively, the clause \vcc{_(writes p, q)} says that, 
of the memory objects that are thread-local to the caller before the call,
the function is going to modify only the object pointed to by \vcc{p}
and the object pointed to by \vcc{q}.%
\footnote{
And their ``ownership domains'',
but until \secref{ownership} we consider these to be empty.
}
In other words, it is roughly equivalent to a postcondition that ensures
that all other objects local to the caller prior
to the call remain unchanged.
VCC allows you
to write multiple writes clauses, and implicitly
combines them into a single set. If a function spec contains no writes clauses, 
it is equivalent to specifying a writes clause with empty set of
pointers.

%More precisely, an object is \vcc{\writable} if it is \vcc{\mutable} and 
%it is either listed in a writes clause of the function,
%or it became \vcc{\mutable} sometime after the function was entered; the 
%latter condition guarantees that either \vcc{p} was listed in the
%writes clause or was not thread-local in the caller when the call to
%the function was made. 
%In particular, formal function parameters and local variables are
%writable as long as they are in scope and have not been explicitly
%wrapped (\secref{invariants}) or reinterpreted to a
%different type (\secref{reint}).  VCC asserts
%\vcc{\writable(p)} on each attempt to write to \vcc{*p}, as well as on
%each call to a function that lists \vcc{p} in a writes clause.

Here is a simple example of a function that visibly reads and writes
memory; it simply copies data from one location to another.
\vccInput[linerange={begin-}]{c/01_copy1.c}
In the postcondition the expression \vcc{\old(E)} returns the value
the expression \vcc{E} had on function entry.
Thus, our postcondition states that the new value of \vcc{*to}
equals the value \vcc{*from} had on call entry. 
VCC translates the function call \vcc{copy(&x,&y)} approximately as
follows:
\begin{VCC}
_(assert \thread_local(&x))
_(assert \mutable(&y))
// record the value of x
int _old_x = x;
// havoc the written variables
havoc(y);
// assume the postcondition
_(assume y == _old_x)
\end{VCC}

%% Shouldn't \array_range be allowed for arrays of non-primitives also?
% Similar to \vcc{\thread_local_array},
%\vcc{\mutable_array(ar,sz)} is defined as
%\vcc{\forall unsigned i; i < sz ==> \mutable(&ar[i])}.
%
%The expression \vcc{\thread_local_array(ar, sz)} is
%syntactic sugar for \vcc{\forall unsigned i; i < sz ==> \thread_local(&ar[i])}.
%
%Programs that manipulate arrays often write to multiple array
%locations. Writes clauses actually allow sets of pointers, rather than
%individual pointers. We'll introduce sets in full generality later, but
%note one special case: the expression \vcc{\array_range(ar, len)}
%denotes the set of pointers \vcc@{&ar[0], &ar[1], ..., &ar[len-1]}@. 
%Thus, a writes clause of the form
%\vcc{_(writes \array_range(ar,len))}
%allows writing to all elements of the array.

\subsection{Arrays}

Array accesses are a kind of pointer accesses.
Thus, before allowing you to read an element of an array VCC checks if it's thread-local.
Usually you want to specify that all elements of an array are thread-local,
which is done using the expression \vcc{\thread_local_array(ar, sz)}.
It is essentially a syntactic sugar for
\vcc{\forall unsigned i; i < sz ==> \thread_local(&ar[i])}.
The \vcc{\mutable_array()} is analogous.
To specify that an array is writable use:
\begin{VCC}
_(writes \array_range(ar, sz))
\end{VCC}
which is roughly a syntactic sugar for:
\begin{VCC}
_(writes &ar[0], &ar[1], ..., &ar[sz-1])
\end{VCC}

For example, the function below is reimplementation of the 
C standard library \vcc{memcpy()} function:
\vccInput[linerange={begin-end}]{c/01_copy_array.c}
It requires that array \vcc{src} is thread-local,
\vcc{dst} is writable, and they do not overlap.
It ensures that at all indices \vcc{dst} has the old
value of \vcc{src}.
The next section will show how to implemented it with a loop.

\subsection{Logic functions}
\todo{These should probably be put into an appendix, or just left out altogeather in favor of pure functions. 
It certainly could be delayed, right?}
Just like with programs, as the specifications get more complex,
it's good to structure them somewhat.
One mechanism provided by VCC for that is \Def{logic functions}.
They essentially work as macros for pieces of specification,
but prevent name capture and give better error messages.
For example:
\vccInput[linerange={beginsp-endsp}]{c/01_issorted.c}
\noindent
A partial spec for a sorting routine could look like:%
\footnote{We will take care about input being permutation of the output in \secref{ghosts}.}
\vccInput[linerange={beginso-endso}]{c/01_issorted.c}

Logic functions are not executable, but they can be implemented:
\vccInput[linerange={beginim-endim}]{c/01_issorted.c}

A logic function and its C implementation can be combined into one using
\vcc{_(pure)} annotation.  This is covered in \secref{pureFunctions}.
\todo{This isn't right, is it? Logic functions really act as macros, e.g. they cannot be
used in triggers.}
 
\subsection{Exercises}
\begin{enumerate}
\item
Could the postcondition of \vcc{copy} have been written equivalently
as the simpler \vcc{*to == *from}? If not, why not?
\item
Specify a program that takes two arrays and checks whether
the arrays are equal (\ie whether they contain the same sequence of
elements).
\item
Specify a program that takes an array and checks whether it
contains any duplicate elements.
\item
Specify a program that checks whether a given array
is a palindrome.
\item
Specify a program that checks whether two arrays contain a
common element.
\item
Specify, write, and verify a function that swaps the values pointed to
by two \vcc{int} pointers. Hint: use \vcc{\old(...)} in the
postcondition.
\item
Specify a function that copies one array to another array of the same
size. (Don't worry about array aliasing.)
\item 
Specify a function that takes a text (stored in an array) and a string
(stored in an array) and checks whether the string occurs within the
text.
\end{enumerate}

\begin{enumerate}
\item
Extend the specification of sorting to guarantee that the sort
is stable (i.e., it shouldn't change the array if it is already
sorted).  
\item
Extend the specification of sorting to guarantee that the sorting
doesn't change the set of numbers occurring in the array (though it
might change their multiplicities). 
\item
Write, without using the \vcc{%} operator, logic functions that
specify (1)~that one number (\vcc{unsigned int}) divides another
evenly, (2)~that a number is prime, (3)~that two numbers are
relatively prime, (4)~the greatest common divisor of two numbers.
\end{enumerate}


%% \vccInput[linerange={swap-partition}]{c/04_partition.c}
%% \vccInput[linerange={foo-}]{c/01_swap1.c}

%% Because global variables (like \vcc{z}) might be visible to callers
%% of \vcc{copy()}, \vcc{copy()} needs to report that they might change.
%% Note that the writes clause lists pointers to memory locations, not lvalues
%% (\ie \vcc{_(writes &x, &y, &z)} and not \vcc{_(writes x, y, z)}).
%% Note also that because \vcc{&z} aliases neither \vcc{&x} nor \vcc{&y}, VCC can
%% deduce that \vcc{swap(&x, &y)} does not change \vcc{z}.

%% Had we left out the writes clause from the specification of
%% \vcc{swap()}, VCC would report several errors:
%% \vccInput[linerange={out-}]{c/01_swap2.c}
%% \noindent 

%% Whenever a memory object is read, VCC asserts that it is
%% thread-local; whenever a memory object is written or is
%% mentioned in the writes clause of a function call, VCC asserts that it
%% is writable. Try removing each of the function annotations in
%% this example (one at a time) to see what error messages you get.

%% For example, the assert/assume translation of \vcc{swap()} is%
%% \footnote{
%%   VCC does not generate the read and writes checks for the local variable
%%   \vcc{tmp}. Because \vcc{tmp} is a local that never has its address
%%   taken, it can be thought of as remaining in a register, where it is
%%   guaranteed to remain writable.
%% }:

%% \vccInput[linerange={swap-}]{c/01_swap3.c}

%% \noindent
%% As we can see, one effect of \vcc{writes p, q} is the implicit
%% precondition \vcc{requires \writable(p) && \writable(q)}. Such precondition
%% needs to be checked in \vcc{foo()}, at the place where it calls \vcc{swap()}.
%% In other words, the called function can write at most what the caller can write.
%% In particular if we forget to list \vcc{&x} in the writes
%% clause of \vcc{foo()} we would get an error when it tries to call a
%% function that possibly writes \vcc{&x}:

%% \vccInput[linerange={out-}]{c/01_swap4.c}


%% You might wonder why cannot we just have 
%% \vcc{requires \writable(p)} and instead have the specialized writes clause.
%% The reason is that the writes clause also specifies that nothing
%% outside of the writes clause will be changed.
%% This is why we can prove that \vcc{y} is still \vcc{42} after the call
%% to \vcc{boundedIncr(&x)}. 


%A predicate \vcc{\mutable(p)} states that the object pointed to by \vcc{p}
%is allocated, ``belongs'' to the current thread, and is in a ``phase of life''
%that allows for modification.
%We will get into details all of these later.
%For now we just need to know that in order to be able to write to \vcc{*p}
%one needs to know that \vcc{p} was listed in the writes clause \emph{and} \vcc{\mutable(p)}.
%For example, if we remove the \vcc{_(writes ...)} clause from the
%\vcc{boundedIncr()} we get the following output:

