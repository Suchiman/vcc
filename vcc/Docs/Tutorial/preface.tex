\section{Introduction}
This tutorial is an introduction to verifying C code with VCC. Our
primary audience is programmers who want to write correct code.
The only prerequisite is a working knowledge of C.

To use VCC, you first \emph{annotate} your code to specify how
your functions and data structures are meant to be used.
VCC then tries to \emph{prove} (mathematically) that
your program meets these specifications.  Unlike most program
analyzers, VCC doesn't look for bugs, or analyze an abstraction of
your program; if VCC certifies that your program is correct, then your
program really is correct%
\footnote{
  In reality, this isn't a 100\% guarantee, because VCC itself might have bugs. In
  practice, this is unlikely to cause you to accidentally verify an
  incorrect program, unless you find and intentionally exploit such a
  bug. 
  % These don't constitute software bugs. --E
  %Another source of bugs that could slip into verified software would be the compiler,
  %the operating system, and the hardware. 
  % I wouldn't bet on this. --E
  %These are generally more likely to introduce bug than VCC.

  % This is way too arcane to be mentioned in the intro. --M
  %In addition, VCC currently doesn't do the checks needed to
  %ignore memory system optimizations on multiprocessor machines, e.g.,
  %processor store buffering on x64 machines; this will be remedied in the near
  %future.
  }. 

To check your program, VCC uses the \Def{deductive verification paradigm}:
it generates a number of mathematical
statements (called \Def{verification conditions}), the validity of
which suffices to guarantee the program's correctness, and tries to
prove these statements using an automatic theorem prover. If any of
these proofs fail, VCC reflects these failures back to you in terms of
the program itself (as opposed to the formulas seen by the theorem
prover). Thus, you normally interact with VCC entirely at the level of
code and program states; you can usually ignore the mathematical
reasoning going on ``under the hood''.
For example, if your program uses division
somewhere, and VCC is unable to prove that the divisor is nonzero, it
will report this to you as a program error at that point in the
program. 
% Seems like a redundant information.
%(If you use VCC from within Visual Studio, it will show in
%your program text the place where the error is, just like a syntax
%error.) 
This doesn't mean that your program is necessarily incorrect;
most of the time, especially when verifying code that is already well-tested,
it is because your specifications aren't strong
enough to guarantee that the suspected error doesn't occur.
(For example, you might have forgotten to specify that some function
parameter is required to be nonzero.)
Typically, you fix this ``error'' by strengthening your
specifications. This might lead to other error reports, necessitating
the strengthening of other specifications, so verification is in
practice an iterative process.  
Often this process will reveal a genuine programming error.
Moreover, this process pays the extra dividend of producing precise
specifications for your functions and data structures---a very useful
form of documentation. 

%\itodo{the following paragraph should be moved out of here}
%% Annotating your program sometimes requires some extra
%% programming.  For example, a common way to keep threads
%% from interfering with each other is to allow each thread to access
%% only those shared resources that it ``owns''. The movement of 
%% ownership during program execution is an implicit part of the 
%% program design; this movement can be made explicit by maintaining the
%% ownership relation explicitly with \Def{ghost data}, and updating it
%% with \Def{ghost code}. Ghost code is seen by VCC but not by the C compiler, and
%% so introduces no runtime overhead. Part of the VCC philosophy is that
%% programmers would rather do extra programming than drive interactive
%% theorem provers, so ghost code is the preferred way to help VCC
%% understand why your program works.  

This tutorial covers basics of VCC annotation language. By the time
you have finished working through it, you should be able to use VCC to
verify some nontrivial programs. It doesn't cover the theoretical
background of VCC \cite{lci}, implementation details \cite{vcc}
or advanced topics;
information on these can be found on the VCC
homepage\footnote{\url{http://vcc.codeplex.com/}}.
%
%%  These topics are covered
%% separately~\cite{lci}.  A high-level overview of the VCC tool chain is
%% also available separately~\cite{Cohen:TPHOLs2009-23}.
%
The examples in this tutorial are currently distributed with the VCC sources.%
\footnote{
Available from \url{http://vcc.codeplex.com/SourceControl/list/changesets}: click Download on the right,
get the zip file and navigate to \lstinline|vcc/Docs/Tutorial/c|. (In
future, these will form part of the distribution.)}

You can use VCC either from the command line or from Visual Studio
2008 (VS); the VS interface offers easy access to different components of
VCC tool chain and is thus generally recommended.
VCC can be downloaded from the VCC homepage; 
be sure to read the installation instructions\footnote{\url{http://vcc.codeplex.com/wikipage?title=Install}},
which provide important information about installation prerequisites 
and how to set up tool paths.

%\subsection{Notational conventions}

% How about keeping these things in footnotes? -E
%% \begin{note}
%%   Throughout the tutorial, we'll use notes like this one to discuss
%%   topics, which can be skipped on the first reading, either because
%%   they are somewhat more advanced, arcane, or not so important.
%% \end{note}

Because this is a tutorial, we will occasionally provide simplified (and
therefore not strictly correct) explanations, providing
additional clarification in the footnotes\footnote{Like this one.},
which can be skipped on first reading. 
\begin{note}
Notes like this one are used for explanatory and additional material,
that is not necessary to understand the main flow of the text.
\end{note}
% Don't need this -E
%Definitions  be introduced with \Def{italic boldface}.

\subsection{A Note on VCC Invocation}
\label{sect:todo-invoke}
This tutorial assumes you're using VCC version 3. 
As of April 2011 it is necessary to supply the flag \texttt{/3}
to VCC to enable this.
This will soon be the default.
% -3 now implies -2 and -it. --MM

\subsection{Revision history}

%% \subsection{Top-level To-Do}

\noindent \textbf{Version 0.2, April ?? 2011.}
Improved thread-locality explanations in \secref{writes}.
Added description of pure functions.

\noindent \textbf{Version 0.1, July 21 2010}
Added \secref{overflows} about overflows, and explanations about arrays writes in \secref{sorting}.
Added \secref{trigger-inference} and \secref{trigger-hints} about triggering.

\noindent \textbf{Version 0.0, July 17 2010}
Initial.

%\subsection{Running VCC from the command line}
%\todo{More options?}
%The easiest way to call VCC on a set of files is
%\begin{verbatim}
%vcc [/f:funs] [/inspector] [/modelviewer] files
%\end{verbatim}
%Via the \verb!/f! switch a comma-separated list of functions to
%verify may be provided. The \verb!/inspector! (or \verb|/i|) switch causes the Z3 Inspector to be
%displayed while the verification is running, to monitor what VCC is
%trying to do. The \verb!/modelviewer! (or \verb|/mv|) switch causes VCC to display models for
%the errors that it finds.
%If there is more than one error, the active model can be switched in the Model menu.
% 
%\subsection{Running VCC from VS}
%\itodo{this should be introduced along with the examples}
%If you right-click within a C source file,
%several VCC commands are made available, depending on what kind of
%construction IntelliSense thinks you are in the middle of. The choice
%of verifying the entire file is always available. If you click within
%the definition of a struct type, VCC will offer you the choice of
%checking admissibility for that type (a concept explained in
%section \ref{}). If you click within the body of a function, VCC should offer
%you the opportunity to verify just that function. However,
%IntelliSense often gets confused about the syntactic structure of
%VCC code, so it may not give these context-dependent
%options. However, if you select the name of a function and then right
%click, it will allow you to verify just that function.
%
%If you want to run the VCC inspector during verification, this
%option can be selected from the Verify$\rightarrow$Settings menu. If you want
%to look at the error model for a particular error, right-click on
%error (in the source), and choose ``Show VCC error model''\todo{This
%  should really say ``VCC error model'', to not expose Z3.}
