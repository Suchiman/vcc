\section{Triggers}

The triggers are likely the most difficult part of this tutorial.
As of recently, the trigger inference algorithm in VCC
has been improved, so triggers need to be used less often.
Thus, we didn't need any trigger annotations for the examples
in the tutorial.
Still, you'll need them to deal with more complex VCC verification
tasks.

SMT solvers, which are the underlying VCC theorem proving technology,
prove that the program is correct by looking for possible counterexamples,
or \Def{models}, where your program goes wrong (\eg by violating an assertion).
Once the solver goes through \emph{all} possible counterexamples, and finds them
all to be inconsistent (\ie impossible),
it considers the program to be correct.
Normally, it would take virtually forever, for there is very large number of
possible counterexamples, one for every input to the function (values stored in
the heap also count as input).
To workaround this problem, the SMT solver considers
\Def{partial models}, \ie 
sets of statements about the state of the program.
For example, the model description may say \vcc{x == 7}, \vcc{y > x}
and \vcc{*p == 12}, which describes all the concrete models, where
these statements hold. There is great many such models,
for example one for each different values \vcc{y} and other program variables,
not even mentioned in the model.

It is thus useful to think of the SMT solver as sitting there with
a possible model, and trying to find out whether the model is consistent or not.
For example, if the description of the model says that \vcc{x > 7} and
\vcc{x < 3}, then the solver can apply rules of arithmetic, conclude this is
impossible, and move on to a next model.
The SMT solvers are usually very good in finding inconsistencies in models
where the statements describing them do not involve universal quantifiers.
With quantifiers things tend to get a bit tricky.

For example, let's say the model description states that the two
following facts are true:
\begin{VCC}
\forall unsigned i; i < 10 ==> a[i] > 7
a[4] == 3
\end{VCC}
The meaning of the universal quantifier is that it should hold
not matter what we substitute for \vcc{i}, for example
the universal quantifier above implies the following facts (which
are called \Def{instances} of the quantifier):
\begin{VCC}
 4 < 10 ==>  a[4] > 7  // for i == 4
\end{VCC}
which happens to be the one needed to refute our model,
\begin{VCC}
11 < 10 ==> a[11] > 7  // for i == 11
\end{VCC}
which is trivially true, because false implies everything, and
\begin{VCC}
 k < 10 ==>  a[k] > 7  // for i == k
\end{VCC}
where \vcc{k} is some program variable of type \vcc{unsigned}.

However, there is potentially infinitely many such instances, and certainly too many
to enumerate them all.
Still, to prove that our model candidate is indeed contradictory
we only need the first one, not the other two.
Once the solver adds it to the model description,
it will simplify \vcc{4 < 10} to true,
and then see that \vcc{a[4] > 7} and \vcc{a[4] == 3} cannot hold
at the same time.

The question remains: how does the SMT solver decide that the first
instance is useful, and the other two are not?
This is done through so called \Def{triggers}.
Triggers are either specified by the user or inferred automatically
by the SMT solver or the verification tool.
In all the examples before we just relied on the automatic trigger
inference, but as we go to more complex examples, we'll need to consider
explicit trigger specification.

A trigger for a quantified formula is usually some subexpression 
of that formula, which contains all the variables that the formula
quantifies over.
For example, in the following formula:
\begin{VCC}
\forall int i; int p[int]; is_pos(p, i) ==> f(i, p[i]) && g(i)
\end{VCC}
possible triggers include the following expressions
\vcc|is_pos(p, i)|, \vcc|p[i]|, and also \vcc|f(i, p[i])|,
whereas \vcc|g(i)| would not be a valid trigger, because
it does not contain \vcc|p|.

Let's assume that \vcc|is_pos(p, i)| is the trigger. 
The basic idea is that when the SMT solvers considers a model,
which mentions \vcc|is_pos(q, 7)| (where \vcc|q| is, \eg a local variable), then the formula
should be instantiated with \vcc|q| and \vcc|7| substituted
for \vcc|p| and \vcc|i| respectively.

Note that the trigger \vcc|f(i, p[i])| is \Def{more restrictive} than
\vcc|p[i]|: if the model contains \vcc|f(k, q[k])| it also contains \vcc|q[k]|.
Thus, a ``bigger'' trigger will cause the formula to be instantiated less often,
generally leading to better proof performance, but also possibly preventing
VCC from proving some assertions.

Triggers cannot contain boolean operators or the equality operator.
As of the current release, arithmetic operators are allowed, but cause warnings
and work unreliably, so you should avoid them.

A formula can have more than one trigger.
It is enough for one trigger to match in order for the formula
to be instantiated.

The explicit triggers are listed in \vcc|{...}|, after the quantified variables.
They don't have to be subexpressions of the formula. 
We'll see some examples of that later. 
However, the implicit, solver-selected, triggers always are subexpressions of the formula.
To select default triggers the SMT solver first considers all valid subexpression triggers,
in the example above that would be:
\vcc|is_pos(p, i)|, \vcc|p[i]|, and \vcc|f(i, p[i])|.
Then, it looks if any of these is a subexpression of another.
If it is so, the bigger of the two is discarded.
This leads to discarding \vcc|f(i, p[i])|.
Note that this is the \emph{least} restrictive set of
triggers possible, that is one that will trigger \emph{most} often.
Thus, specifying explicit triggers will usually make them more restrictive.%
\footnote{ Unless you use a trigger which is not a subexpression of the formula. }
Also, adding additional explicit triggers, will make the quantified formula trigger more often.
In future, it will likely be VCC (which has a lot more information available),
not the solver, who will decide on default triggers, but for now the SMT solver
choices might not be what you want.

\begin{note}
\textbf{Multi-triggers}:
Consider the following formula:
\begin{VCC}
\forall int a, b, c; P(a, b) && Q(b, c) ==> R(a, c)
\end{VCC}
There is no subexpression here, which would contain all the variables
and not contain boolean operators.
In such case we need to use a \Def{multi-trigger}, which
is a set of expressions which together cover all variables.
An example trigger here would be \vcc|{P(a, b), Q(b, c)}|.
It means that for any model, which has both \vcc|P(a, b)|
and \vcc|Q(b, c)| (for the same \vcc|b|!), the quantifier
will be instantiated.
In case a formula has multiple multi-triggers, \emph{all}
expressions in at least \emph{one} of multi-triggers
must match for the formula to be instantiated.

If it is impossible to select any single-triggers in the formula,
and none are specified explicitly, Z3 will select \emph{some}
multi-trigger, which is usually not something that you want.
\end{note}


\subsubsection{Typical triggers}

\itodo{maybe we want a section like that?}

\begin{VCC}
\forall unsigned i; {a[i]} i < 100 ==> a[i] > 0
\end{VCC}

\begin{VCC}
\forall unsigned i, j; {f(i, j)} f(i, j) == i + j * 2
\end{VCC}

\subsubsection{Matching loops}

Consider a model description
\begin{VCC}
\forall struct Node *n; {\mine(n)} \mine(n) ==> \mine(n->next)
\mine(a)
\end{VCC}
Let's assume the SMT solver will instantiate the quantifier with \vcc{a}, yielding:
\begin{VCC}
\mine(a) ==> \mine(a->next)
\end{VCC}
It will now add \vcc{\mine(a->next)} to the set of facts
describing the model.
This however will lead to instantiating the quantifier again,
this time with \vcc{a->next}, and in turn again with
\vcc{a->next->next} and so forth.
Such situation is called a \Def{matching loop}.
The SMT solver would usually cut such loop at a certain depth,
but it might make the solver run out of time, memory, or both.

Note that, if you skip the explicit trigger annotation, by the definition
above, \vcc|{\mine(n)}| and \vcc|{n->next}| are still going to be default
triggers of the formula above, still leading to the matching loop.

To avoid matching loop we need to use a different, more restrictive,
trigger, for example \vcc|{\mine(n->next)}|.
This will cause the quantifier to be instantiated only when the current
model talks about \vcc{n->next} already.
It is thus more ``goal-oriented''.
This is a typical pattern when specifying properties of recursive data-structures
using quantified formulas in VCC.
This is what our example does, however instead of using the shorthand
notation, it uses explicit owns set membership.
\itodo{we need to fix that}

So the upside of the more restrictive explicit trigger is that it avoids
excessive quantifier instantiations.
The downside is that if the SMT solver is missing some instantiations,
it might fail to rule out a model and report a bogus counterexample.
This doesn't happen in for our list, but we'll see such problems
(but with solutions!) later.

%\subsection{Hinting triggers}
%
%Consider a quantified formula \vcc|\forall T x; {hint: H} E|.
%Intuitively the hint annotation states that the expression \vcc{H} (which can
%refer to \vcc{x}) might have something to do with proving \vcc{E}.
%In our invariant example, we state that list ownership of \vcc{n->next}
%might have something to do with proving the \vcc{followers[n]}
%is \vcc{followers[n->next]} plus \vcc{n->data}.


