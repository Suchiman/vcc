\section{Introduction}
This tutorial is an introduction to verifying C code with VCC. Our
primary audience is programmers who want to write correct code and
verification engineers who want to check code for correctness. The
only prerequisite is a working understanding of C. 

To use VCC, you must first \emph{annotate} your code to specify how
your functions and data structures are meant to be used, and what your
functions guarantee to their callers.
VCC then
takes your program and tries to \emph{prove} (mathematically) that
your program meets these specifications.  Unlike most program
analyzers, VCC doesn't look for bugs, or analyze an abstraction of
your program; if VCC certifies that your program is correct, then your
program really should be correct
\footnote{
  In reality, this isn't
  really a guarantee, because VCC itself might have bugs. But in
  practice, this is unlikely to cause you to accidentally verify an
  incorrect program, unless you find and intentionally exploit such a
  bug. 
  Another source of bugs that could slip into verified software would be the compiler,
  the operating system, and the hardware. 
  These are generally more likely to introduce bug than VCC.
  % This is way too arcane to be mentioned in the intro. --M
  %In addition, VCC currently doesn't do the checks needed to
  %ignore memory system optimizations on multiprocessor machines, e.g.,
  %processor store buffering on x64 machines; this will be remedied in the near
  %future.
  }. 

To check your program, VCC generates a number of mathematical
statements (called \Def{verification conditions}) whose proofs
suffice to guarantee the program's correctness, and tries to prove
these statements using an automatic theorem prover. If any of these
proofs fail, VCC reflects these failures back to you in terms of the
program itself (as opposed to the formulas used in the theorem prover).
For example, if your program uses division
somewhere, and VCC is unable to prove (from what it thinks holds at the
point at which the division is done) that the divisor is nonzero, it
will report this to you as a program error at that point in the
program. 
% Seems like a redundant information.
%(If you use VCC from within Visual Studio, it will show in
%your program text the place where the error is, just like a syntax
%error.) 
This doesn't mean that your program is necessarily incorrect;
most of the time, especially when verifying code that is already well-tested,
it is because your specifications aren't strong
enough to guarantee that the suspected error doesn't occur.
Typically, you fix this ``error'' by strengthening your
specifications. This might lead to other error reports, necessitating
the strengthening of other specifications, so verification is in
practice an iterative process.  
Quite often this process will reveal a genuine programming error.

\itodo{the following paragraph should be moved out of here}
Annotating your program sometimes requires doing some extra
programming.  For example, your annotations might need to talk about a
set of users of a data structure, where the implementation only
maintains a count of them.  You would then need to include \Def{ghost
  data} to store this set and write small bits of \Def{ghost code} to
update it.  Ghost code is seen by VCC but not by the C compiler, and
so introduces no runtime overhead. Part of the VCC philosophy is that
programmers would rather do extra programming than drive interactive
theorem provers, so ghost code is the preferred way to help VCC
understand why your program works.  Thus, you interact with VCC
entirely at the level of of code and program states; usually, you can
safely ignore the mathematical reasoning going on ``under the hood''.

This tutorial covers basics of VCC annotation language. By the time
you have finished working through it, you should be able to use VCC to
verify some nontrivial programs. It doesn't cover the theoretical
background of VCC, implementation details, or advanced topics;
information on these can be found on the VCC
homepage\footnote{\url{http://vcc.codeplex.com/}}.

%%  These topics are covered
%% separately~\cite{lci}.  A high-level overview of the VCC tool chain is
%% also available separately~\cite{Cohen:TPHOLs2009-23}.

You can use VCC either from the command line or from Visual Studio
2008 (VS).
The VS interface offers easy access to different components of
VCC tool chain and is thus generally recommended,
but invoking VCC from command line will be also covered.
VCC can be downloaded from its homepage.
Make sure to check out installation instructions\footnote{\url{http://vcc.codeplex.com/wikipage?title=Install}},
as they contain important information about installation prerequisites 
and setting include paths.

%\subsection{Notational conventions}

\begin{note}
  Throughout the tutorial, we'll use notes like this one to discuss
  topics, which can be skipped on the first reading, either because
  they are somewhat more advanced, arcane, or not so important.
\end{note}

  Because this is a tutorial, we will occasionally provide a simplified (and
  therefore not strictly correct) explanation of what is going on, providing
  some additional clarification in the footnotes,\footnote{Like this one.}
  which can be skipped on first reading.

  Definitions will be introduced with \Def{italic boldface}.

\subsection{Top-level To-Do}

\begin{itemize}
\item use \vcc{\old} in the \vcc{copy()} example
\item get rid of inline axioms in \vcc{mod()}
\item fix the \vcc{lsearch()} array readability annotations
\item add bubble-sort example; add another sort as excercise
\item explain \vcc{\at()}
\item explain out parameters
\end{itemize}

%\subsection{Running VCC from the command line}
%\todo{More options?}
%The easiest way to call VCC on a set of files is
%\begin{verbatim}
%vcc [/f:funs] [/inspector] [/modelviewer] files
%\end{verbatim}
%Via the \verb!/f! switch a comma-separated list of functions to
%verify may be provided. The \verb!/inspector! (or \verb|/i|) switch causes the Z3 Inspector to be
%displayed while the verification is running, to monitor what VCC is
%trying to do. The \verb!/modelviewer! (or \verb|/mv|) switch causes VCC to display models for
%the errors that it finds.
%If there is more than one error, the active model can be switched in the Model menu.
% 
%\subsection{Running VCC from VS}
%\itodo{this should be introduced along with the examples}
%If you right-click within a C source file,
%several VCC commands are made available, depending on what kind of
%construction IntelliSense thinks you are in the middle of. The choice
%of verifying the entire file is always available. If you click within
%the definition of a struct type, VCC will offer you the choice of
%checking admissibility for that type (a concept explained in
%section \ref{}). If you click within the body of a function, VCC should offer
%you the opportunity to verify just that function. However,
%IntelliSense often gets confused about the syntactic structure of
%VCC code, so it may not give these context-dependent
%options. However, if you select the name of a function and then right
%click, it will allow you to verify just that function.
%
%If you want to run the VCC inspector during verification, this
%option can be selected from the Verify$\rightarrow$Settings menu. If you want
%to look at the error model for a particular error, right-click on
%error (in the source), and choose ``Show VCC error model''\todo{This
%  should really say ``VCC error model'', to not expose Z3.}
