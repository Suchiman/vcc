\section{Loop Invariants}

For the most part, what VCC knows at a control point can be
computed from what it knew at the immediately preceding control
points. But when the control flow contains a loop, VCC faces a
chicken-egg problem, since what it knows at the top of the loop (i.e.,
at the beginning of each loop iteration) depends not only on what it
knew just before the loop, but also on what it knew just before it
jumped back to the top of the loop from the loop body.

Rather than trying to guess what it should know at the top of a loop,
VCC lets you tell it what it should know, by providing a \Def{loop
  invariant}. To make sure that the loop invariant does indeed hold 
whenever control reaches the top
of the loop, VCC asserts that the invariant holds wherever control
jumps to the top of the loop -- namely, on loop entry, at the end of
the loop body, and at \vcc{continue} statements within the loop body.
In addition, VCC knows at the top of a loop
that any variable that is not modified in the loop has 
the same value it had on entry to the loop%
\footnote{ Because of aliasing, it is not always obvious to VCC that a
  variable is not modified in the body of the loop. However, VCC can
  check it syntactically for a local variable if you never take the
  address of that variable.}. We simulate this by having VCC forget
(at loop entry) everything it knew about variables that are modified
in the loop body.

Let's look at an example:
\vccInput[]{c/02_div.c}

\noindent
The \vcc{mod()} function computes a reminder of a integer division
using iterated subtraction%
\footnote{Of course C has a built-in operator to calculate this,
but you can imagine that you are verifying code designed to execute on
a machine that doesn't have the operator built-in.}
%% (Later, we'll see similar examples with sets, which are built into
%% the specification language, but not into C.)
The loop invariant says that the \vcc{res % a} stays unchanged,
and equal to \vcc{a % b}. 
VCC translates this example roughly as follows:
\vccInput[linerange={mod-999}]{c/02_div_assert.c}

\noindent
The invariant is asserted wherever control moves to the top of the
loop (here, on entry to the loop and at the end of the loop body). On
loop entry, VCC forgets the value of each variable modified in the
loop (in this case just \vcc{res}), and assumes the invariant (which
places some constraints on \vcc{res}).  VCC doesn't have to consider
the actual jump from the end of the loop iteration back to the top of
the loop (since it has already checked the loop invariant), so further
consideration of that branch is cut off with \vcc{_(assume \false)}.
The only way to exit this particular loop is through the
\vcc{break} statement, (which is translated to a \vcc{goto}). At this
control point, we know the loop invariant holds and that \vcc{res <  b}, 
which together imply the postcondition of the function. Since this is
the only location from which control jumps to \vcc{theEnd}, the
postcondition is also known at \vcc{theEnd}, so the assertion generated
by the postcondition follows.

If the loop had been of the form
\begin{VCC}
while (res >= b) 
  _( invariant a % b == res % b )
{
  res -= b;
}
\end{VCC}
the assert/assume translation would be exactly the same: the invariant
would be assumed before checking the guard, despite the fact that
guard syntactically precedes the invariant.

% This is still about array 
% This example isn't really about the unnecessity of invariants
%% Sometimes invariants are not required, in particular when the loop
%% doesn't modify any interesting locations. 
For a more interesting example of a loop, consider 
the following function that uses linear search to determine if a value
occurs within an array:
\todo{Change the following to use \vcc{thread_local} instead of \vcc{wrapped}.}
\vccInput{c/03_lsearch.c}

\noindent
Thus, the postcondition guarantees that when the returned value
is not \vcc{UINT_MAX}, then \vcc{elt} is indeed found at the returned
index.
This doesn't require an invariant, because the non-\vcc{UINT_MAX} index
is returned only under that condition.
However this specification is not full: what about the case when the result is not found?
To express that an element is not in an array we will use a universal quantifier:

\vccInput{c/03_lsearch_full.c}

\noindent
The invariant \vcc{\forall unsigned j; j < i ==> ar[j] != elt} means that 
\vcc{ar[j]} is not \vcc{elt} for all \vcc{j} between \vcc{0} and \vcc{i - 1}.
In other words, take an arbitrary unsigned (and thus non-negative) integer \vcc{j}. 
If it happens to be less than \vcc{i} then the value in \vcc{ar[j]} is not \vcc{elt}.
Thus, the invariant says that the element was not found between \vcc{0}
and \vcc{i - 1}.
If the loop terminates with \vcc{i == sz}, then the postcondition follows.


\subsection{Review}
\todo{Put in some way to get to the relevant info about quantifiers
  and ghost data?}  

\itodo{I'm not sure how useful this review is. In particular the parts
where we explain the semantics of if statements and assignments
in terms of what VCC know just seem confusing. Programmers already
know what if statement or assignment does. 
I think it would be useful just to emphasize what VCC doesn't know,
for loops and function calls.
--M }

You have now learned enough to verify some nontrivial sequential
programs that use only base types and arrays.  This is already a very
rich domain for programming, and you should take some time using VCC
to verify some of the ``toy'' algorithms you learned in school. It's
also a good opportunity to review what we've learned so far.

At each control point within a function, VCC ``knows'' certain things
about the state of the program. Included in this knowledge is what
memory locations it can safely read or write. The computation of this
knowledge can be summarized as follows:
\begin{itemize}
\item
On entry to a function, it knows the preconditions of the function.
\item
A memory object is writable if it is unwrapped and is either listed in the 
writes clause of the function or was unwrapped after the function was entered.
\item
After \vcc{_(assume E)}, it knows what it knew before the assumption,
and in addition knows \vcc{E != 0}.
\item
\vcc{_(assert E)} asks VCC to prove that what it knows before the
assertion implies \vcc{E} (and report an error if it can't). 
It also assumes \vcc{E} afterward.
\item
\todo{Break this up into variable assignment and memory assignment?}
An assignment statement \vcc{v = E}, where \vcc{E} doesn't have a 
function call and doesn't mention \vcc{v}%
\footnote{
  If \vcc{E} mentions \vcc{v}, we can imagine the value of \vcc{v} being
  first copied into a fresh temporary variable, which is used in place
  of \vcc{v} within \vcc{E}.
}, asserts that the data needed to
compute \vcc{E} is readable, and that \vcc{v} is writeable. After the
assignment, it knows everything it knew before the assignment (except
for what it knew about the value of \vcc{v}), and additionally knows
that \vcc{v == E}. 
\item 
A function call \vcc{f(args)}, where \vcc{args} is a list of variables%
\footnote{
  If the arguments to the function call are expressions, we can think
  of these expressions being evaluated and assigned to temporary
  variables before the function call.
}, asserts that the \vcc{args} are readable, asserts that the objects
mentioned in the writes clauses of \vcc{f} are writeable,
asserts the preconditions of \vcc{f} (with the actual parameters
substituted for the formal parameters), forgets what it knew about
\vcc{v} and any objects mentioned in the writes clause of \vcc{f}, and
finally assumes the postconditions of \vcc{f}%
\footnote{If these postconditions use \vcc{\\old} to refer to parts of
  the state before the call, we can think of these parts of the state
  as copied to temporary variables prior to the call. The result of
  the function can be viewed as being put into a temporary variable of
  the caller.}
\item
For a conditional \vcc{if (p) S1 else S2}, it first asserts that
\vcc{p} is readable. At the beginning of \vcc{S1} (resp. \vcc{S2}), it
knows what it knew before the conditional, and in addition knows
\vcc{p != 0} (resp. \vcc{p == 0}). After the conditional, it knows the 
disjunction (``or'') of what it knew at the end of \vcc{S1} and what
we know at the end of \vcc{S2}.
\item
For a loop, it knows at the beginning of the loop body just what it
knew just before the loop (except that it forgets what it knew about
variables modified in the loop), and also knows the loop
invariant. Just before the loop, and at any point in the loop body where
control jumps back to the top of the loop (including the end of the
loop body), it asserts the loop invariant.
\end{itemize}

\subsection*{Exercises}

\begin{enumerate}
\item
Write and verify an iterative program that copies an array if ints from one
location to another. Repeat with 2-dimensional arrays.
\item
Write and verify an iterative program for binary search (a program
that checks whether a sorted array contains a given value).
\item
\itodo{we should implement one sort routine in the text, and ask for implementation
of another}
Write and verify an iterative program that sorts an array of ints using
bubblesort. You can assume that the input array contains pairwise
distinct elements. You can also try selection sort.
\item 
Write and verify a program that takes a 2-dimensional array of ints in
which every row and column is sorted, and checks whether a given int
occurs in the array.
\end{enumerate}
