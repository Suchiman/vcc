\section{Loop invariants}

For the most part, what VCC knows at a control point can be
computed from what it knew at the immediately preceding control
points. But when the control flow contains a loop, VCC faces a
chicken-egg problem, since what it knows at the top of the loop (i.e.,
at the beginning of each loop iteration) depends not only on what it
knew just before the loop, but also on what it knew just before it
jumped back to the top of the loop from the loop body.

Rather than trying to guess what it should know at the top of a loop,
VCC lets you tell it what it should know, by providing a \Def{loop
  invariant}. To make sure that the loop invariant does indeed hold 
whenever control reaches the top
of the loop, VCC asserts that the invariant holds wherever control
jumps to the top of the loop -- namely, on loop entry, at the end of
the loop body, and at \vcc{continue} statements within the loop body.
In addition, VCC knows at the top of a loop
that any variable that is not modified in the loop has 
the same value it had on entry to the loop%
\footnote{ Because of aliasing, it is not always obvious to VCC that a
  variable is not modified in the body of the loop. However, VCC can
  check it syntactically for a local variable if you never take the
  address of that variable.}. We simulate this by having VCC forget
(at loop entry) everything it knew about variables that are modified
in the loop body.

Let's look at an example:
\vccInput[]{c/02_div.c}

\noindent
\itodo{This example currently requires axioms about arithmetic that should actually
come by default with VCC.
This will be fixed soon.}
The \vcc{mod()} function computes a reminder of a integer division
using iterated subtraction%
\footnote{Of course C has a built-in operator to calculate this,
but you can imagine that you are verifying code designed to execute on
a machine that doesn't have the operator built-in.}
%% (Later, we'll see similar examples with sets, which are built into
%% the specification language, but not into C.)
The loop invariant says that the \vcc{res % a} stays unchanged,
and equal to \vcc{a % b}. 
VCC translates this example roughly as follows:
\vccInput[linerange={mod-999}]{c/02_div_assert.c}

\noindent
The invariant is asserted wherever control moves to the top of the
loop (here, on entry to the loop and at the end of the loop body). On
loop entry, VCC forgets the value of each variable modified in the
loop (in this case just \vcc{res}), and assumes the invariant (which
places some constraints on \vcc{res}).  VCC doesn't have to consider
the actual jump from the end of the loop iteration back to the top of
the loop (since it has already checked the loop invariant), so further
consideration of that branch is cut off with \vcc{_(assume \false)}.
The only way to exit this particular loop is through the
\vcc{break} statement, (which is translated to a \vcc{goto}). At this
control point, we know the loop invariant holds and that \vcc{res <  b}, 
which together imply the postcondition of the function. Since this is
the only location from which control jumps to \vcc{theEnd}, the
postcondition is also known at \vcc{theEnd}, so the assertion generated
by the postcondition follows.

If the loop had been of the form
\begin{VCC}
while (res >= b) 
  _( invariant a % b == res % b )
{
  res -= b;
}
\end{VCC}
the assert/assume translation would be exactly the same: the invariant
would be assumed before checking the guard, despite the fact that
guard syntactically precedes the invariant.

% This is still about array 
% This example isn't really about the unnecessity of invariants
%% Sometimes invariants are not required, in particular when the loop
%% doesn't modify any interesting locations. 
For a more interesting example of a loop, consider 
the following function that uses linear search to determine if a value
occurs within an array:
\vccInput{c/03_lsearch.c}

\noindent
The syntax \vcc{\thread_local_array(ar, sz)} means that the
array pointed to by \vcc{ar}, with \vcc{sz} elements is thread-local.
This is required so that the function can read the array.
The postcondition guarantees that when the returned value
is not \vcc{UINT_MAX}, then \vcc{elt} is indeed found at the returned
index.
This doesn't require an invariant, because the non-\vcc{UINT_MAX} index
is returned only under that condition.
However this specification is not full: what about the case when the result is not found?
To express that an element is not in an array we will use a universal quantifier:

\vccInput{c/03_lsearch_full.c}

\noindent
The invariant \vcc{\forall unsigned j; j < i ==> ar[j] != elt} means that 
\vcc{ar[j]} is not \vcc{elt} for all \vcc{j} between \vcc{0} and \vcc{i - 1}.
In other words, take an arbitrary unsigned (and thus non-negative) integer \vcc{j}. 
If it happens to be less than \vcc{i} then the value in \vcc{ar[j]} is not \vcc{elt}.
Thus, the invariant says that the element was not found between \vcc{0}
and \vcc{i - 1}.
If the loop terminates with \vcc{i == sz}, then the postcondition follows.

\subsection{Overflows and unchecked arithmetic}
\label{sect:overflows}

This topic is not really related to loops, but you're very likely to run into it
while verifying loops operating on integers.
Let's have a look at an example:

\vccInput{c/02_hash_fail.c}

\noindent
VCC complains that the hash-computing operation might overflow.
Normally, this is not something to be expected (integer overflows
are a common source of security vulnerabilities nowadays),
which is why VCC warns about it by default.
However, we do expect this in a function computing a hash of a buffer.
To indicate that this overflow behavior is desired we use \vcc{_(unchecked)},
with syntax similar to a regular C type-cast.
This annotation applies to the following expression, and indicates that
you expect that there might be overflows in there.
Thus, replacing the body of the loop with the following
makes the program verify:

\vccInput[linerange={update-endupdate}]{c/02_hash.c}

Note that ``unchecked'' does not mean ``unsafe''.
The C standard mandates modulo interpretation for unsigned overflows,
and signed overflows are usually implementation-defined to use two-complement.
It just means that VCC will loose information about the operation.
For example consider:
\begin{VCC}
int a, b;
// ...
a = b + 1;
_(assert a < b)
\end{VCC}
This will either complain about possible overflow of \vcc{b + 1} or succeed.
However, the following might complain about \vcc{a < b}, if VCC does not know
that \vcc{b + 1} doesn't overflow.
\begin{VCC}
int a, b;
// ...
a = _(unchecked)(b + 1);
_(assert a < b)
\end{VCC}
Think of \vcc{_(unchecked)E} as computing the expression using mathematical 
integers, which never overflow, and then casting the result to the desired range.
VCC knows that \vcc{_(unchecked)E == E} if \vcc{E} fits in the proper range,
and some other basic facts about \vcc{(unsigned)-1}.
If you need anything else, you will need to resort to bit-vector
reasoning (\secref{bv}).

Let's have a look at another example:
\vccInput{c/02_rand.c}
\noindent
The reason we needed to use unchecked cast here, is that the C library
\vcc{rand()} function is specified to return a signed integer.

\begin{note}
In fact, the C standard, mandates the following specification:
\begin{VCC}
int rand(void)
  _(ensures 0 <= \result && \result <= RAND_MAX);
\end{VCC}
Thus, in principle the \vcc{_(unchecked)} shouldn't be required in the
example above. 
However,
VCC currently does not come with specifications for C standard library functions.
We plan to setup a open-source project, where you'll be able to contribute such
specifications.
It is indeed unclear why does it return a signed integer, only to ensure that the return value
is never negative.
\end{note}

\subsection{Sorting}
\label{sect:sorting}

%\Def{Ghost data} contains auxiliary information needed to convince VCC about correctness of a program.
%You can think of it as data that the program maintains for the purpose of debugging.
%An example might be a program which only keeps track of count of foobars, whereas
%the specifications of that program also need to use the set of these foobars.
%\Def{Ghost code} is code which manipulates such data (\ie when you increment the count of foobars
%you need to add the specific foobar to the set). Ghost variables are just pieces of local ghost
%data, and ghost functions are functions, which can be only used in specifications and ghost code.
%
%The regular C compiler doesn't see the ghost code.
%Therefore it has no runtime effect, it's only there to help VCC understand why the program works.

%We shall start with ghost functions, which in this case is just a macro for another formula.
The function below implements the bozo-sort algorithm.
The algorithm works by swapping two random elements in an array, checking if the resulting array
is sorted, and repeating otherwise.
We do not recommend using it in production code:
it's not stable, and moreover has a fairly bad time complexity.
Still, it will serve us to illustrate the use of logic functions, and later (\secref{sorting-perm}) ghost data.

\vccInput[linerange={begin-out}]{c/04_bozosort.c}

\noindent
The meaning of:
\begin{VCC}
_(logic F(A) = E)
\end{VCC}
is similar to:
\begin{VCC}
#define F(A) E
\end{VCC}
except that it prevents
name capture and gives better error messages (\ie ones which mention both \vcc{E} and \vcc{F(A)}).

The other novel thing about this function is the writes clause on the array.
Indeed, all previous examples were only reading arrays, and this one is actually writing
the array.
The notation \vcc{\array_range(arr, len)} refers to all pointers into array
of size \vcc{len} pointed to by \vcc{arr}.
When \vcc{arr} is a pointer to non-struct type (as in the example above),
it expands to \vcc@{ &arr[0], &arr[1], ..., &arr[len-1] }@.
In addition to specifying the writes clause on the function, we also specify it on
the loop.
This is common for loops, which write the heap.
Generally, a writes clause on the loop is the same as the writes clause you would need to
write on a function which contained \emph{only} that loop.
If there is no writes clauses on the loop, VCC takes the writes clause from the 
function, but interprets it with respect to the beginning of the function,
and not beginning of the loop.
Thus, in general, when the loop writes the heap, you will want to specify a writes clause on it.

The specification that we use is that the output of the sorting routine is sorted.
Unfortunately, we do not say that it's actually a permutation of the input.
We'll show how to do that in \secref{sorting-perm}.

\subsection{Review}
%\todo{Put in some way to get to the relevant info about quantifiers
%  and ghost data?}  
%
%\itodo{I'm not sure how useful this review is. In particular the parts
%where we explain the semantics of if statements and assignments
%in terms of what VCC know just seem confusing. Programmers already
%know what if statement or assignment does. 
%I think it would be useful just to emphasize what VCC doesn't know,
%for loops and function calls.
%--M }

You have now learned enough to verify some nontrivial sequential
programs that use only base types and arrays.  This is already a very
rich domain for programming, and you should take some time using VCC
to verify some of the ``toy'' algorithms you learned in school. It's
also a good opportunity to review what we've learned so far.

At each control point within a function, VCC ``knows'' certain things
about the state of the program. Included in this knowledge is what
memory locations it can safely read or write. The computation of this
knowledge can be summarized as follows:
\begin{itemize}
\item
On entry to a function, it knows the preconditions of the function.
\item
A memory object is writable if it is mutable and is either listed in the 
writes clause of the function or was mutable after the function was entered.
\item
After \vcc{_(assume E)}, it knows what it knew before the assumption,
and in addition knows \vcc{E != 0}.
\item
\vcc{_(assert E)} asks VCC to prove that what it knows before the
assertion implies \vcc{E} (and report an error if it can't). 
It also assumes \vcc{E} afterward.
%\item
%\todo{Break this up into variable assignment and memory assignment?}
%An assignment statement \vcc{v = E}, where \vcc{E} doesn't have a 
%function call and doesn't mention \vcc{v}%
%\footnote{
%  If \vcc{E} mentions \vcc{v}, we can imagine the value of \vcc{v} being
%  first copied into a fresh temporary variable, which is used in place
%  of \vcc{v} within \vcc{E}.
%}, asserts that the data needed to
%compute \vcc{E} is readable, and that \vcc{v} is writeable. After the
%assignment, it knows everything it knew before the assignment (except
%for what it knew about the value of \vcc{v}), and additionally knows
%that \vcc{v == E}. 
\item 
A function call \vcc{f(args)}, 
%where \vcc{args} is a list of variables
%\footnote{
%  If the arguments to the function call are expressions, we can think
%  of these expressions being evaluated and assigned to temporary
%  variables before the function call.
%}, 
asserts that the \vcc{args} are readable, asserts that the objects
mentioned in the writes clauses of \vcc{f} are writeable,
asserts the preconditions of \vcc{f} (with the actual parameters
substituted for the formal parameters), forgets what it knew about
\vcc{v} and any objects mentioned in the writes clause of \vcc{f}, and
finally assumes the postconditions of \vcc{f}.
If these postconditions use \vcc{\\old} to refer to parts of
the state before the call, we can think of these parts of the state
as copied to temporary variables prior to the call. The result of
the function can be viewed as being put into a temporary variable of
the caller.
%\item
%For a conditional \vcc{if (p) S1 else S2}, it first asserts that
%\vcc{p} is readable. At the beginning of \vcc{S1} (resp. \vcc{S2}), it
%knows what it knew before the conditional, and in addition knows
%\vcc{p != 0} (resp. \vcc{p == 0}). After the conditional, it knows the 
%disjunction (``or'') of what it knew at the end of \vcc{S1} and what
%we know at the end of \vcc{S2}.
\item
For a loop, it knows at the beginning of the loop body just what it
knew just before the loop (except that it forgets what it knew about
variables modified in the loop), and also knows the loop
invariant. Just before the loop, and at any point in the loop body where
control jumps back to the top of the loop (including the end of the
loop body), it asserts the loop invariant.
\end{itemize}



\subsection*{Exercises}

\begin{enumerate}
\item
Write and verify an iterative program that copies an array if ints from one
location to another.% Repeat with 2-dimensional arrays.
\item
Write and verify an iterative program for binary search (a program
that checks whether a sorted array contains a given value).
\item
Write and verify an iterative program that sorts an array of ints using
bubblesort. The specification should be the same as for bozo-sort above.
%\item 
%Write and verify a program that takes a 2-dimensional array of ints in
%which every row and column is sorted, and checks whether a given int
%occurs in the array.
\end{enumerate}

