\section{Object invariants}

Verification in VCC, especially when it comes to concurrent programs,
it not so much about loop invariants or functions contracts,
as about object invariants.
Object invariants are predicates describing ``consistent'' states of objects.
Take for example a safe string structure implemented with a
statically allocated array (we'll move to dynamic allocation later).

\vccInput[linerange={obj-init}]{c/05_safestring.c}

\noindent
The invariant of \vcc{struct SafeString} states that consistent instances
of that structure will shorter than \vcc{SSTR_MAXLEN} and \vcc{'\0'}-terminated.
To refer to the current instance in an invariant we can use \vcc{\this}, but
we can also omit it (the example above shows both).

Talking about instances of structures in C is a tricky business. 
In plain C a structure type generally just gives some guidelines how to interpret
arrays of bytes.
Some programming languages, like Java or ML, have a much more disciplined
view of memory:
one allocates an object of given type, not merely $n$ bytes of memory,
and later there is no way to change the type assigned to that memory location.
Most C programs also follow this model, most of the time:
when a function gets a pointer to \vcc{struct Foo}, it usually doesn't
expect to find data corresponding to some \vcc{struct Bar} there.
Still, there are rare situations where the program needs to
change type assignment of a pointer.
The most common is in the memory allocator, which needs to create
and destroy objects of arbitrary types from arrays of bytes
in its memory pool.
Therefore, the general rule in VCC is that programs are forced to
follow the strict Java-like type discipline, except for places
where explicit annotations indicate reinterpretations of type assignment
(these annotations are explained in \secref{memmodel}).

In (sequential) Java programs it is usually enough to check that
\vcc{o} is non-null in order to deduce that accessing \vcc{o.f} is safe.
This is not the case is C, particularly not in concurrent C.
The pointer \vcc{o} might be non-null, but still point to an invalid
(for example unallocated) memory location.
VCC inserts an assertion in front of every memory access,
\vcc{*p}%
\footnote{
  Of course this also applies to \vcc{x->y}, which is understood
  as \vcc{*(&x->y)}, and other memory accesses.
}, in the program. 
This assertion will check that memory location pointed to by \vcc{p}
is currently allocated (which is something any sound C verifier
would need to do), but also that this memory location 
\emph{is currently assigned type} \vcc{T}, where \vcc{T} is the
statically known type of \vcc{*p}.
There are restriction on type assignment (to be explained in \secref{memmodel}), which guarantee
that C pointers behave like type-safe, Java-like objects.
It should be noted that one can still access memory almost arbitrarily,
but it requires additional annotations.

Let's then have a look at how one initializes an instance of the \vcc{SafeString} structure.

\vccInput[linerange={init-append}]{c/05_safestring.c}

\noindent
First, the function announces it will write the span of \vcc{s}. This is a shorthand
for:
\begin{VCC}
  _(writes s, &s->len, &s->content[0], &s->content[1], ..., 
           &s->content[SSTR_MAXLEN])
\end{VCC}
%pointers to all fields of \vcc{s}.%
%\footnote{
%  This is a bite more complicated when embedded structures are involved,
%  see \secref{TODO}.
%}
Second, it announces that when it's done, \vcc{s} will be \Def{wrapped}, and indeed
at the end it ``wraps'' \vcc{s}.
This means, that at the end of the function the invariant of \vcc{s} holds.
One could ask why wouldn't the invariant always hold, but already the \vcc{sstr_init()}
function provides a good explanation: its whole purpose is to establish the invariant,
for a freshly allocated object, for which the invariant (generally) doesn't yet hold
(because it contains garbage).
Similarly, sometimes one wants to perform a few updates on an object, and between
them the invariant doesn't have to hold.
Finally, most functions that only read an object, will require that it is consistent.
For example:

\vccInput[linerange={append-out}]{c/05_safestring.c}

\noindent
A pattern emerges: an object comes from the memory allocator unwrapped, 
we initialize and wrap it.
When we want to read it, it should be wrapped, and we know its invariant holds.
A function operating on an object unwraps it to temporarily suspend invariants, perform updates, and wraps it again.

Let's then get a bit more precise about this wrap/unwrap protocol. 

\subsection{Wrap/unwrap Protocol}

Because invariants do not always hold,
in VCC one needs to explicitly state which objects are consistent.
This is expressed with \vcc{\consistent(...)} function.
One should think of this function as returning a value of special ghost field,
let's call it the \Def{consistency flag}, defined on every object.
The invariants need to hold only when consistency flag is true.
When the flag is false they need not hold (but of course still can).
The flag is initially (on newly allocated objects) false,
and one needs to set it to false before disposing objects.

In addition to the consistency flag each object has an \Def{owner field}.
We also refer to it using a function, \vcc{\owner(...)}.
The owner itself is also an object, but VCC provides objects, of \vcc{\thread} type, to represent threads,
so that threads can also own objects.
The idea is that the owner of \vcc{o} should have some special rights to \vcc{o} that others do not.
In particular, the owner of \vcc{o} can transfer ownership of \vcc{o} to
another object (\eg the memory allocator, in order to dispose \vcc{o}).

When verifying a body of a function VCC assumes that it is being executed by some
particular thread.
The \vcc{\thread} object representing it is referred to as \vcc{\me}.

(Some of) the rules of ownership and consistency:
\begin{enumerate}
\item every atomic step of the program has to preserve invariants of all consistent objects 
\item only the owning thread can modify inconsistent object
\item threads own themselves
\item only threads can own inconsistent objects
\end{enumerate}
Thus, by the first two rules, VCC allows updates of objects in the following two situations:
\begin{enumerate}
\item the updated object is consistent, the update is atomic, and the update preserves the invariant of the object,
\item or the updated object is inconsistent and the update is performed by the owning thread.
\end{enumerate}
In the first case to ensure that an update is atomic, VCC requires that the
updated field has a \vcc{volatile} modifier.
There is a lot to be said about atomic updates in VCC, and we shall do
that in \secref{TODO}, but for now we're only considering sequentially
accessed objects, with no \vcc{volatile} modifiers.
For such objects we can assume that they \emph{do not change}
when they are consistent.

So a thread needs to make the object inconsistent to update it.
Because making it inconsistent counts as an update, the thread needs
to own it first.
This is performed by the unwrap operation, which translates to the following:
(1) assert that the object wrapped (consistent and owned by the current thread), 
(2) assume the invariant (as a consequence of rule 1, the invariant holds for every consistent object),
and (3) set the consistent flag to false.
The wrap operation does just the reverse:
(1) assert that the object is unwrapped (inconsistent and owned by the current thread;
note that this does not mean ``not wrapped''),
(2) assert the invariant, 
and (3) set the consistent flag to true.
Let's then have a look at the definitions of \vcc{\wrapped(...)} and \vcc{\unwrapped(...)}%
and at the assert/assume desugaring of \vcc{sstr_append_char()} function.

\begin{VCC}
predicate \wrapped(\object o) =
  \consistent(o) && \owner(o) == \me;
predicate \unwrapped(\object o) =
  !\consistent(o) && \owner(o) == \me;
\end{VCC}
\vccInput[linerange={assert-999}]{c/05_safestring_assert.c}

\noindent
The definitions of \vcc{\wrapped(...)} and \vcc{\unwrapped(...)}
use the \vcc{\object} type.
It is much like \vcc{void*}, in the sense that it is a wildcard for any pointer type.
However, unlike \vcc{void*}, it also carries the dynamic information about the type of the pointer.
It can be only used in specifications.

\subsubsection{The Writes}

The final issue to explain for the example above is the treatment of the \vcc{writes} clauses.
The initialization function posses no problems: it lists all the fields is assigns to
(the \vcc{\span(s)} notation is just syntactic sugar, as explained before).
However, the \vcc{sstr_append_char()} declares that it will only write
\vcc{s}, wheres it writes \vcc{s->content[...]} and \vcc{s->len}.
Listing \vcc{s} allows one to unwrap \vcc{s}, and unwrapping \vcc{s}
makes all its field writable. 
The next section elaborates on why is it useful.

\subsection{Ownership Trees}

Often objects stand for abstractions that are implemented with
more than just one object.
For example a hash table will consist of a control object, an array of pointers,
and linked lists pointed to by those pointers.
However, before we get to hash tables, we shall first 
reimplement our \vcc{SafeString} to have dynamically
allocated buffer. The logical string consists of the control object holding the length
and the array of bytes holding the content.

\vccInput[linerange={obj-append}]{c/06_safestring_dynamic.c}

\noindent
The type \vcc{char[10]} denotes an array with exactly 10 elements,
and thus the type \vcc{char[capacity]} denotes an array with \vcc{capacity} elements.
Such types can be only used in casts, as in \vcc{(char[capacity])content},
which means: take the pointer \vcc{content} and interpret it as an array
of \vcc{capacity} elements of type \vcc{char}.
This notation is used so we can think of arrays as objects (of some weird type).
The other way to think about it is that \vcc{content} represents just
one object of type \vcc{char}, whereas \vcc{(char[capacity])content}
represents the array.
One can use \vcc{\any} instead of \vcc{char} in all of the above, to let
VCC infer the type.

Now, that we've packed a bunch of characters into an object, we can make
the \vcc{SafeString} own it.
And indeed, this is what \vcc{SafeString} specifies in its invariant:
the syntax \vcc{\mine(o1, ..., oN)} is roughly equivalent
(the exact translation is provided later)
to:
\begin{VCC}
\owner(o1) == \this && ... && \owner(oN) == \this
\end{VCC}

OK, so what's the benefit of objects owning other objects?
The main benefit is abstraction: the function operating on a string
\vcc{s}, still need to only mention \vcc{s} in their \vcc{writes}
clause, not \vcc{s->content} or any other objects the string might comprise of.

\vccInput[linerange={append-alloc}]{c/06_safestring_dynamic.c}

\noindent
First, the syntax:
\begin{VCC}
_(unwrapping o) { ... }
\end{VCC}
is equivalent to:
\begin{VCC}
_(unwrap(o)); { ... } _(wrap(o));
\end{VCC}
Thus, at the beginning of the function the string is owned by the current thread and consistent (\ie wrapped),
whereas the content is owned by the string and consistent.
After unwrapping the string, the ownership of the content goes to the current thread,
but the content remains consistent.
Thus, unwrapping the string makes the string unwrapped, and the content wrapped.
Then we unwrap the content (which doesn't own anything, so the thread gets no new wrapped objects), and perform the changes,
and wrap the content.
Finally, we wrap the string.
This transfers ownership of the content from the current thread to the string, so the content is no longer wrapped (but still consistent).
Let's then have a look at the part of the assert/assume translation
that deals with ownership:

\vccInput[linerange={append-999}]{c/06_safestring_dynamic_assert.c}

\noindent
To make it easier to read, we made it store the \vcc{s->content} pointer
casted to an array into a temporary variable.
Also, an invariant of \vcc{o} is referred to as \vcc{\inv(o)}
(one can use that in regular VCC specifications).
As you can see there are two ownership transfers.
The first one is kind of clear: when unwrapping an object everything that it used
to own, will be now owned by the thread.
The second one is much more tricky: 
in VCC the ownership relations are specified fully through invariants.
Thus, when wrapping an object, we would need to give it ownership
of \emph{some} other objects, to satisfy its invariant.
Of course, in general the invariant might be such that the choice
is unclear, for example:
\begin{VCC}
struct S {
  struct T *a, *b;
  _(invariant \mine(a) || \mine(b))
};
\end{VCC}
When wrapping an instance of \vcc{struct S}, should we transfer ownership of \vcc{a}, \vcc{b}, or both?
By default VCC will reject such invariants, and only allow \vcc{\mine(...)}
as a top-level conjunct in an invariant.
Such invariants are supported, but need additional annotation
and manual ownership transfer when wrapping, see \secref{dynamic-ownership}.


\subsection{Dynamic ownership}
\label{sect:dynamic-ownership}
