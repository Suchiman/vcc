\section{Object invariants}
\label{sect:invariants}

%% Verification in VCC, especially when it comes to concurrent programs,
%% it not so much about loop invariants or functions contracts,
%% as about object invariants. 

When verifying a function, we are usually reasoning about only a very
small part of the program state. This is particularly true for a
concurrent program, where concurrency depends on minimizing the amount
of state that a thread ``owns''. Since a thread only knows about data
that it owns (and perhaps read-only data that it shares), another
mechanism is needed to regulate data that is shared between
threads. But these same mechanisms provide a way to minimize the
amount of knowledge a thread needs at any program point.

In VCC, this mechanisms is object invariants, which are associated
with compound C types (\vcc{struct}s and \vcc{union}s). The invariants
of a type describe how ``well-behaved'' objects of of that type
behave. In this section, we consider only the static aspects of this
behavior, namely what the ``consistent'' states of an object are. For
example, consider the following type definition of (\vcc{'\0'}-terminated)
safe strings implemented with statically allocated arrays (we'll see
dynamic allocation later).

\vccInput[linerange={obj-init}]{c/05_safestring.c}

\noindent
The invariant of \vcc{SafeString} states that consistent
\vcc{Safestring}s have length less than \vcc{SSTR_MAXLEN} and are
\vcc{'\0'}-terminated.  Within a type invariant, \vcc{\this} refers to
the (address of the) current instance of the type (as in the first
invariant), but fields can also be referred to directly (as in the
second invariant). 

Because memory in C is allocated without initialization, no nontrivial
object invariant could be enforced to hold at all times. Thus, in VCC
the invariant of an object \vcc{o} is guaranteed to hold only when the
object is marked as \vcc{\consistent}. A \vcc{\consistent} object that
is 
A thread can mark an object as
\vcc{\consistent} by wrapping
Wrapping an object involves checking that
its invariants hold. Nonvolatile fields of an object can't change
while the object is wrapped, so to change its fields, the object must
first be unwrapped. 

We can initialize a \vcc{SafeString} as follows:
\vccInput[linerange={init-append}]{c/05_safestring.c}

\noindent
For \vcc{p} a pointer to a structured type, we distinguish between
writing \vcc{p} and writing the members (fields) of \vcc{p}; the former 
allows only wrapping and unwrapping \vcc{p}. 
\todo{Should talk about the array rules somewhere.}
For a pointer \vcc{p} of structured type, \vcc{\span(p)} returns the
set of pointers to members of \vcc{p}. Arrays of base types produce
one pointer for each base type component, so in this example,
\vcc{\span(s)} abbreviates the set
\begin{VCC}
  s, &s->len, &s->content[0], &s->content[1], ..., &s->content[SSTR_MAXLEN])
\end{VCC}
%pointers to all fields of \vcc{s}.%
%\footnote{
%  This is a bite more complicated when embedded structs are involved,
%  see \secref{TODO}.
%}
Thus, the writes clause says that the function not only can wrap
\vcc{s} but can also write the fields of \vcc{s}. 
The postcondition says that the function returns with \vcc{s} wrapped,
which implies also that the invariant of \vcc{s} holds; this invariant
is checked when the object is wrapped.

A function that modifies a wrapped object will first unwrap it, make
the necessary updates, and wrap the object again (which causes another
check of the object invariant). Unwrapping an object adds all of its
members to the writes set of a function, so such a function has to
report that it writes the object, but does not have to report writing
the fields of the object.

Finally, a function that only reads an object need not unwrap, and so
will not list it in its writes clause. For example:

\vccInput[linerange={append-out}]{c/05_safestring.c}

\noindent


\subsection{Wrap/unwrap protocol}
\label{sect:wrap-unwrap}

Because invariants do not always hold,
in VCC one needs to explicitly state which objects are consistent.
This is expressed with \vcc{\consistent(...)} function.
Think of this function as returning a value of special ghost field,
let's call it the \Def{consistency flag}, defined on every object.
The invariants need to hold only when consistency flag is true.
When the flag is false they need not hold (but of course still can).
The flag is initially (on newly allocated objects) false,
and one needs to set it to false before disposing objects.

In addition to the consistency flag each object has an \Def{owner field}.
We also refer to it using a function, \vcc{\owner(...)}.
The owner itself is also an object, but VCC provides objects, of \vcc{\thread}
type, to represent threads of execution, so that threads can also own objects.
The idea is that the owner of \vcc{o} should have some special rights to \vcc{o} that others do not.
In particular, the owner of \vcc{o} can transfer ownership of \vcc{o} to
another object (\eg a thread can transfer ownership of \vcc{o} from itself to the memory allocator, 
in order to dispose of \vcc{o}).

When verifying a body of a function VCC assumes that it is being executed by some
particular thread.
The \vcc{\thread} object representing it is referred to as \vcc{\me}.

(Some of) the rules of ownership and consistency:
\begin{enumerate}
\item every atomic step of the program has to preserve invariants of all consistent objects 
\item a thread can only modify fields of in
\item threads own themselves
\item only threads can own inconsistent objects
\end{enumerate}
Thus, by the first two rules, VCC allows updates of objects in the following two situations:
\begin{enumerate}
\item the updated object is consistent, the update is atomic, and the update preserves the invariant of the object,
\item or the updated object is inconsistent and the update is performed by the owning thread.
\end{enumerate}
In the first case to ensure that an update is atomic, VCC requires that the
updated field has a \vcc{volatile} modifier.
There is a lot to be said about atomic updates in VCC, and we shall do
that in \secref{TODO}, but for now we're only considering sequentially
accessed objects, with no \vcc{volatile} modifiers.
For such objects we can assume that they \emph{do not change}
when they are consistent, so the only way to change their fields is to
first make them inconsistent, \ie via method 2.

So a thread needs to make the object inconsistent to update it.
Because making it inconsistent counts as an update, the thread needs
to own it first.
This is performed by the unwrap operation, which translates to the following:
(1) assert that the object wrapped (consistent and owned by the current thread), 
(2) assume the invariant (as a consequence of rule 1, the invariant holds for every consistent object),
and (3) set the consistent flag to false.
The wrap operation does just the reverse:
(1) assert that the object is unwrapped (inconsistent and owned by the current thread;
note that this does not mean ``not wrapped''),
(2) assert the invariant, 
and (3) set the consistent flag to true.
Let's then have a look at the definitions of \vcc{\wrapped(...)} and \vcc{\unwrapped(...)}%
and at the assert/assume desugaring of \vcc{sstr_append_char()} function.

\begin{VCC}
predicate \wrapped(\object o) =
  \consistent(o) && \owner(o) == \me;
predicate \unwrapped(\object o) =
  !\consistent(o) && \owner(o) == \me;
\end{VCC}
\vccInput[linerange={assert-out}]{c/05_safestring_assert.c}

\noindent
The definitions of \vcc{\wrapped(...)} and \vcc{\unwrapped(...)}
use the \vcc{\object} type.
It is much like \vcc{void*}, in the sense that it is a wildcard for any pointer type.
However, unlike \vcc{void*}, it also carries the dynamic information about the type of the pointer.
It can be only used in specifications.

\paragraph{The writes}

The final issue to explain for the example above is the treatment of the \vcc{writes} clauses.
The initialization function posses no problems: it lists all the fields it assigns to
(the \vcc{\span(s)} notation is just syntactic sugar, as explained before).
However, the function \vcc{sstr_append_char()} declares that the
only location it will write is
\vcc{s}, whereas the function writes also \vcc{s->content[...]} and \vcc{s->len}.
Listing \vcc{s} in writes allows one to unwrap \vcc{s}, and unwrapping \vcc{s}
makes all its field writable. 
The next section elaborates on why such generality in writes clauses is useful.

\subsection{Ownership trees}

Often objects stand for abstractions that are implemented with
more than just one physical object.
As a simple example, consider our \vcc{SafeString}, changed to have dynamically
allocated buffer.
The logical string object consists of the control object holding the length
and the array of bytes holding the content.
In reality such abstraction go further, \eg a hash table might consist of a control object, an array of buckets,
and the attached linked lists.

\vccInput[linerange={obj-append}]{c/06_safestring_dynamic.c}

\noindent
In C the type \vcc{char[10]} denotes an array with exactly 10 elements.
VCC extends that location to allow
the type \vcc{char[capacity]} denoting an array with \vcc{capacity} elements
(where \vcc{capacity} is a variable).
Such types can be only used in casts, as in \vcc{(char[capacity])content}%
\todo{make sure the example doesn't use \vcc{any[...]}},
which means: take the pointer \vcc{content} and interpret it as an array
of \vcc{capacity} elements of type \vcc{char}.
This notation is used so we can think of arrays as objects (of some weird type).
The other way to think about it is that \vcc{content} represents just
one object of type \vcc{char}, whereas \vcc{(char[capacity])content}
represents the array.
\todo{can you?}
\vcc{\any} can be used instead of \vcc{char} in the casts above, to let
VCC infer the type.

Now, that we've packed a bunch of characters into an object, we can make
the \vcc{SafeString} own it.
And indeed, this is what \vcc{SafeString} specifies in its invariant:
the syntax \vcc{\mine(o1, ..., oN)} is roughly equivalent
(the exact translation is provided later)
to:
\begin{VCC}
\owner(o1) == \this && ... && \owner(oN) == \this
\end{VCC}

OK, so what's the benefit of objects owning other objects?
The main benefit is abstraction: the function operating on a string
\vcc{s}, still need to only mention \vcc{s} in their \vcc{writes}
clause, not \vcc{s->content} or any other objects the string might comprise of.

\vccInput[linerange={append-alloc}]{c/06_safestring_dynamic.c}

\noindent
First, the syntax:
\begin{VCC}
_(unwrapping o) { ... }
\end{VCC}
is equivalent to:
\begin{VCC}
_(unwrap(o)); { ... } _(wrap(o));
\end{VCC}
Thus, at the beginning of the function the string is owned by the current thread and consistent (\ie wrapped),
whereas the content is owned by the string and consistent.
After unwrapping the string, the ownership of the content goes to the current thread,
but the content remains consistent.
Thus, unwrapping the string makes the string unwrapped, and the content wrapped.
Then we unwrap the content (which doesn't own anything, so the thread gets no new wrapped objects), perform the changes,
and wrap the content.
Finally, we wrap the string.
This transfers ownership of the content from the current thread to the string, so the content is no longer wrapped (but still consistent).
Let's then have a look at the part of the assert/assume translation
that deals with ownership:

\vccInput[linerange={append-out}]{c/06_safestring_dynamic_assert.c}

\noindent
To make it easier to read, we made it store the \vcc{s->content} pointer
casted to an array into a temporary variable.
Also, an invariant of \vcc{o} is referred to as \vcc{\inv(o)}.
As you can see there are two ownership transfers.
The first one is kind of clear: when unwrapping an object everything that it used
to own, will be now owned by the thread.
The second one is much more tricky: 
\todo{Penny: very unclear}
in VCC the ownership relations are specified fully through invariants.
Thus, when wrapping an object, we would need to give it ownership
of \emph{some} other objects, such that its invariant is satisfied.
Of course, in general the invariant might be such that the choice
is unclear, for example:
\begin{VCC}
struct S {
  struct T *a, *b;
  _(invariant \mine(a) || \mine(b))
};
\end{VCC}
When wrapping an instance of \vcc{struct S}, should we transfer ownership of \vcc{a}, \vcc{b}, or both?
By default VCC will reject such invariants, and only allow \vcc{\mine(...)}
as a top-level conjunct in an invariant.
Invariants like the ones above are supported, but need additional annotation
and manual ownership transfer when wrapping, see \secref{dynamic-ownership}.


\subsection{Dynamic ownership}
\label{sect:dynamic-ownership}

When a struct is annotated with \vcc{_(dynamic_owns)} the ownership transfers
during wrapping need to performed explicitly, but \vcc{\mine(...)} can
be freely used in its invariant, including using it under a universal
quantifier.

\vccInput[linerange={obj-set}]{c/07_table.c}

\noindent
The invariant of \vcc{struct SafeContainer} states that it owns its underlaying array,
as well as all elements pointed to from it.
It also states that there are no duplicates in that array.
Let's now say we want to change a pointer in that array,
from \vcc{x} to \vcc{y}.
After such operation, the container should own whatever it used
to own minus \vcc{x} plus \vcc{y}.
To facilitate such transfers VCC introduces the \Def{owns set}.
It is essentially the inverse of the owner field.
It is defined on every object \vcc{o} and referred to as \vcc{\owns(o)}.
VCC maintains that:
\begin{VCC}
\forall object p, q; \consistent(p) ==> 
  (q \in \owns(p) <==> \owner(p) == q)
\end{VCC}
The operator \vcc{<==>} reads ``if and only if'', and is simply boolean
equality (or implication both ways), with a binding priority lower than implication.
That is, for consistent \vcc{p}, the set \vcc{\owns(p)} contains exactly
the objects owned by \vcc{p}.
Additionally, the unwrap operation does not touch the owns set,
that is after unwrapping \vcc{p}, the \vcc{\owns(p)} still contains
all that objects that \vcc{p} used to own.
Finally, the wrap operation will attempt to transfer ownership
of everything in the owns set to the object being wrapped.
This requires that the current thread has write access to these objects
and that they are wrapped.

Thus, the usual pattern is to unwrap the object, potentially modify the owns
set, and wrap the object.
Note that when no ownership transfers are needed, one can just unwrap
and wrap the object, without worrying about ownership.
Let's have a look at an example, which does perform an ownership transfer:

\vccInput[linerange={set-use}]{c/07_table.c}

\noindent
The \vcc{sc_set()} function transfers ownership of \vcc{s} to \vcc{c},
and additionally leaves object initially pointed to by \vcc{s->strings[idx]}
wrapped, \ie owned by the current thread.
Moreover, it promises that this object is \Def{fresh}, \ie the thread did not own
it directly before.
This can be used in the call site:

\vccInput[linerange={use-out}]{c/07_table.c}

\noindent
In the contract of \vcc{sc_add} the string \vcc{s} is mentioned
in the writes clause, but in the postcondition we do not say it's wrapped.
Thus, asserting \vcc{\wrapped(s)} after the call fails.
On the other hand, asserting \vcc{\wrapped(o)} fails before the call,
but succeeds afterwards.
Additionally, \vcc{\wrapped(c)} holds before and after as expected.

%This effectively tells the call site that it no longer has ownership of \vcc{s}.
%Additionally, when we look at the invariant of \vcc{c}, we can even figure out
%that \vcc{s} is indeed no longer wrapped.
%
%VCC does know that the invariant of \vcc{s} holds (because the object is consistent),
%but we need to explicitly assert it to bring it into theorem prover scope.
%Normally, this is done by \vcc{unwrap}, or \vcc{requires \wrapped(...)}.
%
%Note the distinction between not being able to prove \vcc{P} and 
%being able to prove \vcc{!P}.
%

\subsection{Ownership domains}

An ownership domain of an object \vcc{o} is the set of objects
that it owns and their ownership domains, plus \vcc{o} itself.
In other words, it's the set of objects that are transitively
owned by a given object.

\todo{this remark might be confusing, and possibly no longer true}
In general there can be cycles in the ownership graph,
and so the definition above should be understood in the least fix point sense.
However, every object has exactly one owner and threads own themselves,
and thus anything that
is owned by a thread will have a ownership domain that is a tree.
It is most useful to think about ownership as trees, and disregard
the degenerate cycle case.

Thus, the current thread will own a number of objects, some of them
unwrapped (inconsistent and thus not owning anything), but other wrapped (consistent and
so with possibly large ownership domains).
The ownership domains of the wrapped objects are disjoint
(in the grand ownership tree of the thread they are all at the same level).

Mentioning a wrapped object in the writes clause gives the function
a right to unwrap it, and then unwrap everything it owns.
Thus, it effectively gives write access to its entire ownership domain.
\todo{make it a real example that actually means something}
Consider the following piece of code:

\begin{VCC}
void f(T *p) 
  _(writes p) { ... }
...
T *p, *q, *r;
_(assert \wrapped(p) && \wrapped(q) && p != q);
_(assert q \in \domain(q))
_(assert r \in \domain(q))
_(assert q->f == 1 && r->f == 1);
f(p);
_(assert q->f == 1 && r->f == 1);
\end{VCC}

\noindent
The function \vcc{\domain(o)} returns the ownership
domain of \vcc{o}.
We have three objects, two of them are wrapped.
We call a function that will update one of them.
We now want to know if the values of the other two are preserved.
Clearly, because \vcc{p != q} and both are wrapped, then
\vcc{q} is not in the ownership domain of \vcc{p},
so value of \vcc{q->f} should be preserved by the call.
But what about \vcc{r->f}?
This depends on whether \vcc{r \in \domain(p)},
because \vcc{f(p)} could have written everything
in \vcc{\domain(p)} (according to its writes clause).
The ownership domain is the transitive closure of the inverse of the
owner field.
\todo{explain transitive closure, logic and things}
Unfortunately, the concept transitive
closure is not expressible in first order logic.
More precisely, we can (usually) prove that something \emph{is} in the ownership
domain, but not (directly) that something \emph{is not}.
Therefore, we need to hack our way around it: there are implicit
assumptions in VCC about the ownership domains not overlapping.
Once we prove \vcc{p != q} and \vcc{r \in \domain(q)}
when VCC knows that functions not writing \vcc{q} are not
going to touch \vcc{r}.
Unfortunately, we need to explicitly tell VCC in
which ownership domain \vcc{r} is to make use of that.
This is what the assertion \vcc{r \in \domain(q)} is doing.
\itodo{say something about the other in domain assertion;
it would be best if we didn't need it}

\begin{note}
Before allowing a write to \vcc{*p} VCC will assert \vcc{\unwrapped(p)}.
Additionally, it will assert that either \vcc{p} is in the writes
clause, or the consistency or ownership of \vcc{p} was updated after the current
function started executing.
Thus, after you unwrap an object, you modify consistency of all its fields,
which provides the write access to them.
Also, you modify ownership of all the objects that it used to own, providing
write access to unwrap these objects.
In case a write clause is specified on a loop, think of an implicit function
definition around the loop.
\end{note}

\subsection{Simple sequential admissibility}
\label{sect:admissibility0}

Until now we've been skimming on the issue of what you can actually
mention in an invariant. 
Intuitively the invariant of an object should talk about consistent states
of that very object, not some other objects.
However, for example the invariant of the \vcc{struct SafeString} 
talks about the values stored in its underlaying array.
This also seems natural: one should be able to mention things
from the ownership domain of \vcc{o} in \vcc{o}'s invariant.

This is important, because VCC checks only invariants of objects
that you actually modify, and as we recall the most important
verification property we want to enforce (and which we rely on in our
verifications) is that all invariant of all (consistent) objects 
are always preserved.
For example, consider:

\begin{VCC}
struct A { 
  int x;
};
struct A *a; // global variable
struct B {
  int y;
  _(invariant a->x == y)
};
void foo()
  _(writes a)
{
  _(unwrapping a) {
    a->x = 7;
  }
}
\end{VCC}

\noindent
In \vcc{foo()}, when wrapping \vcc{a} we would only check invariant
of \vcc{a}, not all \vcc{struct B}s that could possibly depend on it.
Thus, an action which preserves invariant of modified object breaks invariant of another object.
For this reason VCC makes the invariant of \vcc{struct B} inadmissible.
In fact, for all invariant VCC will check that they are admissible.
We shall refrain now from giving a full definition of admissibility, as 
it only makes full sense after we learn about two-state object invariants
(see \secref{inv2}), but for sequential programs the useful approximation
is that invariants that only talk about their ownership domains are admissible.


