\section{Function contracts}

So let's start.
The first example we're going to look at is very simple, but it will serve
us well to illustrate the most basic VCC concepts.

\vccInputSC{c/01_min1.c}

\noindent
The \vcc{main()} function changes the variable \vcc{position} to a new
value, but tries to make sure the \vcc{position} doesn't exceed \vcc{LIMIT}.
In a full example we would have some code computing \vcc{newPos}
and using \vcc{position} in place of \vcc{// ...}, but we can actually
verify the code as is: \vcc{newPos} is uninitialized,
but this only means
VCC will not assume anything particular about its value.

\begin{VCC}
/*`C:\somewhere> vcc 01_min1.c
Verification of min succeeded.
Verification of main succeeded.
C:\somewhere>`*/
\end{VCC}

\noindent
VCC is happy about our program, it reports that nothing can go wrong.
However, because we did not say what do we want the program to do,
it only means it will not crash.
The next step is to convey our ideas on what the program should
to the verifier, and have it validate them.
\todo{the example uses the current syntax, the text will mostly talk about the new one}
A simplest way of doing that is through \vcc{spec( assert E )}
statements, where \vcc{E} is a boolean expression.
It is an instruction to the verifier asking it to try to prove
that in any execution of the program \vcc{E} will be true.
All such annotations, surrounded by \vcc{spec( ... )}
are there only for VCC.
The regular C compiler should not see them,
so the program with annotation behaves exactly as the program
without them.
\footnote{
  The \vcc{<assert.h>} header file defines an \vcc{assert(E)}
  macro with similar functionality: \vcc{E} will be evaluated
  at runtime and the program will be terminated if \vcc{E} is false.
  The goal of VCC is not to perturb the execution,
  and moreover the expressions VCC can show to hold are not always
  checkable at runtime.
}
For the regular C compiler the \vcc{<vcc.h>} header file contains
just a single definition:
\begin{VCC}
#define spec(...) /* nothing */
\end{VCC}
VCC does not use this definition, and instead parses the inside of \vcc{spec( ... )}
annotations.
Let's then have a look at the example.

\vccInput{c/01_min2.c}

\noindent
The listing above presents both the source code and the output
of VCC, typeset in a different font and color.
The actual file name of the example is replaced with \vcc{/*`testcase`*/}.
As we can see VCC failed to prove our assertion,
even though by looking at implementation of \vcc{min()}
one can easily see it always holds.
The reason is that verification in VCC is modular:
it will not look into body of \vcc{min()} when
verifying \vcc{main()}.%
\footnote{
  If VCC did look into \vcc{min()} when verifying \vcc{main()}
  then in general we would quickly run into scalability problems.
  It is sometimes useful to perform such inlining during verification,
  we will look into that issue later.
}
However, clearly, the correctness of \vcc{main()} depends on what \vcc{min()}
does.
Because of that VCC requires the programmer to annotation function
with \Def{contracts}.
There are two basic kinds of contracts on functions:
\begin{itemize}
\item the requirements before the function is called, and
\item the conditions that the implementation of the function ensures to be true when it finishes.
\end{itemize}
These are given with \vcc{spec( requires E )} and \vcc{spec( ensures E )} respectively.

\vccInput[linerange={min-endmin,out-}]{c/01_min3.c}

\noindent
The function \vcc{min()} doesn't have any specific entry requirements:
it can be always called.
Thus we say \vcc{spec( requires \true )} to say that the entry condition is
always true.
The postcondition states that the value returned from the function (referred to as \vcc{\result})
will be no bigger than any of the input arguments \vcc{a} and \vcc{b}.

Note that \vcc{\true} and \vcc{\result} are spelled with a backslash.
All VCC keywords, which can be used in expressions, start with a backslash.
This does not apply to the first keyword after \vcc{spec}, because it cannot
be confused with a C identifier (thus you are still free to have, \eg,
a function called \texttt{requires} or \texttt{assert}).

Another thing to note is that the specification of \vcc{min()} is partial:
\todo{this might be not the best place to put this note?}
it only says that what you get out of it is no bigger than what you put in.
The full specification would also say \vcc{\result == a || \result == b}.
While for simple functions like \vcc{min()} it is often useful to give the full
specification, the primary function of specifications for more complex
functions is hiding implementation details.
Thus, the specifications will be partial most of the time, will only
talk about important aspects of what the function does.
The decision on what is important will depend on the person specifying
the function, and the needs of the calling function.

The verification of \vcc{main()} only depends on the specification of \vcc{min()}.
To illustrate that let's replace \vcc{<} with \vcc{>} in the return statement of \vcc{min()}.
The output of verification is:

\vccInput[linerange={out-}]{c/01_min4.c}

\noindent
VCC says that verification of \vcc{main()} is OK, only \vcc{min()} is broken.

\subsection{Assumptions and assertions}

The way verification process works can be usually explained using the
notion of assertions and assumptions.
We've already seen assertions, that is annotations of the form \vcc{spec( assert E )}.
When VCC sees such an assertion in the code
it tries to see if from what it ``knows'' about the program it can infer
that \vcc{E} is true.
If it cannot it will report an error.
Otherwise, in the following code the verifier will ``know'' \vcc{E}.
So an assertion can be understood as a hint for the verifier:
you should better be able to infer \vcc{E}, and by the way, you can use
\vcc{E} in your later proofs.

An assumption, written \vcc{spec( assume E )}, has only the second component:
it makes the verifier ``know'' \vcc{E} holds in the following code of the function.
It does not need to prove that it will actually hold, it just assumes it will.
Of course, introducing such assumptions is unsafe, for example consider:

\begin{VCC}
void perc(int x) {
  spec( assume x != 0 )
  return 100 / x;
}
int main()
{
  perc(0);
  return 0;
}
\end{VCC}

\noindent
Without the assumption the verifier would complain about possible division by zero.
With the assumption this goes through VCC without problems, and it crashes at runtime.
The promise that verified programs will never crash is only valid if you do not
use assumptions.

So are such assumptions useful at all?
One case is interaction with hardware: you might know the hardware is going to leave
specific I/O register positive, and an assumption is a way to communicate that to VCC.
What is however much more common is use of assumption when debugging your specifications:
when the program does not verify you might try to temporarily add assumptions in a bet
``if VCC knew that, would it verify my program?''.
Once you find what is that thing VCC doesn't know, but what makes it verify the program,
you can figure out how to specify rest of your program, so that is knows it.

One however needs to be very careful with assumptions.
An assumption of the form \vcc{spec( assume \false )} makes everything below
it verify, including null pointer dereferences and the like.
This is because it constrains the verification to all the execution
where \vcc{\false} holds, which is never.
Note that there are many creative ways of writing \vcc{\false}, including
\vcc{spec( assume 1 != 0 )} or \vcc{spec( assume x < 0 )} when \vcc{x} is \vcc{unsigned}.

Another use of assumption is for explaining how some specification construct work ---
internally VCC will often translate them to assertions and assumptions, and presenting
such translation helps understanding.

For example, when verifying function body
its \vcc{requires} clause becomes an assumption at the beginning, and its
\vcc{ensures} clause becomes an assertion just before each of its \vcc{return} statements
(including the implicit return statement at its end).
Conversely, when verifying a call to such function, its \vcc{requires} clause is asserted
and its \vcc{ensures} clause is assumed. For example, our example program is translated
as follows:

\vccInput{c/01_min_assert.c}

As for call itself, because the \vcc{min()} function above has no visible specification,
VCC doesn't know anything about the value it might possibly return.
Therefore, as far as VCC's understanding is concerned, the line:
\begin{VCC}
position = min(newPos, LIMIT);
\end{VCC}
could be replaced with \vcc{position = anything();}, that is assigning an unspecified value
to the variable \vcc{position}. 
The only knowledge about it comes from the following assumption.

Let's also consider the meaning of \vcc{spec( requires \false )}.
When verifying function body it translates to an assumption.
As we have noted this will make the body of function verify,
regardless what it contains.
On the other hand, you will be unable to verify call to such a function
from outside.
\todo{Do we want that here?}

Conversely, \vcc{spec( ensures \false )} will prevent verification
of the body of the function, but will make the function that calls
it verify.

As we can see, in each case there is something that does not verify.
However, because of this one should be careful when interpreting
VCC answers: successful verification of a function is only meaningful
if everything it calls was verified.

\subsection{Fancy example}

Finally, 
\todo{kill this?}
to show something little less trivial, the implementation of \vcc{min()} can surprisingly be more involved.
For example the one below does not use a branch.

\vccInput[]{c/01_min5.c}

\noindent
The syntax:
\begin{VCC}
  spec( assert {bv} \forall int x; (x & -1) == x )
\end{VCC}

\noindent
VCC to prove the assertion using the fixed-length bit vector theory, a.k.a. machine integers.
This is then used as a lemma to prove the postcondition.

