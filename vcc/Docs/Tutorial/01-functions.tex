\section{Function contracts}

So let's start.
The first example we're going to look at is very simple, but it will serve
us well to illustrate the most basic VCC concepts.

\vccInputSC{c/01_min1.c}

\noindent
The \vcc{main()} function changes the variable \vcc{position} to a new
value, but tries to make sure the \vcc{position} doesn't exceed \vcc{LIMIT}.
In a full example we would have some code computing \vcc{newPos}
and using \vcc{position} in place of \vcc{// ...}, but we can actually
verify the code as is: \vcc{newPos} is uninitialized,
but this only means
VCC will not assume anything particular about its value.

\begin{VCC}
/*`C:\somewhere> vcc 01_min1.c
Verification of min succeeded.
Verification of main succeeded.
C:\somewhere>`*/
\end{VCC}

\noindent
VCC is happy about our program, it reports that nothing can go wrong.
However, because we did not say what do we want the program to do,
it only means it will not crash.
The next step is to convey our ideas on what the program should
to the verifier, and have it validate them.
\todo{the example uses the current syntax, the text will mostly talk about the new one}
A simplest way of doing that is through \vcc{spec( assert E )}
statements, where \vcc{E} is a boolean expression.
It is an instruction to the verifier asking it to try to prove
that in any execution of the program \vcc{E} will be true.
All such annotations, surrounded by \vcc{spec( ... )}
are there only for VCC.
The regular C compiler should not see them,
so the program with annotation behaves exactly as the program
without them.
\footnote{
  The \vcc{<assert.h>} header file defines an \vcc{assert(E)}
  macro with similar functionality: \vcc{E} will be evaluated
  at runtime and the program will be terminated if \vcc{E} is false.
  The goal of VCC is not to perturb the execution,
  and moreover the expressions VCC can show to hold are not always
  checkable at runtime.
}
For the regular C compiler the \vcc{<vcc.h>} header file contains
just a single definition:
\begin{VCC}
#define spec(...) /* nothing */
\end{VCC}
VCC does not use this definition, and instead parses the inside of \vcc{spec( ... )}
annotations.
Let's then have a look at the example.

\vccInput{c/01_min2.c}

\noindent
The listing above presents both the source code and the output
of VCC, typeset in a different font and color.
The actual file name of the example is replaced with \vcc{/*`testcase`*/}.
As we can see VCC failed to prove our assertion,
even though by looking at implementation of \vcc{min()}
one can easily see it always holds.
The reason is that verification in VCC is modular:
it will not look into body of \vcc{min()} when
verifying \vcc{main()}.%
\footnote{
  If VCC did look into \vcc{min()} when verifying \vcc{main()}
  then in general we would quickly run into scalability problems.
  It is sometimes useful to perform such inlining during verification,
  we will look into that issue later.
}
However, clearly, the correctness of \vcc{main()} depends on what \vcc{min()}
does.
Because of that VCC requires the programmer to annotation function
with \Def{contracts}.
There are two basic kinds of contracts on functions:
\begin{itemize}
\item the requirements before the function is called, and
\item the conditions that the implementation of the function ensures to be true when it finishes.
\end{itemize}
These are given with \vcc{spec( requires E )} and \vcc{spec( ensures E )} respectively.

\vccInput[linerange={min-endmin,out-}]{c/01_min3.c}

\noindent
The function \vcc{min()} doesn't have any specific entry requirements:
it can be always called.
Thus we say \vcc{spec( requires \true )} to say that the entry condition is
always true.
The postcondition states that the value returned from the function (referred to as \vcc{\result})
will be no bigger than any of the input arguments \vcc{a} and \vcc{b}.

Note that \vcc{\true} and \vcc{\result} are spelled with a backslash.
All VCC keywords, which can be used in expressions, start with a backslash.
This does not apply to the first keyword after \vcc{spec}, because it cannot
be confused with a C identifier (thus you are still free to have, \eg,
a function called \texttt{requires} or \texttt{assert}).

Another thing to note is that the specification of \vcc{min()} is partial:
\todo{this might be not the best place to put this note?}
it only says that what you get out of it is no bigger than what you put in.
The full specification would also say \vcc{\result == a || \result == b}.
While for simple functions like \vcc{min()} it is often useful to give the full
specification, the primary function of specifications for more complex
functions is hiding implementation details.
Thus, the specifications will be partial most of the time, will only
talk about important aspects of what the function does.
The decision on what is important will depend on the person specifying
the function, and the needs of the calling function.

The verification of \vcc{main()} only depends on the specification of \vcc{min()}.
To illustrate that let's replace \vcc{<} with \vcc{>} in the return statement of \vcc{min()}.
The output of verification is:

\vccInput[linerange={out-}]{c/01_min4.c}

\noindent
VCC says that verification of \vcc{main()} is OK, only \vcc{min()} is broken.
\todo{Do we want that here?}
This can be taken to an extreme: a specification \vcc{spec( ensures \false )}
states \vcc{\false} is true after the function returns. Of course \vcc{\false}
is never true, and therefore this specification means that the function never
returns.
If we placed \vcc{spec( ensures \false )} on \vcc{min()} we would be able to verify
anything (including dereferencing null pointers and the like) in the in \vcc{main()},
following call to \vcc{min()}.

Finally, 
\todo{kill this?}
to show something little less trivial, the implementation of \vcc{min()} can surprisingly be more involved.
For example the one below does not use a branch.

\vccInput[]{c/01_min5.c}

\noindent
The syntax:
\begin{VCC}
  spec( assert {bv} \forall int x; (x & -1) == x )
\end{VCC}

\noindent
VCC to prove the assertion using the fixed-length bit vector theory, a.k.a. machine integers.
This is then used as a lemma to prove the postcondition.

