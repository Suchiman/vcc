\section{Assert and assume}
\label{sect:assert-assume}

%\itodo{Penny: This section dives right into the meat. First, you need two things: 
%1. A general guide to annotation syntax
%2. A section that describes how to think in VCC terms is, you have to describe
%not only exactly what your code does at each step of the way, but what your
%program *doesnt* do. This latter point will nail people on loop verification
%every time. 
%After you do the how to think part, I suggest some simple exercises, if this is in fact to be a tutorial. The whole book can come later. 
%}
%\itodo{Michal: I'm not sure about 1., 2. might be good idea.}

Let's begin with a simple example:

\vccInputSC{c/01_minInline2.c}
This program (internally) sets \vcc{z} to the minimum of \vcc{x} and
\vcc{y}. In addition to the ordinary C code, this program includes an
\Def{annotation}, starting with \vcc{_(}, terminating with a closing
parenthesis, with balanced parentheses inside. The first identifier
after the opening parenthesis (in the program above it's \vcc{assert})
is called an \Def{annotation tag} and
identifies the type of annotation provided (and hence its function).
(The tag plays this role only 
at the beginning of an annotation; elsewhere, it would be treated as
an ordinary program identifier.)

An annotation of the form \vcc{_(assert E)}, called an \Def{assertion}, asks VCC to prove that
\vcc{E} is guaranteed to hold (\ie, evaluate to a value other than \vcc{0})
whenever control reaches the assertion%
\footnote{
  This interpretation changes slightly if \vcc{E} refers to
  memory locations that might be concurrently modified by other
  threads; see \secref{concurrency}}.  
Thus, the line \vcc|_(assert z <= x)| says
that when control reaches the assertion, \vcc{z} is no larger than \vcc{x}.
When VCC successfully verifies a program, it promises that all assertions
hold in \emph{every} possible execution of the program, considering all possible inputs,
all possible ways of scheduling concurrent threads, etc. 
% The following doesn't really clarify much
%% An \Def{execution} is a complete recording of all actions made by the program:
%% which branches were taken, what values were read and stored in memory
%% and so forth.
%% For a deterministic program, once you fix input data (\eg by saying in this and that
%% microsecond the user is going to click at that pixel and so forth),
%% you fix the execution.
%% An assertion causes VCC to try to \emph{prove} that \vcc{E} holds for \emph{all}
%% executions.

% There are only a few of these notes, so let's avoid them for now -E
% Also, this note is something we probably want people to read.
%\todo{should these notes be less prominent?}
%\begin{note}
It is instructive to compare \vcc{_(assert E)} with the macro
\lstinline|assert(E)| (defined in \lstinline|<assert.h>|), which
evaluates \vcc{E}  at runtime and aborts execution if \vcc{E}
doesn't hold. First, \lstinline|assert(E)| requires runtime overhead (at least
in builds where the check is made), whereas \vcc{_(assert E)} does
not. Second, \lstinline|assert(E)| will catch failure of the 
assertion only when it actually fails in an execution, whereas 
\vcc{_(assert E)} is guaranteed to catch the failure if it is
possible in \emph{any} execution. Third, because VCC doesn't have to
actually execute \vcc{_(assert E)}, it allows \vcc{E} to include
mathematical operations that cannot be executed, such as
quantification over infinite domains.
%\end{note}

To verify the function using VCC from the command line, save the source in a file called \lstinline|minimum.c|
and run VCC as follows:

\begin{VCC}
/*`C:\Somewhere\VCC Tutorial> vcc.exe minimum.c
Verification of main succeeded.
C:\Somewhere\VCC Tutorial>`*/
\end{VCC}


If instead you wish to use VCC Visual Studio plugin, load the solution \lstinline|VCCTutorial.sln|
% moved the information on the samples to the preface - E
%% (distributed with VCC), 
%% \itodo{
%% This isn't yet true. The samples are available only with VCC sources, available from
%% \url{http://vcc.codeplex.com/SourceControl/list/changesets}: click Download on the right,
%% get the zip file and navigate to \lstinline|vcc/Docs/Tutorial/c|.
%% }
%% \todo{we need to package the examples, but only after it is clear which ones are included in the tutorial}
locate the file with the example, and right-click on the program text.
You should get options to verify the file or just this function (either will work).

\begin{note}
If you right-click within a C source file,
several VCC commands are made available, depending on what kind of
construction IntelliSense thinks you are in the middle of. The choice
of verifying the entire file is always available. If you click within
the definition of a struct type, VCC will offer you the choice of
checking admissibility for that type (a concept explained in \secref{admissibility0}).
If you click within the body of a function, VCC should offer
you the opportunity to verify just that function. However,
IntelliSense often gets confused about the syntactic structure of
VCC code, so it might not always present these context-dependent
options. However, if you select the name of a function and then right
click, it will allow you to verify just that function.
\end{note}

VCC verifies this function successfully, which means that its
assertions are indeed guaranteed to hold and that the program cannot
crash%
\footnote{
  VCC currently doesn't check that your program doesn't run forever or
  run out of stack space, but future versions will, at least for sequential
  programs.  
}
If VCC is unable
to prove an assertion, it reports an error.  Try changing the
assertion in this program to something that isn't true and see what
happens. (You might also want to try coming up with some complex
assertion that is true, just to see whether VCC is smart enough to
prove it.)

Assertions, like all VCC annotations, 
are surrounded by \vcc{_( ... )} to indicate that they are
only for VCC, and are not part of the program being verified
For the regular C compiler the \vcc{<vcc.h>} header file defines:
\begin{VCC}
#define _(...) /* nothing */
\end{VCC}
VCC does not use this definition, and instead parses the inside of \vcc{_( ... )}
annotations.%
% there's not much point in putting into the tutorial an obscure
% feature that doesn't work -E
%% \footnote{
%%   You can prevent definition of \vcc{_}, and instead surround annotations with
%%   \vcc{__vcc_spec(...)}.
%%   This is controlled with \vcc{_VCC_DONT_USE_UNDERSCORE} macro-definition.
%%   \itodo{This doesn't work at the moment.} }



To understand how VCC works, and to use it successfully, it is useful to
think in terms of what VCC ``knows'' at various program points. In
this example, VCC initially knows nothing about the variables (since they
can initially hold any value). 
Just before the first assignment, VCC knows that 
\vcc{x <= y} (because execution followed that branch of the conditional), and
after the assignment, VCC also knows that \vcc{z == x}, 
so it knows that \vcc{z <= x}. Similarly, in the \vcc{else} branch,
VCC knows that \vcc{y < x} (because execution didn't follow the
\vcc{if} branch), and after the assignment to \vcc{z}, it also knows
that \vcc{z == y}, so it knows \vcc{z <= x}. Since 
\vcc{z <= x} is known to hold at the end of each branch of the
conditional, it is known to hold at the end of the conditional, so the
assertion is known to hold when control reaches it. In general,
VCC doesn't lose any information when reasoning about assignments and
conditionals. However, we will see that VCC
 some information when reasoning about loops and function calls,
which means additional annotations are necessary.

When VCC surprises you by failing to verify something that you think
it should be able to verify, it is usually because it doesn't know
something you think it should know. An assertion provides one way to
check whether VCC knows what you think it knows.

You can add to what VCC knows at a particular point with a second
type of annotation, called an \Def{assumption}.
The assumption \vcc{_(assume E)} tells VCC to ignore
the rest of an execution if \vcc{E} fails to hold (\ie if
\vcc{E} evaluates to \vcc{0}). 
Reasoning-wise, assumption simply adds \vcc{E} to what VCC
knows for subsequent reasoning. For example:
\begin{VCC}
int x, y;
_(assume x != 0)
y = 100 / x;
\end{VCC}
Without the assumption, VCC would complain about possible division by
zero (it checks for division by zero because it would cause the
program to crash).  Assuming the assumption, this error cannot happen.  
Since assumptions (like all annotations) are not seen by the compiler,
assumption failure won't cause the program to stop, and subsequent assertions
might be violated. To put it another way, if VCC verifies a program,
it guarantees that in any prefix of an execution
where all (user-provided) assumptions hold, all assertions will also
hold. Thus, your verification goal should be to eliminate as many assumptions as
possible (preferably all of them).

Although assumptions are generally to be avoided, they are nevertheless
sometimes useful:
\begin{itemize}
\item In an incomplete verification, assumptions can be used
  to mark the knowledge that VCC is missing, and guide further verification
  work possibly performed by different people.

\item When debugging a failed verification, you can use assumptions to
  narrow down the failed verification to a more specific failure
  scenario, perhaps even to a complete counterexample. 
% We should have chapter about it, not a cryptic mention here. --M
%  You can then
%  add additional (non-assumption) annotations to eliminate the
%  counterexample, weaken assumptions until you either hit another
%  counterexample (or finish the verification), and repeat the process.

\item Sometimes you want to assume something even though VCC can
  verify it, just to stop VCC from spending time proving it. For
  example, assuming \vcc{\false} allows VCC to 
  easily prove subsequent assertions, thereby focussing its
  attention on other parts of the code. Temporarily adding assumptions
  is a common tactic when developing annotations for complex functions.

\item Sometimes you want to make assumptions about the operating
  environment of a program. For example, you might want to assume that
  a 64-bit counter doesn't overflow, but don't want to justify it
  formally because it depends on extra-logical assumptions (like the
  speed of the hardware or the lifetime of the software). 
\item Assumptions provide a useful tool in explaining how VCC
  reasons about your program. We'll see examples of this throughout
  this tutorial.
\end{itemize}

%%  What is however much more common is
%% use of assumption when debugging your specifications: when the program
%% does not verify you might try to temporarily add assumptions in a bet
%% ``if VCC knew that, would it verify my program?''.  Once you find what
%% is that thing VCC doesn't know, but what makes it verify the program,
%% you can figure out how to specify rest of your program, so that is
%% knows it.

% The following is a bad example, since we would normally specify
% hardware by an invariant on a volatile field.
%% One case is interaction with hardware: you might know the hardware is
%% going to leave specific I/O register positive, and an assumption is a
%% way to communicate that to VCC. 

An assertion can also change what VCC knows after the assertion, if
the assertion fails to verify: although VCC will report the failure as an error,
it will assume the asserted fact holds afterward. For example, in the following
VCC will only report an error for first assumption and no the second:
\begin{VCC}
int x;
_(assert x == 0)
_(assert x == 0)
\end{VCC}

When we talk about what VCC knows, we mean what it knows in an ideal
sense, where if it knows \vcc{E}, it also knows any logical
consequence of \vcc{E}. In such a world, adding an assertion that
succeeds would have no effect on whether later assertions succeed.
VCC's ability to deduce consequences is indeed complete for many types
of formulas (e.g. formulas that use only equalities,
inequalities, addition, subtraction, multiplication by constants, and
boolean connectives), but not for all formulas, so VCC will
sometimes fail to prove an assertion, even though it ``knows'' enough
to prove it.  Conversely, an assertion that succeeds can sometimes cause later assertions that
would otherwise fail to succeed, by drawing VCC's attention to a
crucial fact it needs to prove the later assertion.  This is
relatively rare, and typically involves ``nonlinear arithmetic''
(e.g. where variables are multiplied together), bitvector reasoning,
or quantifiers. We'll say more about these in \secref{bv}.

\subsection*{Exercises}
\begin{enumerate}
\item
In the following program fragment, which assertions will fail?
\begin{VCC}
int x,y; 
_(assert x > 5) 
_(assert x > 3) 
_(assert x < 2) 
_(assert y < 3)
\end{VCC}
\item
Is there any difference between 
\begin{VCC}
_(assume p)
_(assume q)
\end{VCC}
and 
\begin{VCC}
_(assume q) 
_(assume p)
\end{VCC}
? What if the assumptions are replaced by assertions?
\item
Is there any difference between
\begin{VCC}
_(assume p)
_(assert q)
\end{VCC}
and 
\begin{VCC}
_(assert (!p) || (q))
\end{VCC}
? 

%% \itodo{The implication should be introduced earlier.}
% we need to have a place where we collect all of the new operators -E
%% \vcc{p ==> q} means \vcc{p} implies \vcc{q}, and formally \vcc{!p || q}.
%\item
%\itodo{I'm not sure if this and the following exercise give
%any insight. --M}
% the objective is to let readers think about strongest postconditions
% and weakest preconditions -E
%Given the assumptions preceding each of the assignments below to int
%variables, what are the strongest assertions that would be valid?
%\begin{VCC}
%_(assume x < 5) x += 5; _(assert ??)
%_(assume u < v) u = v;  _(assert ??)
%_(assume a < b && a < c) a = b;  _(assert ??)
%\end{VCC}
%\item
%Given the assertions following each of the assignments below, what is 
%the weakest preceding assumption that would allow the assertions to be
%valid?
%\begin{VCC}
%_(assume ??) x = y _(assert x < 10)
%_(assume ??) u += 3 _(assert 2*u == 3*v)
%\end{VCC}
\end{enumerate}

\section{Requires, ensures, and writes}
\label{sect:functions}

Next we turn to the specification of functions. We'll take the example
from the previous section, and pull the computation of the minimum of
two numbers out into a separate function:

\vccInput{c/01_min2.c}

(The listing above presents both the source code and the output
of VCC, typeset in a different fonts, and 
the actual file name of the example is replaced with \vcc{/*`testcase`*/}.)
VCC failed to prove our assertion, even though it's easy to see that
it always holds. This is because verification in VCC is \Def{modular}: 
VCC doesn't look inside the body of a function (such as \vcc{min()}) 
when understanding the effect of a call to the function (such as 
the call from \vcc{main()})%
\footnote{We will see later how to selectively override this default
  and perform such inlining during verification.}; 
all it knows about the effect of calling \vcc{min()} is that the call 
satisfies the specification of \vcc{min()}. 
%This is just because we have chosen the default to be so. It thus doesn't
% contradict that specification needs to say everything --M
%\footnote{
%  Actually, VCC does know one important thing from this specification
%  of \vcc{min()}: it knows that a call do \vcc{min()} has no side
%  effects that are visible to the caller. We'll see in \secref{writes} that
%  any such side effects have to be explicitly specified.
%}.
Since the correctness of \vcc{main()} clearly depends on what \vcc{min()}
does, we need to specify \vcc{min()} in order to verify \vcc{main()}.

%%\begin{note}
% This is important enough to put in the main text -E
Modular verification brings several benefits. 
First, it allows verification to more easily scale to
large programs. Second, by providing a precise interface between
caller and callee, it allows you to modify the implementation of
a function like \vcc{min()} without having to worry about breaking the
verifications of functions that call it (as long as you don't change
the specification of \vcc{min()}). This is especially important
because these callers normally aren't in scope, and the person
maintaining \vcc{min()} might not even know about them (e.g., if
\vcc{min()} is in a library). Third, you can verify a function like
\vcc{main()} even if the implementation of \vcc{min()} is unavailable
(\eg if it hasn't been written yet). 
%%\end{note}

The specification of a function is sometimes called its \Def{contract},
because it gives obligations on both the function and its callers. It
is provided by three types of annotations:
\begin{itemize}
\item A requirement on the caller (sometimes called the
  \Def{precondition} of the function) take the form \vcc{_(requires E)}, 
  where \vcc{E} is an expression. It says that callers of the
  function promise that \vcc{E} will hold on function entry. 

\item A requirement on the function (sometimes called a
  \Def{postcondition} of the function) takes the form \vcc{_(ensures E)}, 
  where \vcc{E} is an expression. It says that the function
  promises that \vcc{E} holds just before control exits the
  function. 

\item The third type of annotation, a \Def{writes clause}, is described
  in the next section.
\end{itemize}

For example, we can provide a suitable specification for \vcc{min()} as
follows:
\vccInput[linerange={min-endmin,out-}]{c/01_min3.c}
\noindent
(Note that the specification of the function comes after the header and
before the function body; you can also put specifications on function
declarations (\eg in header files).)
The precondition \vcc{_(requires \true)} of \vcc{min()} doesn't
really say anything (since \vcc{\true} holds in every state), but is included
to emphasize that the function can be called from any state and
with arbitrary parameter values.
The postcondition states that the value returned from \vcc{min()} 
is no bigger than either of the inputs.
Note that \vcc{\true} and \vcc{\result} are spelled with a backslash
to avoid clash with C identifiers\footnote{
  All VCC keywords start with a backslash; 
  this contrasts with annotation tags (like \vcc{requires}),
  which are only used at the beginning of annotation
  and therefore cannot be confused with C identifiers
  (and thus you are still free to have, \eg
  a function called \lstinline{requires} or \lstinline{assert}).}.

VCC uses function specs as follows. When verifying the body of a
function, VCC implicitly assumes each precondition of the function on
function entry, and implicitly asserts each postcondition of the
function (with \vcc{\result} bound to the return value and each
parameter bound to its value on function entry) just before the
function returns. For every call to the function, VCC replaces the
call with assertion of the preconditions of the function, sets the
return value to an arbitrary value, and finally assumes each
postcondition of the function. 
For example, VCC translates the program above roughly as follows:
\vccInput{c/01_min_assert.c}

Note that the assumption of a precondition on function entry could
fail in an execution only if the corresponding assertion of the
precondition (in the caller) failed first. Similarly, the
postconditions assumed on return from a function could fail only if
the corresponding assertion in the called function failed first. Thus,
in a verified program, these assumptions can never fail.

\subsection*{Exercises}
\begin{enumerate}
\item
Try replacing the \vcc{<} in the return statement of \vcc{min()} with
\vcc{>}. Before running the verifier, can you guess which parts of the
verification will fail?
%% One way to illustrate that the verification of \vcc{main()} 
%% depends only on the specification of \vcc{min()} is to 
%% replace \vcc{<} with \vcc{>} in the return statement of \vcc{min()}.
%% The output of verification shows that \vcc{main()} is still correct---only 
%% \vcc{min()} is broken:
%% \vccInput[linerange={out-}]{c/01_min4.c}

\item
What is the effect of giving a function the specification
\vcc{_(requires \false)} ? How does it effect verification of
the function itself? What about its callers? Can you think of a good 
reason to use such a specification?
%% When verifying function body it translates to an assumption.
%% As we have noted this will make the body of function verify,
%% regardless what it contains.
%% On the other hand, you will be unable to verify call to such a function
%% from outside.
%% Conversely, \vcc{_(ensures \false)} will prevent verification
%% of the body of the function, but will make the function that calls
%% it verify.

%% As we can see, in each case there is something that does not verify.
%% However, because of this you should be careful when interpreting
%% VCC answers: successful verification of a function is only meaningful
%% if everything it calls was verified.

\item
Can you see anything wrong with the above specification of \vcc{min()}?
Can you give a simpler implementation than the one presented? Is this 
specification strong enough to be useful? If not, how might it be
strengthened to make it more useful?

\item
Specify a function that returns the (int) square root of its (int)
argument. (You can try writing an implementation for the function, but
won't be able to verify it until you've learned about loop
invariants.)

\item
Can you think of useful functions in a real program that might
legitimately guarantee only the trivial postcondition \vcc{_(ensures \true)}?
\end{enumerate}

\subsection{Reading and writing}
\label{sect:writes}
When programming in C, it is important to distinguish two kinds of
memory access. \Def{Sequential} access, which is the default, is appropriate when
interference from other threads (or the outside world) is not an
issue, \eg when accessing unshared memory. Sequential accesses can be
safely optimized by the compiler by breaking it up into multiple
operations, caching reads, reordering operations, etc. 
\Def{Atomic} access is required when the access might race with other
threads, \eg a write to memory that is concurrently read or written,
or a read to memory that is concurrently written. In this section, we
consider only sequential access to memory, atomic access is considered
in \secref{concurrency}. 

For each memory access within a program, VCC checks that the access is accessing a 
\Def{valid} memory object. Validity implies that the object address
points to memory that is actually in the address space of the program
(i.e., it has been allocated, either on the stack or on the heap, and
has not been freed). (Validity in VCC additionally requires that the
access is appropriately typed; this aspect is 
described in more detail in \secref{type-safety}). 

To safely read memory, we additionally need to know that the memory
is not concurrently modified by other threads; such an object is said
to be \Def{readable}. In general, readability can depend on complex
program reasoning (and perhaps hints from the user), so by default,
VCC checks a stronger condition, called \Def{thread
  locality}. The precise definition of thread localility is given in 
\secref{ownership}, but intuitively, an object is
considered thread-local if it is controlled by the thread under
consideration. For sequential programs, readability essentially
reduces to simple validity; we point out thread-locality only because
if VCC is unable to check that a read is safe, it will report that it
was unable to show that the object read was thread-local.

While thread locality is what is checked on a read, in practice it is
rarely used in preconditions%
\footnote{This is because the thread-locality of an object could be
  falsified by the unwrapping of other objects; see
  \secref{invariants}).}  More usual is to provide the stronger
precondition of the object being \vcc{\mutable} (also described in
\secref{ownership}), which essentially says that object is
private to the current thread; you should generally use this stronger
condition in specifications.

When a program writes to an object, that object must be
\Def{writable}. Writability requires the object to be \vcc{\mutable}
(because a sequential write can in general cause unpredictable results
for a concurrent read to the same memory in another thread). 
However, a stronger check is needed because, by default, VCC assumes that a
function call has no side effects on its caller; for example, in
verifying \vcc{main()} above, VCC assumed that the call of
\vcc{min()} didn't change \vcc{newPos}. 
In VCC, possible side effects are specified using 
another form of function specification, called \Def{writes clauses}.
Intuitively, the clause \vcc{_(writes p, q)} says that, 
of the memory objects that are thread-local to the caller before the call,
the function is going to modify only the object pointed to by \vcc{p}
and the object pointed to by \vcc{q}%
\footnote{More precisely, the function can modify objects that were in
  the sequential ownership domains of \vcc{p} and \vcc{q}; see 
  \secref{ownership}.}.
In other words, it is roughly equivalent to a postcondition that ensures
that all other objects local to the caller prior
to the call remain unchanged.%
\footnote{It's not quite the same when considering objects that are
  wrapped; see \secref{invariants}.}  VCC allows you
to write multiple writes clauses, and implicitly
combines them into a single set. If a function spec contains no writes clauses, 
it is equivalent to specifying a writes clause with empty set of
pointers.

More precisely, an object is \vcc{\writable} if it is \vcc{\mutable} and 
it is either listed in a writes clause of the function,
or it became \vcc{\mutable} sometime after the function was entered; the 
latter condition guarantees that either \vcc{p} was listed in the
writes clause or was not thread-local in the caller when the call to
the function was made. 
In particular, formal function parameters and local variables are
writable as long as they are in scope and have not been explicitly
wrapped (\secref{invariants}) or reinterpreted to a
different type (\secref{reint}).  VCC asserts
\vcc{\writable(p)} on each attempt to write to \vcc{*p}, as well as on
each call to a function that lists \vcc{p} in a writes clause.

Here is a simple example of a function that visibly reads and writes
memory; it simply copies data from one location to another.
\vccInput{c/01_copy1.c}
In the postcondition the expression \vcc{\old(E)} returns the value
the expression \vcc{E} had on function entry.
Thus, our postcondition states that the new value of \vcc{*to}
equals the value \vcc{*from} had on call entry. 

%% \vccInput[linerange={swap-partition}]{c/04_partition.c}
%% \vccInput[linerange={foo-}]{c/01_swap1.c}

%% Because global variables (like \vcc{z}) might be visible to callers
%% of \vcc{copy()}, \vcc{copy()} needs to report that they might change.
%% Note that the writes clause lists pointers to memory locations, not lvalues
%% (\ie \vcc{_(writes &x, &y, &z)} and not \vcc{_(writes x, y, z)}).
%% Note also that because \vcc{&z} aliases neither \vcc{&x} nor \vcc{&y}, VCC can
%% deduce that \vcc{swap(&x, &y)} does not change \vcc{z}.

%% Had we left out the writes clause from the specification of
%% \vcc{swap()}, VCC would report several errors:
%% \vccInput[linerange={out-}]{c/01_swap2.c}
%% \noindent 

%% Whenever a memory object is read, VCC asserts that it is
%% thread-local; whenever a memory object is written or is
%% mentioned in the writes clause of a function call, VCC asserts that it
%% is writable. Try removing each of the function annotations in
%% this example (one at a time) to see what error messages you get.

%% For example, the assert/assume translation of \vcc{swap()} is%
%% \footnote{
%%   VCC does not generate the read and writes checks for the local variable
%%   \vcc{tmp}. Because \vcc{tmp} is a local that never has its address
%%   taken, it can be thought of as remaining in a register, where it is
%%   guaranteed to remain writable.
%% }:

%% \vccInput[linerange={swap-}]{c/01_swap3.c}

%% \noindent
%% As we can see, one effect of \vcc{writes p, q} is the implicit
%% precondition \vcc{requires \writable(p) && \writable(q)}. Such precondition
%% needs to be checked in \vcc{foo()}, at the place where it calls \vcc{swap()}.
%% In other words, the called function can write at most what the caller can write.
%% In particular if we forget to list \vcc{&x} in the writes
%% clause of \vcc{foo()} we would get an error when it tries to call a
%% function that possibly writes \vcc{&x}:

%% \vccInput[linerange={out-}]{c/01_swap4.c}


%% You might wonder why cannot we just have 
%% \vcc{requires \writable(p)} and instead have the specialized writes clause.
%% The reason is that the writes clause also specifies that nothing
%% outside of the writes clause will be changed.
%% This is why we can prove that \vcc{y} is still \vcc{42} after the call
%% to \vcc{boundedIncr(&x)}. 


%A predicate \vcc{\mutable(p)} states that the object pointed to by \vcc{p}
%is allocated, ``belongs'' to the current thread, and is in a ``phase of life''
%that allows for modification.
%We will get into details all of these later.
%For now we just need to know that in order to be able to write to \vcc{*p}
%one needs to know that \vcc{p} was listed in the writes clause \emph{and} \vcc{\mutable(p)}.
%For example, if we remove the \vcc{_(writes ...)} clause from the
%\vcc{boundedIncr()} we get the following output:

% Too much information, too few full examples in one place. --M
%
%\subsection*{More on expressions in annotations}
%VCC provides a number of C extensions that can be used within VCC
%annotations. We describe some of them here.
%
%Within a VCC declaration, the type \vcc|T[E]| where \vcc{T} is
%a type and \vcc{E} is an expression that is convertible to an
%\vcc{int}, is the type of arrays of \vcc{E} elements of type
%\vcc{T}. For example, the declaration
%\begin{VCC}
%void copyArray(int *from, int *to, int len)
%_(requires \\thread_local((int[len]) from))
%_(writes ((int[len]) to))
%...
%\end{VCC}
%defines a function that can read the first \vcc{len} elements of the
%array \vcc{from}, and read or write the first \vcc{len} elements of
%the array \vcc{to}.
%
%The expression \vcc{\forall T v; E} evaluates to \vcc{1} if the
%expression \vcc{E} evaluates to a nonzero value for every value 
%\vcc{v} of type \vcc{E}. For example, the expression 
%\vcc|\forall int i; 1 < i && i < x ==> x % i != 0|
%says that \vcc{x} is a prime number.
%Here, \vcc{==>} denotes logical implication; formally,
%\vcc{P ==> Q} means \vcc{((!P) || (Q))}, and is usually 
%read as ``\vcc{P} implies \vcc{Q}''.
%
%Similarly, the expression \vcc{\exists T v; E} evaluates to \vcc{1} if there
%is some value of \vcc{v} of type \vcc{T} for which \vcc{E} evaluates
%to a nonzero value.
%
%The expression \vcc{\old(E)}, when used in a postcondition of a
%function, returns the value of expression \vcc{E} as it was at just
%before the function was called. For example, the postcondition 
%\vcc{*x == \old(*x) + 1} says that the function under consideration
%increments \vcc{*x}.

\subsection*{Exercises}
\begin{enumerate}
\item
Could the postcondition of \vcc{copy} have been written equivalently
as the simpler \vcc{*to == *from}? If not, why not?
\item
Specify, write, and verify a function that swaps the values pointed to
by two \vcc{int} pointers. Hint: use \vcc{\old(...)} in the postcondition.
% We did not explain anything about arrays at this point --M
%\item
%Specify a function that takes a pointer to the first element of an
%array of distinct \vcc{int}s and sorts the array 
%in ascending order%
%\footnote{Specifying this for arrays with duplicates is somewhat more
%  involved.}. 
%\item
%Specify a function that takes a pointer to the first element of an
%array of distinct \vcc{int}s and the size of the array and finds an index of the
%smallest element occurring in the array. Write a recursive
%implementation of this function and verify that it satisfies your
%specification. 
%\item
%Use the last function and the swap function defined in the text to
%define and verify a recursive function that sorts an array. 
%\item 
%Verify recursive variants of other sorting routines.
%\item
%Write a recursive function that checks whether a given element occurs
%in a sorted array.
\end{enumerate}


