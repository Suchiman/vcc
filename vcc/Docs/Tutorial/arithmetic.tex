\todo{if this section remains after the functions section, move the exercises from there to here,
since they require quantification.}
\section{Arithmetic and Quantifiers}
\todo{move arithmetic stuff appendix in, as well as mathint and a mention of maps}
\todo{add appendix section gathering together all annotations and extensions to C}

VCC provides a number of C extensions that can be used within VCC
annotations (such as assertions):
\begin{itemize}
\item
The Boolean operator \vcc{==>} denotes logical implication; formally,
\vcc{P ==> Q} means \vcc{((!P) || (Q))}, and is usually 
read as ``\vcc{P} implies \vcc{Q}''. Because \vcc{==>} has lower
precedence than the C operators, it is typically not necessary to
parenthesize \vcc{P} or \vcc{Q}.

\item
The expression \vcc{\forall T v; E} evaluates to \vcc{1} if the
expression \vcc{E} evaluates to a nonzero value for every value 
\vcc{v} of type \vcc{T}. For example, the assertion
\begin{VCC}
_(assert x > 1 &&
  \forall int i; 1 < i && i < x ==> x % i != 0)
\end{VCC}
\noindent checks that (\vcc{int}) \vcc{x} is a prime number. If \vcc{b}
is an \vcc{int} array of size \vcc{N}, then
\begin{VCC}
_(assert \forall int i; \forall int j;
  0 <= i && i <= j && j < N ==> b[i] <= b[j])
\end{VCC}
checks that \vcc{b} is sorted.

\item
Similarly, the expression \vcc{\exists T v; E} evaluates to \vcc{1} if there
is some value of \vcc{v} of type \vcc{T} for which \vcc{E} evaluates
to a nonzero value. For example, if \vcc{b} is an \vcc{int} array of
size \vcc{N}, the assertion
\begin{VCC}
_(assert \exists int i; 0 <= i && i < N && b[i] == 0)
\end{VCC}
asserts that  \vcc{b} contains a zero element.
\vcc{\forall} and \vcc{\exists} are jointly referred to as
\Def{quantifiers}. 

\item
VCC also provides some mathematical types that cannot be used in
ordinary C code (because they are too big to fit in memory);
these include mathematical (unbounded) integers and (possibly infinite) maps. They are described in
\secref{mathTypes}.

\item
Expressions within VCC annotations are restricted in their use of 
functions: you can only use functions that are proved to be 
\Def{pure}, \ie free from side effects (\secref{pureFunctions}).
\end{itemize}


\subsection{Overflows and unchecked arithmetic}
\label{sect:overflows}

Consider the C expression \vcc{a+b}, when \vcc{a} and \vcc{b} are,
say, \vcc{unsigned int}s. This might represent one of two programmer
intentions. Most of the time, it is intended to mean ordinary
arithmetic addition on numbers; program correctness is then likely to
depend on this addition not causing an overflow. However, sometimes
the program is designed to cope with overflow, so the programmer means
\vcc{(a + b) % UINT_MAX+1}. 
It is always sound to use this second interpretation, but VCC
nevertheless assumes the first by default, for several reasons:
\begin{itemize}
\item The first interpretation is much more common.
\item The second interpretation introduces an implicit \vcc{%}
  operator, turning linear arithmetic into nonlinear arithmetic and
  making subsequent reasoning much more difficult.
\item If the first interpretation is intended but the addition can in
  fact overflow, this potential error will only manifest later in the
  code, making the source of the error harder to track down.
\end{itemize}

Here is an example where the second interpretation is intended, but
VCC complains because it assumes the first:
\vccInput[linerange={begin-}]{c/4.1.hash_fail.c}

\noindent
VCC complains that the hash-computing operation might overflow.
To indicate that this possible overflow behavior is desired we use \vcc{_(unchecked)},
with syntax similar to a regular C type-cast.
This annotation applies to the following expression, and indicates that
you expect that there might be overflows in there.
Thus, replacing the body of the loop with the following
makes the program verify:

\vccInput[linerange={update-endupdate}]{c/4.2.hash.c}

Note that ``unchecked'' does not mean ``unsafe''.
The C standard mandates the second interpretation for unsigned overflows,
and signed overflows are usually implementation-defined to use two-complement.
It just means that VCC will loose information about the operation.
For example consider:
\begin{VCC}
int a, b;
// ...
a = b + 1;
_(assert a < b)
\end{VCC}
This will either complain about possible overflow of \vcc{b + 1} or succeed.
However, the following might complain about \vcc{a < b}, if VCC does not know
that \vcc{b + 1} doesn't overflow.
\begin{VCC}
int a, b;
// ...
a = _(unchecked)(b + 1);
_(assert a < b)
\end{VCC}
Think of \vcc{_(unchecked)E} as computing the expression using mathematical 
integers, which never overflow, and then casting the result to the desired range.
VCC knows that \vcc{_(unchecked)E == E} if \vcc{E} fits in the proper range,
and some other basic facts about \vcc{(unsigned)-1}.
If you need anything else, you will need to resort to bit-vector
reasoning (\secref{bv}).

\subsubsection{Bitvector Reasoning}
\label{sect:bv}

Every now and then, you need to prove some low-level fact that VCC
can't prove using ordinary logical reasoning. If the fact involves
can be expressed over a relatively small number of bits, you can ask
VCC to prove it using boolean reasoning at the level of bits, by 
putting \lstinline|{:bv}| after the \vcc{assert} tag. For example:

\vccInputSC[linerange={begin-}]{c/4.3.min5.c}

Assertions proved in this way cannot mention program variables, and
can use only variables of primitive C types.

