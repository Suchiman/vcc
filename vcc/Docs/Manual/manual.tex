\ifdense
\documentclass[preprint,nocopyrightspace]{sigplanconf}
\else
\documentclass{article}
\usepackage{fancyhdr}
%\pagestyle{fancy}
\fi
\bibliographystyle{plain}

% on-screen reading version
\ifwide
\usepackage[margin=3mm, paperwidth=7in, paperheight=9in]{geometry}
%\usepackage[margin=3mm, paperwidth=5in, paperheight=4in]{geometry}
\else
\usepackage[margin=3mm, paperwidth=8.5in, paperheight=11in]{geometry}
\fi

\usepackage{amsmath}
\usepackage{stmaryrd}
\usepackage{color}
\usepackage{graphicx}
%\usepackage{marginnote}
\usepackage{hyperref}
\usepackage{amsmath, amssymb}
\usepackage{url, listings}
%\usepackage{msrtr}
\usepackage{vcc}
\usepackage{boogie}
\usepackage{xspace}
\usepackage{paralist}
% default to roman numerals:
\let\oldinpaxraenum=\inparaenum
\def\inparaenum{\oldinparaenum[(i)]}
\definecolor{bgcode}{rgb}{0.92,0.92,0.92}

\definecolor{todocolor}{rgb}{0.9,0.0,0.0}
\definecolor{noteframe}{rgb}{0.5,0.5,0.5}
%\ifdense
\newcommand{\todo}[1]{[\textcolor{red}{\textbf{TODO:} {#1}}]}
%\else
%\newcommand{\todo}[1]{\marginnote{\scriptsize {[\textcolor{red}{\textbf{TODO:} {#1}}]}}}
%\fi
\newcommand{\itodo}[1]{{[\textcolor{red}{\textbf{TODO:} {#1}}]}}
%\renewcommand{\todo}[1]{}
%\renewcommand{\itodo}[1]{}
\newcommand{\lines}[1]{\begin{array}{l}#1\end{array}}
\newcommand{\linesi}[1]{\;\;\;\begin{array}{l}#1\end{array}}
\newcommand{\tuple}[1]{{\langle}{#1}\rangle}
\newcommand{\subsubsubsection}[1]{\paragraph{#1}}
\ifdense
\usepackage[T1]{fontenc}
\usepackage{epigrafica}
%\usepackage{iwona}
%\usepackage[scaled]{berasans}
%\usepackage{cmbright}
%\usepackage{lxfonts}
%\usepackage{kurier}
\usepackage{times}
\else
\usepackage[OT1]{fontenc}
\usepackage{courier}
%\usepackage[T1]{fontenc}
%\usepackage[scaled=0.81]{luximono}
\fi

\newcommand{\secref}[1]{\hyperref[sect:#1]{\textsection~\ref{sect:#1}}}
\newcommand{\figref}[1]{Figure~\ref{fig:#1}}
\newcommand{\Secref}[1]{Section~\ref{sect:#1}}
\newcommand{\Figref}[1]{Figure~\ref{fig:#1}}

\newcommand{\lemmaref}[1]{Lemma~\ref{lemma:#1}}
\newcommand{\thmref}[1]{Theorem~\ref{thm:#1}}
\newcommand{\lineref}[1]{line~\ref{line:#1}}

\newcommand{\ie}[0]{i.e.,{ }}
\newcommand{\eg}[0]{e.g.,{ }}
\newcommand{\cf}[0]{cf.{ }}


\ifdense
\newenvironment{note}{%
\vspace{-3mm}
\begin{list}{}%
    {\setlength{\leftmargin}{0.03\textwidth}}%
    \item[]%
  \textcolor{noteframe}{\rule{0.444\textwidth}{1pt}} \\
  %\small
  %\sffamily
  \selectfont
  %\textbf{Note:}
}{%
  \vspace{-2mm} \\ 
  \textcolor{noteframe}{\rule{0.444\textwidth}{1pt}} 
  \end{list}
\vspace{-2mm}
}
\else
\newenvironment{note}{%
\vspace{-3mm}
\begin{list}{}%
    {\setlength{\leftmargin}{0.1\textwidth}}%
    \item[]%
  \textcolor{noteframe}{\rule{0.9\textwidth}{1pt}} \\
  \small
  %\textbf{Note:}
}{%
  \vspace{-2mm} \\ 
  \textcolor{noteframe}{\rule{0.9\textwidth}{1pt}} 
  \end{list}
\vspace{-2mm}
}
\fi
\newcommand{\notehd}[1]{\textbf{#1} \\}

\newcommand{\eqspc}[1]{\;\;{#1}\;\;}
\setlength{\arraycolsep}{0mm}

%%% the model

%%% general
\newcommand{\MathOp}[2]{{}\mathbin{\hbox{$\mkern#2mu#1\mkern#2mu$}}{}}
\newcommand{\Iff}{\MathOp{\Leftrightarrow}{6}}
\newcommand{\Equal}{\MathOp{=}{6}}
\newcommand{\Xor}{\MathOp{\not\equiv}{6}}
\newcommand{\Implies}{\MathOp{\Rightarrow}{4}}
\renewcommand{\And}{\MathOp{\wedge}{2}}
\newcommand{\Or}{\MathOp{\vee}{2}}
\newcommand{\Neg}{\neg}
\newcommand{\dor}[0]{\MathOp{|}{2}}

\newcommand{\ON}[1]{\operatorname{#1}}
\newcommand{\Version}[0]{0.2}

% -----------------------------------------------------

\newcommand{\Def}[1]{\textit{\textbf{#1}}}
\newcommand{\entry}[2]{\noindent #1 #2}

\begin{document}

\title{A VCC User's Manual\\
\vspace{2mm}
\Large  Working draft, version \Version, \today}
%\title{Developing VCC Specifications \\ for Concurrent C Programs}

\ifdense
\authorinfo{}
%\authorinfo{Ernie Cohen, Mark A. Hillebrand, \\ Stephan Tobies}{European Microsoft Innovation Center}{\{ecohen,mahilleb,stobies\}@microsoft.com}
%\authorinfo{Micha{\l} Moskal, Wolfram Schulte}{Microsoft Research Redmond}{\{micmo,schulte\}@microsoft.com}
\preprintfooter{VCC User Manual (working draft, ver. \Version)}
\else
\author{
%Micha{\l} Moskal, Wolfram Schulte \\
%\normalsize Microsoft Research Redmond \\
%\and Ernie Cohen, Mark A. Hillebrand, Stephan Tobies \\
%\normalsize European Microsoft Innovation Center
}
\date{}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0.3pt}
\fancyfoot[LO,RE]{\footnotesize VCC Tutorial (working draft, ver. \Version, \today)}
\fancyfoot[RO,LE]{\thepage}
\fi


%\msrtrno{MSR-TR-2010-9}
%{\def\@titletext{foo}}
%\msrtrmaketitle

%\pagebreak
%\begin{figure*}
%\vspace{3in}
%\begin{center}
%This page intentionally left blank.

%\end{center}
%\end{figure*}

%\setcounter{page}{0}

\maketitle


\begin{abstract}
This manual presents the annotation language of VCC, a deductive
verifier for concurrent C.
\end{abstract}

%\tableofcontents
\ifdense
\lstset{
  basicstyle=\small\sffamily,
  columns=fullflexible,
}
\else
\lstset{
  basicstyle=\small\ttfamily,
}
\fi

\definecolor{kwColor}{rgb}{0.2,0.2,0.8}

\lstset{
  keywordstyle=\bfseries, %\textcolor{kwColor},
  breaklines=true,
  breakatwhitespace=true,
  numberstyle=\tiny\sf,
  escapeinside={/*-}{*/},
  numbers=none,
  emptylines=1,
  rangeprefix=\/\*\{,
  rangesuffix=\}\*\/,
  includerangemarker=false,  
%  aboveskip=2mm,
%  belowskip=2mm,
%  xleftmargin=2mm,
%  xrightmargin=2mm,
}

\ifdense
\renewcommand{\labelitemi}{{\footnotesize \centeroncapheight{$\bullet$}}}
\fi

VCC is a deductive verifier for concurrent C code. VCC takes C code,
annotated with specifications of its behavior, and tries to prove that
the code does indeed behave as specified. The primary purpose of this
document is to describe the meaning of these annotations and what constitutes
correct behavior of VCC (but not its internal architecture). 

\section{Introduction}

Like many other methodologies, VCC seeks to provide \emph{modular}
verification. This means that a program can be broken up into into
``verification units'' (which in VCC are functions and data type
definitions), each with a public specification, such that each unit
can be verified independently, using only the specifications of the
units it mentions (including the units mentioned in their
specifications, etc.). 

VCC partitions the state into a number of objects, each with a number
of fields. Each object has a two-state \Def{invariant} (a predicate on pairs
of states) restricting how the entire state may change in a single
atomic step; these invariants can mention arbitrary parts of the
state. A 2-state invariant can be interpreted as an invariant on a
single state by applying it to the transition from the state to itself
(\Def{stuttering}). Define a state to be \Def{good} if all object
invariants hold in that state, and a state transition to be good if it
satisfies every object invariant. A sequence of states (finite or
infinite) is good iff all of its states and transitions are good. VCC
verification guarantees that all possible executions of the program
are good. VCC does this inductively, by showing that the initial
state is good, and that for every state transition induced by the program,
assuming that the prestate of the transition is good, the transition
is good and the poststate is good.

A transition is \emph{legal} if it preserves the invariants of all
modified objects. An invariant of object \vcc{o} is \Def{admissible}
iff (1) every legal state transition, starting from a good state,
satisfies the invariant of \vcc{o}, and (2) every good transition,
starting from a good state, results in a state from which stuttering
satisfies the invariant of \vcc{o}. VCC proves its inductive step by
proving that every object invariant is admissible and that each
transition induced by each function is legal.

In VCC, every object has a type, and the (annotated) definition of a
type determines the invariant of an object of that type. Verifying a
type definition means verifying that the invariants of objects of that
type are admissible. 

To modularize the verification of the functions, each function has a
specification that defines its preconditions (what the function
expects when it is called), postconditions (what it guarantees when it
returns), framing (what parts of the state it is allowed to modify),
and possibly termination guarantees. When verifying the body of a
function, function calls are replaced with their
specifications. Similar sorts of specifications can be put on code
blocks. Loops are verified by constructing a suitable loop invariant,
and showing that the invariant holds on entry and is maintained by an
arbitrary iteration of the loop. Atomic actions are verified by
showing that they maintain the invariants of the objects they
update. In this way, verification of concurrent programs is reduced to
the verification of branching programs without loops or function
calls.

VCC methodology depends heavily on \Def{ghost} data and code - data
and code that is added to the program to facilitate reasoning, but is
removed prior to compilation. Ghost code can use richer data types and
operations than real code, since ghost data doesn't have to be stored
in a finite memory and ghost code doesn't have to be implemented with
hardware.  The primary restrictions on ghost data are that ghost code
cannot write to non-ghost (concrete) data, and ghost code must not
effect the control flow of real code (so in particular, ghost code
must terminate); these conditions guarantee that the program without
ghost code simulates the program with the ghost code. VCC provides a
number of pieces of ghost data that are integrated into the
programming methodology. In addition, users can define their own ghost
data types, declare ghost data, and write ghost functions to
manipulate this data.  Users can also use ghost parameters to pass
ghost data in and out of concrete functions.

Each object has a Boolean ghost field that says whether it
is \Def{closed}, and a ghost field that gives its \Def{owner} (an
object). If the owner of an object is a thread, that thread says the
object is \Def{mutable} if it is open and \Def{wrapped} if it is closed.
Only threads can own open (non-closed) objects. For an 
object of a user-defined type, invariants are not guaranteed to hold
in transitions between states where the object is open. When an object
is open, only the thread that owns it can read or write it. Thus,
sequential code normally operates on mutable objects,
without having to check object invariants. Only explicitly marked
atomic actions can update fields of closed objects (regardless of who
owns the object). Ownership of an object can transfer from one thread
to another only by transfering ownership to some shared (and therefore
closed) object as an intermediary; this idiom is used in the
implementation of synchronization primitives such as locks (which are
not built in). 

An implicit reduction theorem allows each thread to pretend that it
runs in isolation (without interleaving actions of other threads),
allowing other threads to run only just before starting an atomic
action. At this point, the thread ``forgets'' everything it knows
about the state, except for what it knows about the objects that it
owns. Additional information about the state before this ``scheduler
boundary'' that is known to still be true later (because of object
invariants) can be explicitly captured by the thread by using it as an
invariant of a ghost object that it wraps before the atomic
action. VCC provides syntactic sugar for making such objects, in the
form of \Def{claims}. Closed ghost objects are often used as carriers
of information; because the are first-class, they can be stored in
data structures, passed in and out of functions, packaged up in
messages sent from one thread to another, and so on. Part of the VCC
philosophy is to allow the programmer to use ordinary programming
methods to structure what he knows about program behavior, to
explicitly move such information around to where it's needed, and to
expose it where it's needed to show correctness of the program; it's
up to VCC to combine the information the programmer has provided using
mathematical deduction.

\section{Program Structure}

\subsection{Annotations}
VCC annotations are of the form \vcc{_(tag stuff)}, where \vcc{tag} is
a \Def{annotation tag} and \vcc{stuff} has ballanced parentheses
(after preprocessing), and follows the rules defined in this
manual. In ordinary program compilation, the header vcc.h defines the
macro \vcc{_} as ignoring its argument, so all VCC annotations are
removed. 

In this manual, the syntax of annotations are described like function
calls, except that instead of writing 
\begin{VCC}
  void F(args)
\end{VCC}
we write
\noindent\vcc{_(F args)} (class)\\
where the class describes the lexical role of the annotation, which is
one of the following:
\begin{description}
\item[command] an annotation that acts syntactically as a program 
statement in ghost code;
\item[cast] an annotation that acts syntactically as a (type) cast in
expressions (in concrete or ghost code);
\item[contract] an annotation that appears as a specification clause
of a function or a block (in concrete or ghost code);
\item[specifier] an annotation that appears in the syntactic role of a
function specifier (just before a function declaration or definition);
\item[special] an annotation whose role is described in the text.
\end{description}

Several VCC annotations allow a variable number of arguments of the
same type. In such cases, we write the argument as a single typed
argument followed by an ellipses. If the argument is separated from
the ellipses by a comma, the list is comma-separated.

In addition to annotations, VCC also provides a number of additional
types and functions that can be used inside of annotations. These
types and functions all have names starting with \vcc{\}. In this
manual, these functions are given conventional C declarations. 

\subsection{Contexts}
An annotated program contains several types of context:
\begin{itemize}
\item A program context lies within a program block in a function
definition. Annotations classified as \vcc{(command)} can appear only
in a program context.
\item A concrete context is part of the program that is not inside of a VCC annotation. 
\item A ghost context is that part of the program that is within VCC
annotations. Within a ghost context, real state can be read but not
updated. 
\item A pure context is a ghost context within which the state is not
allowed to change. (Note: the body of a pure function is not itself a
pure contect.) Within a pure context, the state can be read but
not updated. No implicit assertions (e.g. to avoid null dereferences)
are implicitly added inside pure contexts. Only pure functions can be
called in a pure context.
\item An atomic context is a a context inside of an atomic action
(i.e., within the scope of a block labelled \vcc{_(atomic)}
or \vcc{_(ghost_atomic)}), or within the definition of a type
invariant (i.e., inside of a \vcc{_(invariant)} inside of a type
definition). 
\end{itemize}

\subsection{Sequentialization}
C allows the compiler great lattitude in reordering computations. For
example, it allows the arguments to a functon call to be evaluated in
any order, or even in parallel. VCC enforces stronger properties on
programs so that the behavior allowed by C is equivalent to the
behavior of a naive translation of the program, where things are
computed sequentially in the obvious order (typically textual when
ambiguities arise, so for example VCC translates a function call into
first evaluating the parameters one at a time, from left to
right). This means VCC will reject some programs that are legal C,
even ones that correctly implement the specification. Typically, for
any specific desired ordering one wanted to make possible, it is
possible to rewrite the program so that VCC will accept it (for
example, one can obtain any desired ordering of parameter evaluation
by just computing them one at a time and putting the results into
local variables).


\subsection{Objects}
VCC organizes the state into a collection of objects, each with
a number of fields. Every object has the ghost
fields \vcc{\owner}, \vcc{\owns}, \vcc{\closed}, \vcc{\type}, \vcc{\valid},
and \vcc{\version}. The remaining fields of an object are determined
by its \vcc{\type} field. For example, a struct normally has a field
for each nonprimitive member declared in the definition of its
type. VCC objects are either instances of compound types (structs or
unions) or array objects; there are no objects of primitive types. 

As in C, many different objects share (alias) the same bits of
physical memory. This means that an update to the state of
one \vcc{\valid} object cannot change the state of
another \vcc{\valid} object. All data access in VCC is
through \vcc{\valid} objects, so accessing memory through a currently
invalid object typically requires first invalidating any aliasing
objects and validating the new object, a mechanism known as
"reinterpretation" (section ??). 

\subsection{The Heap}

Conceptually, the entire state of a program, including the state of
the threads, is stored in two heaps, the concrete heap (inherited from
C) and a ghost heap. The real heap maps real memory addresses to byte
values. The ghost heap maps \vcc{\natural} to either either byte
values or ghost type values. 
The size and layout of objects of a concrete type on the ghost heap
matches the layout of such objects on the concrete heap.  

The ghost fields of all objects are stored on the ghost heap. Their
address of a ghost field of an object does not have a predictable
offset from the address of the object, but is a function of the
address and type of the object.  

VCC does not provide an initialization syntax for ghost fields of concrete objects. 

Pointer types distinguish between pointers to real memory and pointers
to guest memory; the * operator is extended polymorphically to apply
to either type of pointer. The \vcc{&} operator is extended to apply
to both real and ghost lvalues. 

It is convenient to think of the heap as storing the previous state of
an execution (at some well-known ghost address), and for every update
to the state to update this location appropriately. In this manual, we
use the following notations: 
\\\\
\vcc{\last}\\
The previous state of the execution. (Not allowed in VCC annotations.)
\\\\
\noindent\vcc{\stutter(s)}\\
This is \vcc{s} with \vcc{\last} set to \vcc{s}, i.e., the effect of
taking a step without changing the state. (Not allowed in VCC
annotations.) 
\\\\
\vcc{\prev(e)}\\
Defined as \vcc{\at(\last,e)}. In atomic contexts, this is equal
to \vcc{\old(e)}. 
\\\\
\vcc{\at(s,e)}\\
The evaluation of expression \vcc{e} in the state \vcc{s} (with all
free variables replaced with their value in the current state).  
\\\\
\vcc{\notchanged(o)}\\
For object \vcc{o}, this holds iff, for every field \vcc{f}
of \vcc{o}, \vcc{o->f == \prev(o->f)}. (Not allowed in VCC
annotations.) In atomic contexts, this is equal
to \vcc{\unchanged(e)}. 

\subsection{Object Invariants}
For each object \vcc{o}, there is a state
predicate \vcc{\invariant(o)}. (This predicate is a fixed function of  
the current state, and so is not a field of \vcc{o}.) Define

\begin{VCC}
\good(s) <==> \forall \object o; \at(s, \invariant(o)) && \at(\stutter(s), \invariant(o))

\legal(s) <==> \at(s, \good(\prev(s)) ==> \forall \object o; \notchanged(o) || \invariant(o))

\admissible(o) <==>
        \forall(\state s; \legal(s) && \at(s,\notchanged(o)) ==> \at(s,\invariant(o)))
        \forall(\state s; \legal(s) && \at(s,!\notchanged(o)) ==> \at(\stutter(s),\invariant(o))
\end{VCC}


VCC proves that every state reached in an execution
is \vcc{\good} by checking that every state update is legal (by
verifying the code of each function) and by checking that each object
invariant is admissible (by reasoning about the type definitions).  

The invariant of an object is defined as follows, where \vcc{\inv2(o)}
is a state predicate defined as part of the definition of \vcc{o}'s
type: 

\begin{VCC}
\invariant(o) <==> 
	o \in o->\owner->\owns
	&& (\forall \object o1; o->\closed && o1 \in o->\owns ==> o1->\owner == o)
	&& (o->\valid ==> 
 		 o->\owner->\valid 
 		 && o \in o->\owner->owns 
 		 && (o->\claim_count ==> o->\closed)
 		 && (o->\closed || (o->\owner is a thread)))
	&& (o->\closed ==> o->\valid && (\forall \object s; s \in o->\owns ==> s->\closed && s->\owner == o)
        && (o->\closed || \prev(o->\closed) ==> \inv2(o))
        && (\forall \object o1; o1 != o && o1->\valid && o->\valid ==> <the \span(o1) and \span(o) have no common heap locations>)
)
\end{VCC}

\noindent\vcc{\bool \inv2(\object o)}\\
Can appear only in object invariants or inside atomic actions. 
True iff the current state satisfies the 2-state invariant of \vcc{o},
i.e. the conjunction of the invariants given by the \vcc{_(invariant)}
annotations (explicit or implicit) given in the definition of
the \vcc{o}'s type.
\\\\
\vcc{\bool \inv2s(\state s1,\state s2,\object o)}\\
If \vcc{o} is an object, this is true iff the invariant of object \vcc{o} holds in state \vcc{s2},
but with \vcc{s2->\last} replaced with \vcc{s1}. If \vcc{o} is not an
object, the result is undefined.
\\\\
\vcc{\bool \inv(\object o)}\\
True iff \vcc{\inv2s(\stutter(\now))}.

\subsubsection{Approval}

\vcc{_(bump_volatile_version o)} (command)\\

Each object has an implicit volatile
field \vcc{\volatile_version}. This field cannot be 
mentioned in expressions, and can be updated only by
the statement \vcc{bump_volatile_version)}, which can only appear
inside an atomic action. \vcc{_(bump_volatile_version o)}
has the implicit precondition
\vcc{_(requires \wrapped(o) ==> \writable(o))}.

The effect of these restrictions is that if \vcc{o} is \vcc{\wrapped}
prior to a function call or entry to a block with a specification,
and \vcc{o} is not in the writes clause of the call or block, then the
call or block does not change the value of \vcc{o->\volatile_version}.

\vcc{\bool \approves(o, f ))} (special)\\

If the form
\begin{VCC}
  \approves(\this->\owner,f))
\end{VCC}
appears as a top-level conjunct of an invariant of type \vcc{T},
then \vcc{T} has the additional implicit invariants
\begin{VCC}
  _(invariant \unchanged(\this->\volatile_version)
      || \this->\owner is a thread
      ||  \unchanged(f))
  _(invariant \unchanged(f) 
      || \this->\owner->\type is not a thread
      || \inv2(\this->\owner))
\end{VCC}

This has the effect that if \vcc{o} is \vcc{\wrapped}
prior to a function call or entry to a block with a specification,
and \vcc{o} is not in the writes clause of the call or block, then the
call or block does not change the value of \vcc{o->f}. Moreover, if
\vcc{o} is not owned by a thread, then any change to \vcc{o->f}
requires a check of the invariant of \vcc{o->\owner}.

\subsection{Ownership}
Every object has an owner, given by its \vcc{\owner} field. An object
can only be owned by a closed object. 

\noindent\vcc{\bool \wrapped(\object o)}\\
Can appear only in a program context;
true iff \vcc{o->\owner == \me && o->\closed}.
\\\\
\noindent\vcc{_(dynamic_owns)}\\
\vcc{_(volatile_owns)}\\
These annotation can appear only after the \vcc{struct} or \vcc{union}
keyword in the definition of a \vcc{struct} or \vcc{union}
type \vcc{T}. Both cannot appear of a given type. If the type is not
marked \vcc{_(volatile_owns)}, then the type gets as an implicit
invariant
\begin{VCC}
  _(invariant \this->\closed ==> \unchanged(\this->\owns))
\end{VCC}

\noindent\vcc{\bool \mine(\object o1, ...)}\\
True iff \vcc{(o1 \in \this->\owns && ...)}.
\vcc{\mine} can appear only in object invariants,. 
If the object type is not marked \vcc{_(dynamic_owns)}
or \vcc{_(volatile_owns)}, this function can only be used as the
outermost function of a top-level conjunct of an invariant.

Caveat: currently, \vcc{_(wrap)} and \vcc{_(unwrap)} cannot be used in atomic
actions (except before \vcc{_(begin_update)}. This restriction should
be lifted.

\section{Preprocessing}

VCC requires programs being verified to \vcc{#include <vcc.h>}. This
should precede any code or program directives (after expansion of
other \vcc{#include} directives). 
 
VCC reserves the following preprocessor macros: TODO
\begin{VCC}
  VERIFY _VCC_H _() 
\end{VCC}

VCC reserves the macro \vcc{_(...)}; this macro is not available to C
programs. All VCC annotations occur within this macro, allowing all
annotations to be removed by defining this macro as a space (as is
declared in the version of the header \vcc{<vcc.h>} used when
compiling the program


VCC uses the C preprocessor, so comments and macro expansion follow
the rules of C.

\section{Types}
Types are classified as real or ghost, depending on whether they are
defined in a real context or a ghost context.  

VCC types, like types in C, can be considered sets of values. In C,
each type has a fixed finite size (i.e., the number of bytes needed to
represent any value of that type), and therefore represents a finite
set of possible values. VCC relaxes this restriction, and classifies
each type by the number of possible values of that type, which is
either finite, small (countable), or large (uncountable); with each
type below, we give the class of that type. C primitive types are all
finite. The class of a struct or union type is the class of its
largest member (including ghost fields), so while a C compound type
without ghost fields is finite, one with ghost fields might be small
or large. The class of an array type is the class of its base type. 
\\\\
\vcc{e \is T} (expr)\\
\vcc{e} must be an \vcc{\object}, and \vcc{T} a type. 
This expression is \vcc{\true} iff the type of \vcc{e} is convertible to
type \vcc{T}.

All types can be classified as either \Def{primitive} types
or \Def{object} types. Object types are \vcc{struct}
types, \vcc{union} types, array object types, \vcc{\thread}s, 
\vcc{\claim}s, and \vcc{\blob}s. All other types are primitive types.

\subsection{Numeric Types}

\subsubsection{Boolean Type}

\vcc{\bool} (finite)\\
The Boolean types, with values \vcc{\true} and \vcc{\false}. These 

VCC introduces the infix operators \vcc{==>}
and \vcc{<==>}. These operators operate on any integral type, and
return a result of type \vcc{\bool}. They are introduced primarily
for syntactic sugar; they all have precedence weaker than all ordinary
C operators. They can occur only in pure contexts.

\vcc{x ==> y} return \vcc{\true} iff \vcc{x == \false} or \vcc{y != 0}\\
\vcc{x <==> y} return \vcc{\true} iff \vcc{x ==> y} and \vcc{y==>x}\\

\subsubsubsection{Quantifications}

A quantification has one of the forms
\vcc{\forall <decl>; p} (universal quantification) or 
\vcc{\exists <decl>; p} (existential quantification), 
where \vcc{<decl>} is a variable declaration, and \vcc{p}
is an expression. (Optionally, pattern matchings can appear after the
semicolon (section ??)). A universal/existential quantification evaluates
to \vcc{\true} iff \vcc{p} evaluates to a non-\vcc{\false} value for
each/some possible instantiation of the quantified vvariables.

\subsubsection{Numeric Types}

\vcc{\natural} (small)\\
The type of (unbounded) natural numbers. 
\\\\
\vcc{\integer} (small)\\
Mathematical (unbounded) integers. 
\\\\
VCC extends C with the arithmetic types \vcc{\natural}
and \vcc{\integer}. C integral types can be cast to \vcc{\integer},
or unsigned integral types cast to \vcc{\natural}, in the obvious
way. When a signed value is cast to \vcc{\natural} in an impure
context, there is an implicit assertion that the value cast is
nonnegative. In a pure context, the casting of a negative value to 
a \vcc{\natural} is equivalent to applying some unknown (but fixed)
function from \vcc{integer} to \vcc{natural}. 

An arithmetic operator instance is said to occur in
an \vcc{\unchecked} context if it is is a subterm of an expression
marked \vcc{_(unchecked)}; otherwise, it is said to be checked. The
result of an expression of arithmetic type is implicitly cast
to \vcc{\integer} if (1) the context is pure and checked, or (2) it is
subject to a binary arithmetic operator and the other operand
is \vcc{\natural} or \vcc{\integer}.

The C arithmetic operators are extended to the types \vcc{\natural}
and \vcc{\integer} with the obvious interpretation. 

On any checked arithmetic operation, VCC asserts that the operation
does not overflow or underflow. On any checked division, VCC asserts
that the divisor is nonzero. On any checked cast between arithmetic
types, VCC asserts that the cast value fits in the range of the target
arithmetic type. 

VCC currently does not support floating point arithmetic, in that it
does not "know" anything about the semantics of various floating point
operations, and does not check for floating point overflow, underflow,
or division by zero.

(Note: although the semantics of an overflowing multiplication or
division is well-defined, VCC knows very little about the result,
beyond it fitting in the proper range.)

VCC does not allow C's silent promotion of an expression of
type \vcc{(void *)} to another pointer type; such a promotion requires
an explicit cast. (This is justified on the grounds that it avoids
potential errors without changing the compiled code.)

\subsection{Map Types}
\vcc{T1[T2]}\\
The type of maps from type \vcc{T2} to type \vcc{T1}. If \vcc{T2} is
finite, this has the same class as \vcc{T1}. If \vcc{T2} is small, the
resulting type is large. The construction is illegal if \vcc{T2} is
large.

Map types can also appear in
declarations and typedefs, and there the syntax matches the syntax of
C declarations and typedefs, except that a type appears in between the
array brackets instead of a size.

VCC defines several map types as built-in types that are currently
treated in different ways deductively.

The cast operator is extended to allow casing to map types, 
using the syntax \vcc{(T1[T2]) e} to cast \vcc{e} to type type of maps
from \vcc{T2} to \vcc{T1}.

VCC extends the array syntax to maps. If \vcc{e} is a map of
type \vcc{T1[T2]} and \vcc{x} is a value of type \vcc{T2},
then \vcc{e[x]} is an expression of type \vcc{T1}, whose value is
given by the value of \vcc{e} at the point \vcc{x}. If \vcc{v} is a
lvalue of type \vcc{T1[T2]} and \vcc{e1} is an expression of
type \vcc{T2}, then the expression \vcc{v[e] =  e1} is equivalent to
the assignment \vcc{v = (\lambda T2 u; (u == e) ? e1 : v[u])}
where \vcc{u} is a fresh variable. This is extended to maps of maps in
the obvious way.

\subsubsection{Lambda Expressions}
\vcc{\lambda T v; e} (expression)\\
Here, the scope of \vcc{v} continues to the end of \vcc{e}; it
introduces \vcc{v} as a variable of type \vcc{T}. If \vcc{T1} is the
type of \vcc{e}, this expression has type \vcc{T1[T]}; the resulting
value maps each \vcc{v} to the corresponding value of \vcc{e}.

\subsubsection{Pointer Sets}
The type \vcc{\objset} represents sets of typed pointers.
\\\\
The Boolean infix operator \vcc{\in} takes an
\vcc{\object} as its first argument and an \vcc{\objset} as its second,
and returns \vcc{\true} iff the first argument is an
element of the second.

The infix \vcc{+} and {-} operators are extended to operate on
an \vcc{\objset} and a \vcc{\object}, and return the result of adding
(respectively, removing) the value of the second argument from the
value of the first. The \vcc{+=} an \vcc{-=} are extended analogously.
\\\\
\vcc{\objset \everything()}\\
\vcc{\objset \universe()}\\
The set of all objects.

\vcc{\bool \disjoint(\objset o1, \objset o2))}\\
True iff \vcc{o1} and \vcc{o2} contain no common values. Note that
this can be true even if each set contains pointers (of different
types) with the same address.\\
\\\\
\vcc{\bool \subset(\objset s1, \objset s2)}\\
True iff \vcc{o1} is a subset of \vcc{o2}.
\\\\
\vcc{\objset \diff(\objset s1, \objset s2)}\\
This is an infix operator that returns the union of the sets \vcc{s1}
and \vcc{s2}.

Note: object sets exist as a separate type (rather than just being a
synonym for \vcc{\bool[\object]}) both for legacy reasons and because
they trigger somewhat differently from maps.

\subsubsection{States}

\vcc{\state} (large)\\
The type of states. States are first-class values, so they can be
stored in ghost variables or ghost fields of data structures. 
\\\\
\vcc{T \at(\state s, T e)}\\
Returns the value of expression \vcc{e} evaluated in state \vcc{s}. 
\\\\
\vcc{\state \now()}\\
The current state. 

\subsection{Pointer Types}
In the extended program, a value \vcc{p} of pointer type includes not only the
address \vcc{\address(p)} to which the pointer points, but also the type of the
pointer. In addition, if \vcc{p} is a pointer to a (real or ghost)
\vcc{\object} of primitive type, 
the value includes an object \vcc{\embedding(o)} such that, for some
field \vcc{f} of \vcc{\embedding(o)}, \vcc{\address(o) == \address(&o->f)}. 
(Such an object is unique in any \vcc{\good} state.)
When the \vcc{&} operator is applied to an expression of the
form \vcc{o->f}, where \vcc{f} is of primitive type, the
aforementioned object is \vcc{o}. When it is applied to a local
variable, it is the object containing the variable.

Within a pure context, the operator \vcc{==} applied to two pointers
returns \vcc{\true} iff the pointers have equal addresses, their types
are the same, and (if they point to primitive types) they have equal
embeddings. 
\\\\
\vcc{_(\object \embedding(o))}\\
\vcc{o} must be a pointer or a ghost pointer. If it is a pointer to a
primitive type, this returns 
\\\\
\vcc{^T} (small)\\
The type of pointers to ghost objects of type\vcc{T}. (\vcc{T} can be a real or ghost type.)

The prefix \vcc{&} operator is extended to ghost variables of
type \vcc{T} yielding a result of type \vcc{^T}. 
\\\\
\vcc{_(retype)} (cast)\\
This operator is well-defined only when oeprating on a pointer \vcc{p} to a
primitive type. If there is a \vcc{\valid} object \vcc{o} with a field \vcc{f}
such that \vcc{&o->f} and \vcc{p} point have the same base type and
the same address, then this operator returns \vcc{&o->f}. Otherwise,
the result of the operation is undefined.

This operator is typically used when \vcc{p} points to a primitive
field of struct that is a member of a union, and some other union
member is currently \vcc{\valid}.  
\\\\
\vcc{\object} (small)\\ 
The type of all typed pointers (to real or ghost memory). Note that
these might be pointers to primitives, and so not all \vcc{\object}s
are objects.
\\\\
\vcc{\claim} (small)\\
The type of claims. 
\\\\
The prefix \vcc{*} operator is extended from C pointers to ghost
pointers, with the analogous interpretation.

\subsubsection{Threads}
\vcc{\thread} (small) \\
The type of threads. 
\\\\
\vcc{const \thread \me}\\
Allowed only in a thread context. This is a pure local variable that
gives the current thread. Its address may not be taken and 

\subsection{Compound Types}

\subsubsection{Ghost Fields}
Within a compound type, a field is ghost is it occurs inside the scope
of a \vcc{_(ghost)}  annotation. Ghost fields may be of any concrete
or ghost type. Ghost fields are stored on the ghost heap, even if they
are of concrete type.

\subsubsection{Invariants}
An explicit object invariant is an annotation of the form \vcc{_(invariant e)}
ocurring at the level of member declarations of a structured
type. Within \vcc{e}, the context is considered pure and ghost, 
and all members of the type being declared are
considered to be in scope, even if they are not declared until later
in the type declaration. The keyword \vcc{\this} refers to the
instance of the object for which the invariant is being applied. An
ocurrance of a name \vcc{f}, not beginning with \vcc{\}, that is
declared as a member of the type is synonymous with \vcc{\this->f}. 
Within an object invariant, \vcc{\old(e)} translates essentially
to \vcc{\at(\stutter(\now()->\last), e)}.

An object invariant can mention any part of the state, including
static global variables. However, as there is no thread context, it
cannot mention \vcc{\me}.

An invariant in the declaration of type \vcc{T} forbids unwrapping if
it can be violated in an object \vcc{o} of type \vcc{T} by
unwrapping \vcc{o}. An invariant that forbids unwrapping must be
written in the form \vcc{_(invariant \on_unwrap(\this,p))}. 
\vcc{\on_unwrap(o,p)} translates to 
\vcc{(\old(\this->\closed) && !\this->\closed ==> p)}.

Only compound types can have explicit object invariants. Other object
types have additional implicit object invariants.

\subsubsection{Structs}
Ghost struct declarations need not declare any members (unlike in C).

The infix \vcc{.} operator (selecting a field of a \vcc{struct}
or \vcc{union} is extended in both arguments, to ghost objects and to
records (on the left) and to ghost field names (on the right).

Note: VCC currently does not support this operator when the name begins
with \vcc{\}; the \vcc{->} operator must be used instead.

The infix \vcc{->} operator (selecting a member of a struct or union
pointed to by the first argument) is extended to ghost pointers and
pointers to ghost types and to pointers to records on the left, and to
ghost fields on the right. 


\subsubsubsection{Groups}
A group object is an artificial object that lies inside a
concrete \vcc{struct} object. The physical address and size of a group
are equal to those of the containing struct. The fields of a group
need not be contiguous. (This means that the fields left to the
containing struct need not be contiguous either.)
\\\\
\noindent\vcc{_(group G)} (special)\\
\vcc{_(group G, <forms>)} (special)\\
These forms can appear only within the definition of a \vcc{struct}
or \vcc{union} type. They declares the identifier \vcc{G} to be the name of a nested
ghost \vcc{struct} of the parent type. If the second form is used,
the \vcc{<forms>} are a comma-separated list of modifiers,
each one of \vcc{_(dynamic_owns)}, \vcc{_(volatile_owns)}, \vcc{_(record)},
or \vcc{_(claimable)}; these attributes are used as attributes of the
newly defined group type.

The type of the declared group is written as \vcc{T::G}, where \vcc{T}
is the containing \vcc{struct} type. A pointer to the group has the
same address as a pointer to the container, and so is ghost iff the
container is ghost. 
\\\\
\vcc{_(:G)} (special form)\\
This form can appear only within the definition of a \vcc{struct}
or \vcc{union} type, and only after the group \vcc{G} has been
declared with \vcc{_(group G)}. It declares that the immediately
following fields are semantically fields of \vcc{G}, rather than fields of
the containing struct. The explicit labelling allows the fields of the
group to not be contiguous.
\\\\
\vcc{_(invariant :G p)} (special form)\\
This form declares an invariant for group \vcc{G} defined earlier in
the current \vcc{struct}. It follows the same rules as ordinary object
invariants; in particular, it can mention members of \vcc{G} that are
not yet declared.

\subsubsubsection{Inlining}

\vcc{_(inline)}
This annotation can appear only before the declaration of a field of
a \vcc{struct} type. The field itself must also be of a \vcc{struct}
type. The effect is that the inner object is not considered to be an
true object; instead, its fields are semantically fields of the
parent struct. Invariants of the inner struct are omitted.

\subsubsubsection{Volatile structs}
A type definition of structure type defines two types, the usual one
and a volatile type. The volatile type differs from the nonvolatile
type only in that all of its explicit fields are volatile and it has
none of the explicit invariants of the original type. Instead, the
type gets an implicit invariant that each of its fields is
owner-approved. 

When a field of struct type is marked as \vcc{volatile}, and that
field is of a struct type, the instance is of the volatile variant of
that type. If the type is inlined, the individual fields are inlined
as usual, but each of the fields is as if it was declared to be
volatile. 

\subsubsection{Unions}
If a union includes a member of primitive type, exactly one of
these members must be be marked \vcc{_(backing_member)}. The size of
each backing member must be at least as large as the size of the other
members of the union. It is a vcc error to take the address of a
primitive non-backing-member of a union. 

Members of ghost union types do not necessarily alias, so assignment
through one member need not be reflected in the value of another
member.  

In any state, if a union is \vcc{\valid}, exactly one of its members
is \vcc{\valid}. When a union is created (by \vcc{\unblobify}), the
backing member is made active by default; otherwise, the first member
is made active by default. 

\subsubsection{Record Types}
A record is like a C struct or union, except that it is treated as a single
abstract value. It is declared using the same syntax as the
declaration of a \vcc{struct} type, but with the following
differences:
\begin{itemize}
\item The keyword \vcc{struct} or \vcc{union} is immediately followed by
 \vcc{_(record)}.
\item The fields of a record type cannot be marked as volatile.
\item Record types have no invariants.
\item Fields of a record cannot be of struct types or array types (but
can be of map type). 
\item If a field of a record is of union type, it must have
a \vcc{_(backing_member)}.
\end{itemize}
\vcc{_(record)}

If \vcc{e} is an expression of record type with
fields \vcc{f1,f2,...}, and \vcc{e1,e2,...} are expressions that are
assignment compatible with the types of fields \vcc{f1,f2,...}
respectively, then
\begin{VCC}
  e / { .f1 = e1, f2 = e2, ...}
\end{VCC}
is equal to the record \vcc{e} with the fields \vcc{f1,f2,...} set
to the values \vcc{e1,e2,...} respectively.

An assignment to a field of a record type are translated in the
obvious way.


\subsection{Inductive Types}
VCC provides inductive type definitions. Values of these types are not
objects.  An inductive type is introduced by a top-level annotation
\begin{VCC}
  _(datatype T {
    <type cases>
  })
\end{VCC}
where \vcc{<type cases>} is a (non-separated) sequence of elements of the form
\begin{VCC}
  case Functor(<args>)
\end{VCC}
where \vcc{<args>} is a comma-separated list, each element of which is
a type name optionally followed by a parameter name. This
declares each \vcc{Functor} to be a constructor of values of
type \vcc{T}. 

Types can be mutually recursive, but a type cannot be referenced
before being declared. The form \vcc{_(type T)} declares \vcc{T} as a
type without defining it.

The C \vcc{switch} statement is extended to inductive types as
follows: if \vcc{v} is an expression of type, VCC allows the program statement 
\begin{VCC}
switch (v) {
  case F1(t11,t12,...) { P1 }
  case F2(t21,t22,...) { P2 }
  ...
}
\end{VCC}
where each \vcc{tij} is a variable name not in scope, no name occurs
as more than one of the \vcc{tij}s, each constructor of type \vcc{T}
occurs exactly once among \vcc{T1, T2, ...}, and each of the cases has
proper arity for the given constructor. 
This translates to 
\begin{VCC}
{
  unsigned x;
  switch (x) {
    case (1) : {
      T11 t11; T12 t12; ...
      _(assume v == F1(t11,t12,...))
      { P1 }
      break;
    } case (2) : {
      T21 t21, T22 t22; ...
      _(assume v == F2(t21,t22,...))
      { P2 }
      break;
    } ...
    default: _(assume 0)
  }
}
\end{VCC}

\subsection{Array object types}
An array object is an object that serves as a container for an array
(typically of primitive type). They are typically used to allow
ownership transfer of the elements of the array.

An array  object type is  defined by the  base type and length  of the
array. If the base type of the array is a primitive type, the elements
of the array are effectively fields  of the array. If the base type of
the array is nonprimitive, the  array object has no fields (other than
those present  in all objects), and  so is not very  useful. Note that
VCC's array types  are not the same as the  apparently similar C array
types; array  object types  cannot be defined  via typedef, nor  can a
variable  be declared  to have  an array  object type.  Expressions of
array object type can only be created by casting: if \vcc{T} is a type
and    \vcc{e}   is    an   expression    of   integral    type,   the
expression  \vcc{(T[e]) v}  casts \vcc{v}  to  a pointer  to an  array
object with  base type  \vcc{T} and length  \vcc{e} (where  \vcc{e} is
evaluated in the current state).  Note that this syntax doesn't create
a conflict with ordinary C array types, because C does not allow casts
to array types.

If the base type of an array is declared as volatile, the array has
the implicit invariant that all changes to the array are
owner-approved.
\\\\
\vcc{void \join_arrays(\object a1, \object a2)} (command)\\
\vcc{a1} and \vcc{a2} must be \vcc{\mutable}, \vcc{\writable} array objects with the same
base type, and \vcc{a1} must immediately precede \vcc{a2}. Execution 
invalidates these objects and makes valid the array object of the same
type, with starting addres the same as that of \vcc{a1}, and length
the sum of the two lengths. The new array is \vcc{\mutable}.
\\\\
\vcc{void \split_array(\object a, \size_t s)} (command)\\
\vcc{a} must be a \vcc{\mutable}, \vcc{\writable} array object. This
command asserts that \vcc{a->\length < s}, invalidates the
object \vcc{a}, and breaks \vcc{a} into two \vcc{\mutable} contiguous array
objects of the same base type, the first of length \vcc{s}.
\\\\
\vcc{_(root_index \type T size_t s)}\\
This macro should be aookued only to a pointer \vcc{o} of type \vcc{T*}, and
expands to \vcc{_(T *)_(T[s])}. This has the effect of giving
back \vcc{o} but, if \vcc{o} is of primitive type, changing its
embedding to the array object \vcc{_(T[s])o}. 

\subsection{Blobs}
A blob is an uninterpreted contiguous portion of the concrete address
space, much like a struct of a given size with nothing but padding. 
A chunk of memory starts out as a blob. This blob can be broken into
smaller blobs, joined into larger contiguous blobs, or turned into a
collection of objects (essentially, the \vcc{extent} of the outermopst
object). The outermost object made from the blob is said to be
``blobifiable''; only blobifiable objects can be blobified. (This is
to avoid accidentally making multiple objects of the same type with
the same address.) 

To change a piece of memory from holding one type of object to holding
another, the first object must turned into a blob, this bloc might be 
merge with other blobs or split into smaller blocs, and finally a blob
is turned into a new object. 
\\\\
\vcc{_(blob size_t sz))} (cast)\\
This returns a pointer to a \vcc{blob} of size \vcc{s} with the same
address as \vcc{ptr}. It has no effect on the state. 
\\\\
\vcc{_(blobify \object o)} (command)\\
This \vcc{requires}  \vcc{\extent_mutable(o))} and
the \vcc{\object} is blobifiable. It has the effect of making all
objects in \vcc{\extent(o)} invalid and making valid a blob of
size \vcc{sizeof(o)} with the address of \vcc{o}.
\\\\ 
\vcc{_(join_blobs \blob a, \blob b)} (command)\\
This joins \vcc{a} and \vcc{b} into a single blob. This requires that
the address of \vcc{b} is the address of \vcc{a} plus the size
of \vcc{a}, and that \vcc{a} and \vcc{b} are mutable.
\\\\
\vcc{_(split_blob \blob a, \natural s)} (command)\\
This requires \vcc{a} is \vcc{\mutable} and of size greater
than \vcc{s}. The result is to split \vcc{a} into two contiguous
blobs, the first of size \vcc{s} and the second of size the original
size of \vcc{a} minus \vcc{s}.
\\\\
\vcc{_(blob size_t s)} (cast) \\
This annotation can occur only just before an expression whose type is
castable to \vcc{\object}. Applying it to an \vcc{\object o} yields
the same result as \vcc{\blob(o, s)}.
\\\\
\vcc{_(blob_of)} (cast)\\
This annotation can occur only just before an expression whose type is
castable to \vcc{\object}. Applying it to an \vcc{\object o} yields
the same result as \vcc{_(blob  \sizeof(o)) o}.
\\\\
\vcc{_(unblobify)} (cast)\\
Applying this to object \vcc{o}
\vcc{requires} that there is a \vcc{\wrapped} blob with the same
address and size as \vcc{o}. The effect is to make all of the objects
in \vcc{\extent(o)} \vcc{\mutable}, marking \vcc{o} as blobifiable. If
the type of \vcc{o} involves unions, the backing member is chosen as
the ``active'' member of the union; if the union has no backing
member, the first union member is chosen.

(Note: this is provided as a cast rather than a command, because
legacy code often requires unblobification in the middle of an expression.)
\\\\
\vcc{_(union_reinterpret \object o}\\
This requires \vcc{o} to be of the form \vcc{&(x->f)}, where \vcc{x} is
a pointer to a union type and \vcc{f} is a member of the type. It also
requires that the union is mutable, and that the extent of the currently active
member of the union (if of nonprimitive type) is mutable. The effect
is to make \vcc{f}the currently active member of \vcc{x} i.e., to make
its extent mutable (chosing union members of nested unions as
in \vcc{_(unblobify)}. 

\subsection{Claims}
A type (real or ghost) can be marked a \vcc{claimable} (just before
the \vcc{struct} keyword in its type definition). Any type that is
marked \vcc{claimable} has the following implicit fields and
invariants:
\begin{VCC}
  volatile \natural \claim_cnt;
  \objset \claimants;
  _(invariant claimants == \card(\claimants))
  _(invariant \claim_count ==> \this->\closed)
  _(invariant \forall \object o; o \in \claimants ==> \this \in o->\subjects)
  _(approves \this->\owner, \claimants)
\end{VCC}

For certain state predicates \vcc{p}, and every finite \vcc{\objset s}, 
there is an infinite set of ghost
objects, called \Def{claims}, defined as follows:
\begin{VCC}
  typedef _(claimable) struct \claim {
    volatile \bool \used;
    _(invariant \this->\closed ==> p)
    _(invariant \forall \object o; o \in s ==>
      o->\claimants->\claimable && \this \in o->\claimants)
    _(invariant \old(\used) ==> \used)
  } ^\claim;
\end{VCC}
(Note that these invariants are intended to hold for all states, not
just states where the \vcc{\claim} is \vcc{\closed}.)
We refer to \vcc{p} as the claimed property of such objects,
and \vcc{s} as its claimed objects. 
These claims exist for any object for which the above invariants
are admissible.
\\\\
\noindent\vcc{\bool \claims(\claim c, p)}\\
This holds if, in every \vcc{good} state in which \vcc{c} is
closed, \vcc{p} holds. 
\\\\
\noindent\vcc{\bool \claims_object(\claim c, \object o)}\\
True iff \vcc{o} is one of the claimed objects of \vcc{c}.
\\\\
\noindent\vcc{\bool \active_claim(\claim c)}\\
True iff \vcc{c} is closed. However, it has the effect of also
asserting the invariant of \vcc{c}.
\\\\
\vcc{\bool \claims_claim(\claim c, \claim c1)}\\
(Depricated) Equivalent to \vcc{\claims(c, c1->\closed && \valid_claim(c1))}
\\\\
\vcc{\bool \claimable(\object o)}\\
Equivalent to \vcc{o->\claimable}.
\\\\
\vcc{\claim \make_claim(\objset s, \bool p)} (special form)\\
This expands to the following:
\begin{enumerate}
\item Assert that \vcc{p} holds.
\item Assert that the corresponding claim
type is admissible. (If not, VCC reports its inability to prove
that \vcc{p} holds after ``a step of the machine''.) 
\item Let \vcc{c} be a claim with claimed property \vcc{p} and claimed
objects \vcc{s} for which \vcc{!p->\used && !p->\closed}.
\item \vcc{_(wrap c)}
\item \vcc{_(assert p)}
\item Increment the \vcc{\claim_count}s of the objects of \vcc{c}. 
\end{enumerate}

\noindent\vcc{\claim \upgrade_claim(\claim c1,..., bool p))} (special form) \\
This creates a new claim that claims the invariants
of \vcc{c1,c2,...} conjoined with \vcc{p}, while
unwrapping \vcc{c1,c2,...}. (It thus writes \vcc{c1,...}, but does
not write the subjects of \vcc{c1,...}.)  Note that if the input
claims claim a common object, the number of objects claiming that
object will fall below the \vcc{\claim_count} of the object, making it
unable to open again, so this should normally not be the case for
concrete objects.
\\\\
\vcc{\bool \account_claim(\claim c, \object o)}\\
This is semantically equivalent to \vcc{(\wrapped(c) && \claims_object(c,o))}.
It exists to trigger the following axioms: 
\begin{VCC}
  (\forall \claim c1,c2; \forall \object o; {\account_claim(c1,o), \account_claim(c2,o)}
     \account_claim(c1,o) && \account_claim(c2,o) && c1 != c2 ==> o->\claim_count >= 2)
\end{VCC}
and similarly for up to 4 distinct claims.
\\\\
\noindent\vcc{_(by_claim(\claim c, o->f)} (expr)\\
This expression can appear only in a program context; \vcc{f} must be
a nonvolatile field of \vcc{o}. It evaluates
to \vcc{o->f}, but also assserts \vcc{\active_claim(c) && \claims(c,o->\closed)}.
\\\\
\noindent\vcc{bool \always_by_claim(\claim c, \object o)}\\
\vcc{o} must be an identifier. This expression evaluates
to \vcc{\true}. Asserting this as a top-level conjunct causes each 
subsequent occurance of \vcc{o->f} (until the end of the current
block), where \vcc{f} is a nonvolatile field of \vcc{o}, to be
replaced with \vcc{(_(by_claim c)(o->f))}.
\\\\
\noindent\vcc{void \destroy_claim(\claim c, \objset s)}\\
This asserts that \vcc{c} is \vcc{\wrapped} and \vcc{\writable}, and
that it claims every object in \vcc{s} (though it might claim
others). It has the effect of opening \vcc{c} and decrementing
the \vcc{\claim_cnt} of each object in \vcc{s}.
\\\\
(Note: while \vcc{\claim_count} is currently owner-approved, this
invariant may be omitted in future, to allow the construction of
objects that manage their own claims.)
\\\\
\vcc{T \when_claimed(T e)}\\
This function can appear only inside of \vcc{\claims} or in the second
argument to \vcc{\make_claim}. It returns the
value of \vcc{e} in the state in which the claim was
constructed, unless it is also inside an \vcc{\ensures} clause, in
which case it returns the value of \vcc{e} in the state in which the
function returned.  

\section{Declarations and Scoping}
In general, declarations follow the C conventions regarding
declarations and scoping, with the following exceptions. 

VCC declarations generally appear in a \vcc{_(ghost)} annotation (or
an annotation that expands to one). Ghost variables can be declared
anywhere within a block, not only at the beginning. However, 
declarations of functions and global variables must appear at the
outermost scope, as in C. 

Ghost identifiers use the same namespace as ordinary C identifiers. It
is an error to shadow one with the other. 

The scope of a struct or union declaration, as well as the fields of
such declarations, is extended to include all annotations within the
entire compilation unit in which it appears. (However, a typedef name
declared along with it has the usual scope, from point of declaration
forward.) This exception to the scoping rules of C is included to
allow invariant to mention the fields of types that have not yet been
declared (since C has no mechanism for forward declaration of fields).

\section{Purely Local Variables}
A purely local variable is a local variable of a function (or a
function parameter) such that neither the variable nor any nested
member of the variable (if it is of a compound type) is subject to
the \vcc{&} operator. (That is, a variable is purely local if its
address is never taken.)  Such variables are given special treatment
by VCC, because they can be modified by a program fragment only if it
mentions the variable by name. (In particular, it cannot be modified
by a function call.) Purely local variables are always considered
writable, and so do not have to be mentioned in writes clauses for
blocks. 

Note: A purely local variable of \vcc{struct} type is treated
as a collection of purely local variables, one per field, and so each
field gets separately the treatment described above.

\section{Globals Variable Declarations}
Global variables are owned by a single 
\vcc{\bool \program_entry_point()}\\
Can appear only in function contracts. It is equivalent to all global
variables being \vcc{\mutable}. It is typically used to annotate
the \vcc{main()} function of a program.

\subsection{Function Declarations}
A function specification consists of a nonempty sequence of
annotations with the tag \vcc{requires}, \vcc{ensures},
or \vcc{writes} (or macros that translate to these annotations). A
function specification can appear immediately after a function
declaration (before the ending semicolon), in a function definition
(between the declaration and the body), or immediately before a
program block. All specifications on function declarations or
definitions of the same function must have the identical
specifications.

If the identifier \vcc{T} is not in use as an annotation tag, the
top-level form \vcc{_(T <decl>)} abbreviates \vcc{_(ghost T <decl>)}.

\vcc{_(atomic_inline)} (declarator)\\
If a function is marked \vcc{_(atomic_inline)}, (1)calls to the
function are replaced by the body (with function parameters assigned
as local variables), and (2) the body of the function is treated as an
atomic action (which means that it can appear inside an atomic
action). Such functions cannot have specifications.

\subsubsection{Function Contacts}
A function declaration, with or without a body, can follow the
declarator with any number of the following clauses. Each of these
introduces a pure context.
\\\\
\vcc{_(requires b)}\\
This puts  an obligation on  all callers of  the function that  at the
point of the  call (after formal parameters have  been bound), \vcc{b}
should evaluate to a nonzero  value (i.e., \vcc{b} is asserted at each
call site). This also introduces  the assumption\vcc{b} to be added at
the beginning of the function body. 

\vcc{b} (or a top-level conjuncts of \vcc{b}) can be of the
form \vcc{_(assume b)}. The effect is to assume \vcc{b} on every call
to the function (i.e., to omit the \vcc{_(assert b)} that would
otherwise be generated.
\\\\
\vcc{_(ensures b)}\\
This asserts \vcc{b} at each return point from the function. This also
allows callers of the function to assume \vcc{b} when the function
returns. Within \vcc{b}, \vcc{\old(e)}, where \vcc{e} is an
expression, means the value \vcc{e} evaluated to on function entry
(after binding of parameters).
\\\\
\vcc{_(writes o1, o2, ...)} \\
\vcc{_(writes \objset s)}\\
This has two effects. First, it implicitly \vcc{_(require)}s that the listed objects are \vcc{\writable} (section ??) and \vcc{\thread_local}. Second, at the beginning of the function body, the writes set is set to the set of objects written in the writes clause.
\\\\
\vcc{_(reads o1,...)}\\
This annotation can appear only on \vcc{_(pure)} functions. It causes
VCC to check that, for any two states that differ only on the values
of fields of \vcc{o1,...}, the function returns the same result. VCC
also generates an axiom to this effect (to be used in the verification
of other functions) unless the function has a \vcc{_(no_frameaxiom)}
annotation. 
\\\\
\vcc{_(maintains \bool p)}\\
Equivalent to \vcc{_(requires p) _(ensures p)}.
\\\\
\vcc{_(always \claim c, \bool p)}\\
Equivalent to 
\begin{VCC}
  _(requires \wrapped(c) && \claims(c, cond))
  _(requires \assume(\active_claim(c)))
  _(ensures \wrapped(c))
  _(ensures \assume(\active_claim(c)))
\end{VCC}

\vcc{_(updates \object o)}\\
Equivalent to
\begin{VCC}
  _(requires \wrapped(o))
  _(ensures \wrapped(o))
  _(writes o)
\end{VCC}

\vcc{_(out_param(\object p)}\\
Equivalent to
\begin{VCC}
  _(writes p)
  _(requires \mutable(p))
  _(ensures \mutable(p))
\end{VCC}

\vcc{_(returns e)}\\
Equivalent to \vcc{_(ensures \result == e)}


\subsubsection{Ghost Parameters}

VCC allows functions to have ghost parameters. These parameters must
occur after the concrete parameters. Each ghost parameter has the
form \vcc{_(ghost decl)} where \vcc{decl} is a declaration of a
parameter name. These declarations are not separated by commas (so
that there will not be extra commas when the program is
compiled). These parameters obey the usual rules of function
parameters (their names cannot conflict with names of other
parameters, their scopes are the entire function declaration, etc.).

\subsubsection{Pure Functions}
A pure function is one that that can be treated as a mathematical
function of the state, and so can be used in specifications and
assertions. This mathematical function is defined to be an arbitrary
one such that, for any state satisfying its preconditions, the result
satisfies its postconditions. For states not satisfying its
preconditions, the mathematical function takes on an arbitrary value
of the result type. (Note: such a value always exists, because all
value types are nonempty.)

When a pure function is used in an impure context, its
behavior is the same as an impure function. 

\vcc{_(pure)}\\
This declaration can appear only after the return type declaration of
a function declaration or definition. A function marked in this way is
not allowed to modify the state (real or ghost). In particular, (1) it
must have an empty writes clause, (2) it can use \vcc{_(atomic read)}
but not \vcc{_(atomic)} or \vcc{_(ghost_atomic)}, and (3) it can call
only pure functions. All pure functions are subject to termination
checking. 
\\\\
\vcc{_(def <decl>)}\\
This is an abbreviation for 
\vcc{_(ghost _(pure) _(inline) <decl>)}.
\\\\
\vcc{_(pure <decl>)}\\
\vcc{_(abstract <decl>)}\\
These are abbreviations for \vcc{_(ghost _(pure) <decl>)}. The latter
is depricated.

\subsubsection{Custom Admissibility Checks}
\vcc{_(admissibility)} (function attribute)\\
\vcc{_(admissibility)} declares a function as a custom admissibility check. The function
function must take a single argument having type a pointer to a \vcc{struct} type;
verification of the function is used instead of an admissibility check
of the \vcc{struct} type. The function adds an explicit postcondition
that  \vcc{_(havoc_others)} is called exactly once, and that the
function does not otherwise modify the state. It should modify only
local variables, and should not take the addresses of any of these
variables to assure that they are not heapified. Finally, there is an
implicit postcondition that \vcc{\inv2s(s1,s2,o)}, where \vcc{s1} is
the state on entry, \vcc{s2} is the state on exit, and \vcc{o} is the
function parameter.
\\\\
\vcc{_(havoc_others \object o)} (command)\\
This command can appear only in functions
marked \vcc{_(admissibility)}. It changes the state to an arbitrary
\vcc{\legal} state, without changing any fields of \vcc{o}.

\subsubsection{Termination}
VCC checks termination of all functions, blocks, or loops that are
annotated with a \vcc{_(decreases)} annotation. This section applies
only to entities so annotated.

VCC termination is based on the lexicographic ordering of tuples
of \vcc{\natural}s, defined by
\begin{VCC}
<x1,x2,...> < <y1,y2,...> <==> x1 < y1 || (x1 == y1 && <x2,...> < <y2,...>)
<x1,...> = <0,x1,...>
\end{VCC}
the latter equation used to compare tuples of unequal length.

\vcc{_(recursive_with f1,f2,...)}\\
\\ 
This annotation can appear only on the specification of a
function \vcc{f}; we say that \vcc{f} ``publicly
calls'' each of the functions \vcc{f1,f2,...}. 
The ``transitively calls'' relation is the reflexive transitive
relation of public calling relation.

Note: The soundness of termination checking in VCC depends on the
property that if \vcc{f} calls a function \vcc{g} but does not
publicly call \vcc{g}, then \vcc{g} does not transitively
call \vcc{f}. The intention is that this property would be checked
with a ``verification linker'' at program link time, but VCC currently
makes this check only if the definitions of all pure functions
involved are available at verification time.

Note: The soundness of safety checking for VCC depends on termination
for all functions called within ghost code (including
assertions). Thus, the soudness of VCC cannot be guaranteed unless the
code for all such functions (which are either ghost functions or
marked pure) are available at verification time.

\vcc{_(decreases t1, t2, ...)}\\
\\
A \vcc{_(decreases)} annotation can appear only in the specification of a function or
a block; \vcc{t1,t2,...} are terms of type \vcc{\natural}. Within the
function body or block, this defines a function from states of the
body or block to finite tuples of \vcc{\natural}s, given by the value
of the tuple \vcc{<f1,f2,...>}. If the annotation is on a function,
this measure is extended to calls of the function by evaluating this
tuple after the binding of formal parameters. 

Any function declared \vcc{_(pure)} that does not have
a \vcc{_(decreases)} clause in its specification is given implicitly
the annotation \vcc{_(decreases p1, p2, ...)} where the
sequence \vcc{p1,p2,...} is obtained from the sequence of function
parameters by first removing all parameters of \vcc{struct}
type, \vcc{union} type, pointer type, or type \vcc{\bool}, \vcc{float}
or \vcc{double}, and applying \vcc{size()} to any arguments of record
type.

In the body of a function \vcc{f} with a \vcc{_(decreases)} clause, on
any call to a function \vcc{g} that transitively calls \vcc{f},
VCC asserts that the measure of the call to \vcc{g} is smaller
than the measure of \vcc{f} on entry to \vcc{f}. 

If a \vcc{_(decreases)} clause is put on a loop, VCC asserts on any
return to the head of the loop from within the loop that the measure
on loop is smaller than the value of that measure on loop entry.


\subsection{Function Calls}

A call \vcc{v = f(args)} translates to
\begin{enumerate} 
\item evaluate each of the actual parameters, in left-to-right order,
assigning the result of each to a fresh temporary local variable 
\item assert the preconditions  of \vcc{f} (with the temporary locas substituted for the formal parameters)
\item assert that all objects listed in the writes clause of the object are writable. 
\item change the heap state arbitrarily
\item assert that every object that was \vcc{thread_local} prior to the call and was not listed in the writes clauses of the function has the same version as it did before state change
\item assert the postconditions of the call
\end{enumerate}	

\section{Statements}
In verifying a statement, VCC maintains an implicit local variable
called the writes set, consisting of a set of \vcc{\object}s. On a
function call, this variable is set to the set of objects listed in
the writes clauses of the called function. 

\subsection{Wrapping and Unwrapping}

\vcc{_(wrap \object o1, ...) (command)}\\
This translates roughly as follows:
\begin{VCC}
  foreach (\object o \in o1,...) {
    _(assert \mutable(o) && \writable(o))
    _(assert \forall \object o1; o1 \in o->\owns ==> \wrapped(o1) && \writable(o1))
    if <the type of o is not marked _(dynamic_owns) or _(volatile_owns_)>
      o->\owns = {};  
      foreach <top level conjunct \mine(t) in the invariant of o>
        o->\owns += {t};
  }
  _(ghost_atomic o1, ... {
     foreach (\object o \in o1, ...) {
       foreach (\object x \in o->\owns) x->\owner = o;
       o->\closed = \true;
     }
  })
\end{VCC}

\vcc{void \unwrap(\object o, ...)}\\
This command is allowed only in a non-atomic context. It translates roughly to
\begin{VCC}
  _(assert \wrapped(o) && \writable(o))
  _(ghost_atomic o {
    o->\closed = \false;
    foreach (\object o1; o1 \in o->\owns) 
      o1->\owner = \me;
      <add o1 to the writes set>
  })
  <add o a
\end{VCC}


\subsection{Expression Statements}
As in C, an expression, followed by a semicolon, is a statement; it is
executed by evaluating the expression. In a ghost context, VCC does
not allow expression statements without side effects; an expression
statement must either contain an assignment or a call to a
non-\vcc{\pure} function.

If the expression statement reads a field of an object, there is an
implicit assertion that the object is \vcc{\thread_local}.
If the expression writes a field of an object, VCC asserts that the
field is \vcc{\writable}.  

For each read of a variable \vcc{v}, VCC asserts that \vcc{v}
is either \vcc{\thread_local} or is a volatile field of an object in
the read set of an enclosing atomic action. 

For each write of a variable \vcc{v}, VCC asserts that \vcc{v} is
either \vcc{mutable} and in the current writes set, or is a volatile
field of an object in the writes set of an enclosing atomic action.

\subsection{Block Statements}
If a program block immediately preceded by one or more function
annotations with tag \vcc{requires}, \vcc{ensures}, \vcc{writes},
or \vcc{pure}, these annotations are used as specifications for the
block, with \vcc{\old(e)} meaning the value of \vcc{e} at entry to the
block. Any postconditions are enforced for the block, even if control
exits via a goto to an outside location.

If a block has among its
preconditions \vcc{_(requires \full_context())}, the block is verified
using full context from the preceding code of the function. Otherwise,
the block is verified using only those preconditions listed explicitly
in the block contract.

If a block has among its
postconditions \vcc{_(ensures \full_context())}, then the full context
of the block is available on exit from the block. Otherwise, only
those postconditions explicitly given to the block are exposed on
exit. In this case, if the block is marked \vcc{_(pure)}, then the
block is treated as a pure function call; otherwise, it is treated as
an impure function call (wrt. the havocing of state). 

\subsection{Assertions and assumptions}
VCC associates with a program assertions at various control
points. These assertions are either given explicitly by the user (in
the form of \vcc{_(assert)} annotations) or are implicit assertions
generated by VCC. An assertion \Def{fails} in an execution if the
execution includes a state in which control has reached the assertion
and the assertion evaluates to \vcc{0}. For each assertion, VCC issues an
error message if (but not necessarily only if) there exists an
execution of the program in which that assertion fails.

An explicit assertion of the form \vcc|_(assert {:bv} p)|
tells VCC that \vcc{p} should be proved by bitwise reasoning. \vcc{p}
cannot include free variables, cannot reference the heap, and its
quantifications must be on finite types.

\vcc{_(assume b)}\\
This creates a pure context, in which \vcc{b} must be a Boolean
expression. The annotation tells VCC to assume that \vcc{b} holds
whenever control reaches this location. Formally speaking, VCC
considers only those executions in which no assumption is violated.

Note: a common idiom is to use \vcc{_(assume 0)} to prevent
verifications of assertions that follow. It should be noted that VCC
can often tell that the following code is unreachable, causing later
jumps to be ignored when constructing the control flow graph of the
function. In a loop body, this has the effect of causing VCC to verify
the body only for the first iteration through the loop, rather than an
arbitrary one. This can be avoided by assuming something like 
\vcc{x!= x}.

\vcc{_(assert b)}\\
This creates a pure context, in which \vcc{b} must be a Boolean
expression. In an execution of a program, this assertion \Def{fails}
if \vcc{b} evaluates to \vcc{0}. The soundness of VCC requires that
VCC should report an error if there is any execution in which this is
the only assertion that fails. (Note that VCC will often err on the
other side, and report an error even if none is possible.)

\subsection{Ghost Statements}
\vcc{_(ghost stuff)}\\
The tag \vcc{ghost} can appear as a ghost function parameter
(\ref{??}), as a ghost declaration (\ref{??}), or as a ghost
statement. Ghost statements follow the syntax of C statements, except
that they can use extended VCC operators and functions. A ghost
statement does not have to be terminated by a semicolon (like ordinary
C statements), but semicolons must be used between statements.

\subsection{Conditional Statements}

\subsection{Iterative Statements}
The keywords \vcc{while}, \vcc{do}, and \vcc{for}) 
can be succeeded by a sequence of annotations of the form 
\vcc{_(invariant e)}, \vcc{_(writes \object o,...)}, or 
\vcc{_(ensures e)}. Such annotations belong to the loop itself, and
not to the program block (if any) that follows the keyword; the
following block cannot have a contract, though blocks nested inside
can. If the keyword is not annotated by any \vcc{_(writes)} annotations,
it is implicitly so annotated with the \vcc{_(writes)} set of the
immediately surrounding loop if it is nested inside another loop, and
otherwise with the \vcc{_(writes)} set of the function. For every
purely local variable \vcc{v} that is not explicitly update in the
loop, there is an implicit loop invariant \vcc{_(invariant v == \at(s,v))},
where \vcc{s} is the state at loop entry.

VCC verifies a loop by translating it as follows. 

\begin{VCC}
_(assert all variables in the writes set are writable)
<set the writes set to the writes set of the loop>
_(assert <loop invariants>)
<havoc all variables in the writes set, and all purely local variables
 updated in the loop body>
_(assert <loop invariants>)
<loop body>
_(assume 0)

\end{VCC}

Here, a loop test is considered part of the loop body itself; if the
test succeeds, there is a loop exit to an implicit label just after the
loop). For each annotation \vcc{_(ensures p)} on the loop, VCC asserts 
\vcc{p} on any loop exit. On any loop exit, VCC adds to the writes set
the value of the writes set on loop entry.

VCC does not allow jumps into loops, but does allow jumps out of
loops.

\subsection{Goto Statement}
Gotos within ghost code cannot use a target outside of
the \vcc{_(ghost)} annotation in which the goto occurs.

VCC requires that the control flow graph inside a function body is
reducible. 

\subsection{Atomic Actions}

\subsubsection{Closed Object Lists}
The atomic actions all make use of \Def{closed object lists}. A closed
object list is a nonempty, comma-separated list, each element of which is either
an object or a set of objects, each element possibly preceded
by \vcc{_(read_only)}. To validate an object \vcc{o} in the list is to 
\vcc{_(assert o->\closed)} and then \vcc{_(assume \inv(o))};
to validate an object set is to assert that all
objects in the set are \vcc{\closed}. To validate the entire list is
to validate the elements in left-to-right order. A validation of the
list consists of this sequence of assertions performed in a particular
state. The read objects of a validation is the set of objects ocurring
in the list, along with the union of sets ocurring in the list, as
evaluated in the validation state. The set of write objects of a validation
is defined the same way, but omitting those elements annotated
as \vcc{_(read_only)}. 

Caveat: VCC currently does not allow object sets. This should change
in the future.

\subsubsection{Ghost Atomic Actions}
A ghost atomic action has the form \vcc{_(ghost_atomic obs block)},
where \vcc{obs} is a closed object list and \vcc{block} is a code
block. The block is considered to be in a ghost context. 
The action translates to the following:

\begin{VCC}
<validate obs>;
_(assert all read objects of the validation are ghost objects);
\state s = \now();
<block>
\state t = \now();
t->\last = s;
_(assert \forall \object o; o \in <write objects of the validation above>
  ==> \inv2s(o,s,\now))
<\last = s>
\end{VCC}

The ghost block is subject to the following restructions (beyond those
normally in effect for ghost code). Only pure function calls are
allowed, and all such calls must occur before the first state update. The
block cannot include atomic actions, ghost atomic
actions, \vcc{_(wrap)} or \vcc{_(unwrap)}. For each state update,
there is an implicit assertion that the object updated is
either \vcc{\mutable} or is in the write object set of the validation
of \vcc{obs}. There are no limitations on reads.

Note that ghost atomic actions do not introduce an implicit scheduler
boundary, unlike non-ghost atomic actions. This is because the
scheduling of ghost actions can be viewed as angelic, rather than
demonic.

\subsubsection{Atomic Actions}

An \vcc{_(atomic)} block is a code block preceded by the
annotation \vcc{_(atomic obs)}. Atomic blocks cannot be nested, and
cannot appear inside of \vcc{_(ghost_atomic)} blocks. 

An atomic block can contain at most one annotation of the
form \vcc{_(begin_update)}; if it occurs, it must occur at the top
level (i.e., not inside a conditional or loop). If the block contains
no such annotation, one is implicitly added at the beginning of the
block. 

Execution of an atomic block translates approximately as follows:
\begin{VCC}
\state s = \now();
<set the current state to an arbitrary good state>
_(assert \me == \at(s,\me))
_(assert \forall \object o; \at(s, \wrapped(o) || \mutable(o))
    ==> \unchanged(o->\version) && \unchanged(o->\volatile_version))
s = \stutter(\now());
<translation code block before _(begin_update)>
<validate obs>
s = \now();
<translation of code block after _(begin_update)>
foreach (\object o \in obs not marked _(read_only))
  _(assert \inv2s(o, s,\now()))
\end{VCC}

Before the \vcc{_(begin_update)}, the only operations allowed
are \vcc{_(wrap)}, \vcc{_(unwrap)}, memory operations on mutable data,
\vcc{_(ghost_atomic)} operations 

Inside an atomic block, on any atomic access to a field of an object,
VCC asserts that the object is either \vcc{\mutable} or is one of the
read objects of the validation. If the access is a write, it asserts
that it is one of the write objects of the validation.

If the body contains more than one memory access of a concrete object
other than stack variables, at at least one such access along with a
call to a \vcc{_(atomic_inline)} function, VCC will warn that the block might
not appear atomic. Beyond this, it is up to the user to make sure that the
compiler and hardware platform on which the program executes guarantees that 
the accesses to volatile concrete memory within the
atomic action in a way that appears to be atomic. 

, only pure function calls are permitted, and 
these are allowed only in full-stop states. 

A full-stop state is a state in which all object invariants are known
to hold. The only program points that are not guaranteed to be
full-stop states are points within an atomic action after the state
has been updated by an assignment.

\subsubsubsection{Atomic Operations}

\noindent\vcc{_(atomic_op obs, e)} (cast)\\
This cast cannot occur in a pure context or within an atomic action.
It has the effect of turning the evaluation of the following
expression \vcc{exp} into approximately the following:
\begin{VCC}
_(atomic obs) {
  T \result = exp;
  e;
}
\end{VCC}
with \vcc{\result} being the result returned from the execution. 

Note: it is unfortunate that \vcc{e} can only be an expression, rather
than an arbitrary code block; this restriction is in place because C
does not allow code blocks to appear inside expressions. 

\subsubsubsection{Atomic Reads}

\vcc{_(a_atomic_read obs)} (cast)\\
An atomic read acts just like an atomic action, with all of its
objects implicitly marked \vcc{_(read_only)}, except that it applies
to the implicit sequentialization of the compuation of the term to
which it is applied.

TODO: move the following to the right place.
\\
%// the VccAtomicOp AST class uses this
\vcc{_(void _vcc_atomic_op(\object, ...);)}\\


\section{Library Functions}

\vcc{\bool \fresh(\object o)}\\
This predicate can appear only in a thread context or in a function or block
\vcc{_(ensures)} annotation; it means that the object was not owned by this thread
when the function was called.
\\\\
\vcc{\nested(\object o)}\\
True iff \vcc{o->\owner} is not a thread.
\\\\
\vcc{\non_primitive_ptr(void *o)}\\
True iff the type of \vcc{o} is a pointer to an object type. 
\\\\
\vcc{\objset \span(\object o)}\\
The set consisting of \vcc{o}, along with a pointer to each primative field of \vcc{o}.
\\\\
\vcc{\objset \extent(\object o)}\\
This returns \vcc{\span(o)}, along with \vcc{\extent} of any struct fields of \vcc{o}.
\\\\
\vcc{\full_extent(\object)}\\
The set consisting of \vcc{\extent(o)}, unioned with the \vcc{\full_extent} of any members of any union field of \vcc{o}.
\\\\
\vcc{\extent_mutable(\object o)}\\
Translates to \vcc{\forall \object o1; o1 \in \extent(o) ==> \mutable(o)}.
\\\\
\vcc{\extent_zero(\object)}\\
True if every all bytes in the primitive fields of \vcc{o} or in padding between fields of \vcc{o} is \vcc{0}.
\\\\
\vcc{\extent_fresh(\object)}\\
True if every nonprimitive object in the extent of \vcc{\extent(o)} is \vcc{\fresh}.
\\\\
\vcc{\bool \thread_local(\object o)}\\
True iff it is in the \vcc{\domain} of some object 
\vcc{o1} that is \vcc{\wrapped} or \vcc{\mutable}.
\\\\
\vcc{\bool \thread_local_array(\object o, size_t s)}\\
True iff \vcc{\forall size_t i; i < s ==> \thread_local(o + s)}.
\\\\
\vcc{\bool \mutable(\object o)}\\
True iff \vcc{o->\closed && o->\owner == \me}.
\\\\
\vcc{_(bool \mutable_array(\object o, size_t s)}\\
True iff \vcc{\forall size_t i; i < s ==> \mutable(o + s)}.
\\\\
\vcc{_(bool \in_array(\object o, \object o1, size_t s) )}\\
True iff \vcc{\exists size_t i; i < s && o == o1 + s}. 
\\\\
\vcc{\objset \array_range(\object o, size_t s)}\\
The set of all objects \vcc{o+i} where \vcc{size_t i < s}.
\\\\
\vcc{\objset \domain(\object o)}\\
Returns the sequential ownership domain of \vcc{o}.
\\\\
\vcc{_(\objset \vdomain(\object))}\\
\\\\
\vcc{_(bool \domain_updated_at(\object p, \objset wr))}\\
\\\\
\vcc{_(\type \typeof(\object o))}\\
Returns the type of the thing pointed to by \vcc{o}
(which is \vcc{o->\type} if \vcc{o} is an object).
\\\\
\vcc{\bool \ghost(\object o)}\\
True iff \vcc{o} is a ghost object.
\\
\vcc{T ^\alloc_array<T>(\size_t s))}\\
\vcc{T ^\alloc<T>()}\\
Here, \vcc{T} is a type name. \vcc{\alloc<T>()} allocates a fresh object
of type \vcc{T} on the ghost heap, and returns a pointer to the new
object. \vcc{\alloc_array<T>(s)} allocates an array of \vcc{s} such
ghost objects.


\vcc{_(bool \not_shared(\object))}\\
\\\\
\vcc{\bool \malloc_root(\object o))}\\
True iff \vcc{o} is the root object of a memory allocation.
\\
\vcc{\bool \object_root(\object o))}\\
True iff \vcc{o} was directly created from a blob.
\\
\vcc{_(bool \union_active(\object))}\\
True if \vcc{o} is the currently active member of a valid union.
\\\\
\vcc{\bool \addr_eq(\object o1,\object o2))}\\
True iff \vcc{\addr(o1) == \addr(o2)}.
\\\\
\vcc{\bool \arrays_disjoint(\object o1, size_t s1, \object o2, \size_t s2)}\\
\vcc{o1} and \vcc{o2} must be arrays with the same basetype.
True iff \vcc{(\forall size_t i1,i2; i1 < s1 && i2 < s2 ==> o1[i1] != o2[i2])}.
\\\\
\vcc{\bool \wrapped_with_deep_domain(\object o)}\\
This is semantically equivalent to \vcc{\wrapped(o)}. However, it
causes VCC to assert that, for any object \vcc{o1} in the sequential
domain of \vcc{o}, \vcc{o1 \in \domain(o)}.
\\\\
\vcc{\object \domain_root(\object o)}\\
If there is an \vcc{\object o1} such that \vcc{o} is transitively
owned by \vcc{o1}, \vcc{o1} is not a thread, and \vcc{o1->\owner} is a
thread, then this function returns \vcc{o1}. Otherwise, it returns an
arbitrary object.
\\\\
\vcc{_(\integer _(_boogie0) \index_within(\object o1,\object o2))}\\
Semantically equivalent to \vcc{\address(o1) - \address(o2) / sizeof(\type(o2))}, but
uses a more efficient representation internally.
\\\\
\vcc{_(bool \writable(\object))}\\
This predicate is allowed only in function bodies, not in function
contracts. It hold if the argument was either listed in the writes
clause of the function or if it is owned by the thread and was not
owned by the thread when the function was called.
\\\\
\vcc{\natural \size(e)}\\
\vcc{e} must be an expression of integral or \vcc{record}
type, all of whose fields are of such type. If \vcc{e} is of integral
type, this returns the absolute value of \vcc{e}. If \vcc{e} is a
record type, this returns 1 plus the sum of the sizes of the fields
of \vcc{e}. 
\\\\
\vcc{\bool \shallow_eq(T s, T t)}\\
\vcc{s} and \vcc{t} must be of the same structured type.
This returns \vcc{\true} iff \vcc{s} and \vcc{t} have the same
values for all explicit fields of non-structured type.
\\\\
\vcc{\bool \deep_eq(T s, T t)}\\
\vcc{s} and \vcc{t} must be of the same structured type. 
This returns \vcc{\true} iff \vcc{\shallow_eq(s,t)} and, for each explicit
structured field \vcc{f} of type \vcc{T}, 
\\\\
\vcc{\bool \wrapped0(\object o)}
Equivalent to \vcc{\wrapped(o) && o->\claim_count == 0)}.
\\\\
\vcc{\bool \unchanged(e)}\\
\vcc{\bool \same(e)}\\
Equivalent to \vcc{(\old(e) == e)}. Note that \vcc{\old} has
different meanings depending on context.\\
\\\\
\vcc{size_t \sizeof_object(\object o)}\\
Equivalent to \vcc{\sizeof(T)}, where \vcc{T} is the type of \vcc{o}.


\section{Implicit fields}

VCC adds a number of implicit fields to each object:

\vcc{volatile \natural \claim_count}\\
For objects of types marked as \vcc{_(claimable)}, this field counts how many claims claim this object.

\vcc{volatile bool \closed}\\
This indicates whether an object is closed (section \ref{object invariants})

\vcc{volatile \objset \owns;}\\
This gives the set of objects owned by this object (if it is closed);
when open, it gives the set of objects that will be transfered to it
when it is wrapped.  This field is considered volatile only for types
that are marked as \vcc{_(volatile_owns)}; otherwise, it is a
sequential field.

\vcc{\volatile \object \owner}\\
This gives the owner of this object. 

\vcc{volatile bool \valid}\\
This is true iff the object is in the typestate (section ??). 



\section{Inference}

If \vcc{\wrapped(e)} is a top-level conjunct of a precondition of a
function, then  \vcc{_(requires e _(assume) \in \domain(e))} is implicitly added
to the function contract, unless ??. If \vcc{e} is of \vcc{\claim}
type, then \vcc{_(requires _(assume) \valid_claim(e))} is implicitly added to
the contract, unless ??.

If \vcc{\claims(c, \closed(o))} is a top-level conjunct of a
precondition of a function, then the
preconditions \vcc{_(requires _(assume) \always_by_claim(c,o))}
and \vcc{_(requires _(assume) \inv(o)} are added to the
function, unless the function is preceded by the .


\vcc{_(isolate_proof)} (function attribute)\\
This causes VCC to verify this function in a prover session that is
isolated from the rest of the verification session. (That is, the
function should verify if and only if it was the only function being verified.)
\\\\
\vcc{_(frameaxiom)} (specifier)\\
This forms can only be used as a specifier for a  \vcc{pure} function
with a \vcc{reads} clause. It tells VCC to generate an axiom that says
that for any two states that agree on the values of the objects in the
\vcc{_(reads)} clause of the function, the funciton returns the same
value.
\\\\
\vcc{_(no_frameaxiom)}\\
This annotation can appear only on a \vcc{_(pure)} function with
a \vcc{_(reads)} clause. It says not to generate a frame axiom for the
function. 

%% #define vcc_force_splits(n) \
%%   __declspec(System.Diagnostics.Contracts.CodeContract.IntBoogieAttr, "vcs_max_splits", n) \
%%   __declspec(System.Diagnostics.Contracts.CodeContract.IntBoogieAttr, "vcs_max_cost", 1)
%% #define vcc_keep_going(n) \
%%   __declspec(System.Diagnostics.Contracts.CodeContract.IntBoogieAttr, "vcs_max_keep_going_splits", n)
%% #endif


\subsection{Triggering}
VCC uses an SMT solver as its reasoning backend. SMT solvers typically
work at the level of ground terms, and handle quantifiers by means of
triggers - patterns that, when matched by terms arising in deduction,
cause instances of quantified formulas to be generated. In each
annotation containing a quantification, VCC allows optionally the
inclusion of explicit triggers. If these are not included, VCC
generates triggers automatically. In most cases, it is best to allow
VCC to generate triggers on its own, since it avoids the possibility
of instantiation loops. However, on rare occasions, you may want to
provide your own. <TODO>
\\\\
\vcc{_(bool _(pure) \match_long(__int64 ) _(ensures \result == \true);)}\\
\vcc{_(bool _(pure) \match_ulong(unsigned __int64) _(ensures \result == \true);)}\\
These functions are declared with the contracts given above. They are provided as a
convenience for writing triggers. 

\subsection{Debugging}
The features of this section are included only to aid in the debugging
of verifications; they should never appear in a final program. Use of
any of these annotation may render verification unsound.
\\\\
\vcc{\bool \start_here()}\\
This predicate can appear only in the
annotation \vcc{_(assume \start_here())}; it tells VCC to not verify
any of the assertions in the current function that lexically precede
this statement. At most one such annotation should appear within any
function. 
\\\\
\vcc{_(assume_correct)} (specifier)\\
This annotation can appear only immediately preceding a function
definition. It tells VCC to not verify this function, i.e. to consider
all of the assertions generated inside the body of the function
definition to be assumptions.
\\\\
\vcc{_(no_reads_check)} (specifier)\\
This  can only be used as an attribute of a \vcc{pure} function
with a \vcc{reads} clause. It causes VCC to not perform the reads
check for the function, i.e. to not check that the function depends
only on the objects listed in the reads clause.
\\\\
\vcc{_(no_admissibility)} (specifier)\\
This annotation can appear only immediately before the definition of
a \vcc{struct}, \vcc{union}, or \vcc{_(record)} type. It tells VCC to
omit checking the admissibility of the following type.

\subsection{Smoke Tests}
Smoke testing (which is not done by default) causes VCC to check that no control
location of the program is provably unreachable (provable in the sense
of VCC's treatment of what is known where). This amounts to checking
that an \vcc{\assert(\false)} added to any location would fail (with
some reasonably small timeout). Because deduction is incomplete, smoke
testing is not sound (though it does not interfere with the soundness
of the proofs of other properties being verified).

An explicit \vcc{_(assert \false)} at the beginning of a block causes
smoke testing to be omitted for that block. 
\\\\
\vcc{_(known \bool val)} (cast)\\
\vcc{val} must be the literal \vcc{\true} or the
literal \vcc{\false}. It asserts that the cast expression has
value \vcc{val}. If the expression is the test of a conditional or loop, or
the first argument to \vcc{||} or \vcc{&&} or \vcc{?:}, it disables
smoke testing for the branch that is known not to be taken.
\\\\
\vcc{_(skip_smoke)} (specifier)\\
This annotation causes VCC to skip smoke testing on the following function.

\subsection{Verification Switches}
VCC has a number of parameters that effect how verification is
performed. These can be adjusted using arguments to the command used
to run VCC (either on the command line or through the Visual Studio
pluggin). 

Some of these can be overridden for individual functions by
means of attributes put on individual function definitions. These
attributes are currently expressed with the special top-level form 
\vcc{vcc_attr(<property>, <value>)} just before a function
definition. Here, \vcc{<property>} is a string giving the name
of the property and \vcc{<value>} is a string giving the value for
that property. 


\section{Caveats}
VCC is intended to be \emph{sound}, which is to say that if VCC
verifies your program without giving any errors or warnings, the
program is correct (the meaning of correctness is defined in section
??). It is not intended to be complete, which is to say that there are
programs that are correct that you will not be able to verify with
VCC, perhaps even some programs that might be verified with other
tools. There are also some programs that require minor syntactic
changes to be verified; while we can (and have) extend the annotation
syntax to handle such cases, such activity eventually meets with
diminishing returns.

When reasoning about concurrency, VCC assumes that programs are
running under the standard model of shared variable concurrency,
namely sequentially consistent memory. Most architectures, including
x86 and ARM, provide somewhat weaker memory models. VCC as described
here is not sound for these models in general. However, it is sound if
further conditions on the program are met. One simple restriction that
suffices (for x86 and other TSO architectures) is that all writes are
interlocked (i.e., all volatile atomic updates flush the store
buffers). VCC will hopefully support checking weaker conditions in the
future.

VCC currently does not allow arrays of size 0 at the end of a struct.

\section{Macros}
VCC allows the user to define new annotation tags. This is done with
a top-level annotation of the form
\begin{VCC}
_(bool \macro_<Name>(args) {
  <body>
}
\end{VCC}
where \vcc{<Name>} is the name of the new annotation tag,
and \vcc{<args>} gives the remaining arguments that occur within the
annotation. <TODO>



\end{document}

% vim: spell
Not all objects can be reinterpreted. To see why, suppose there was an
object \vcc{o} of \vcc{struct} type \vcc{T} that had a
single \vcc{struct} field \vcc{f} of some other type \vcc{T'}, where \vcc{o}
and \vcc{&o->f} had different owners. If the owner of \vcc{&o->f}
could reinterpret it, he could turn it into an object of
type \vcc{T}. This would mean that there were two different objects of
type \vcc{T} with the same address. In older versions of VCC, this was
okay because these objects could be distinguished by their embeddings (their
immediately containing object). However, embeddings have now been
removed except for primitive fields, so this situation would lead to
inconsistency. (Note that the same situation could occur if \vcc{f}
had multiple fields, as long as all of them are reinterpretable.)
