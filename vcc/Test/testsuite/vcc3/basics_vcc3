#include <vcc.h>

void foo(int *a) {
	int b = *a;
}
`
Verification of foo failed.
testcase(4,11) : error VC8512: Assertion 'a is thread local' did not verify.
`
`/omitrw
#include <vcc.h>

void foo(int *a) {
	int b = *a;
}
`
Verification of foo succeeded.
`
#include <vcc.h>

bool _vcc_full_stop();

struct foo {
  int x;
  invariant(_vcc_full_stop())
  invariant(x > 0)
};
`
Verification of foo#adm failed.
testcase(7,15) : error VC8012: invariant(_vcc_full_stop()) of foo is not admissible.
testcase(7,15) : error VC8018: invariant(_vcc_full_stop()) of foo forbids unwrapping.
`
#include "vcc.h"

typedef unsigned __int64 uint64;

void testme(uint64* p)
  requires(thread_local(p))
  requires(mutable((uint64*)(*p)))
  requires(p != (uint64 *)(*p))
  writes((uint64 *)*p)
{

    *((uint64*)(*p)) = 5;
}
`
Verification of testme succeeded.
`
#include "vcc.h"

struct x {
  int dummy;
};

struct y {
  int dummy;
  struct x *xp;
  invariant(closed(xp)) 
};
`
Verification of y#adm failed.
testcase(10,15) : error VC8012: invariant(_vcc_closed(xp)) of y is not admissible.
`
#include "vcc.h"
#ifdef VERIFY
struct vcc(dynamic_owns) S { int a; obj_t b;};
// both are OK now, we assume that stuff in owns set is non-primitive
void foo(struct S *s) requires(wrapped(s)) {
    assume(set_in(s->b,owns(s)));
    assert(owner(s->b) == s);
}
void foo2(struct S *s) requires(wrapped(s)) {
    assume(set_in(s->b,owns(s)));
    assume(is_non_primitive_ptr(s->b));
    assert(owner(s->b) == s);
}

void t()
{
  struct S s;
  assert(is_non_primitive_ptr(&s));
}
void t2()
{
  int x;
  assert(is_non_primitive_ptr(&x));
}
#endif
`
Verification of foo succeeded.
Verification of foo2 succeeded.
Verification of t succeeded.
Verification of t2 failed.
testcase(23,12) : error VC9500: Assertion '_vcc_is_non_primitive_ptr(&x)' did not verify.
`
`/newsyntax
#include <vcc.h>
#include <limits.h>

#define disj(da, la, db, lb) ((db > (da + la) || da > (db + lb)) && \arrays_disjoint(da,la,db,lb))

void foo(int *q, size_t l)
_(writes \array_range(q,l))
;

void test(int *p, int *q, size_t l) 
_(requires disj(p,l,q,l))
_(requires 0 < l)
_(requires \mutable_array(q,l))
_(requires \mutable_array(p,l))
_(writes \array_range(q,l))
{
   _(assume p[0] == 0)
   foo(q,l);
   _(assert p[0] == 0)
}
`
Verification of test succeeded.
`
`/newsyntax
#include <vcc.h>
#include <limits.h>

void foo(int *q, size_t l)
_(writes \array_range(q,l))
;

void test(int *p, size_t l) 
_(requires \mutable_array(p,l))
_(writes \array_range(p,l))
{
   _(assume l > 3)
   _(assert \mutable_array(p+1,l-2))
   foo(p+1,l-2); // fails
}

`
Verification of test succeeded.
`
