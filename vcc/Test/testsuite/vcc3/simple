#include <vcc.h>

struct vcc(dynamic_owns) A {
  int x;
  invariant(x > 0)
};


void foo(struct A *a) {
}
`
Verification of A#adm succeeded.
Verification of foo succeeded.
`
#include <vcc.h>

struct vcc(dynamic_owns) A {
  int x;
  invariant(x > 0)
};

struct vcc(dynamic_owns) B {
  struct A *a;
  int y;
  invariant(keeps(a))
  invariant(a->x > y)
};

struct vcc(dynamic_owns) C {
  struct A *a;
  int y;
  invariant(a->x > y)
};


void foo(struct B *a, struct C *c) {
}
`
Verification of A#adm succeeded.
Verification of B#adm succeeded.
Verification of C#adm failed.
testcase(18,15) : error VC8012: invariant(a->x > y) of C is not admissible.
Verification of foo succeeded.
`
#include "vcc.h"


struct vcc(dynamic_owns) A {
  int a;
  int b[10];

  invariant(a > 0)
  invariant(b[0] > 0)
  invariant(b[1] > 0)
};


struct vcc(dynamic_owns) A_wrong1 {
  int a;
  int b[10];

  invariant(b[10] > 0)
};

struct vcc(dynamic_owns) A_wrong2 {
  int a;
  int b[5];

  invariant(b[10] > 0)
};


void foo(struct A *x)
  requires(wrapped(x))
  writes(x)
{
  
  unwrap(x);
  x->a = 10;
  x->b[0] = 10;
  x->b[1] = 10;
  wrap(x);
}

void fooWrong1(struct A *x)
  requires(wrapped(x))
  writes(x)
{
  
  unwrap(x);
  x->b[10] = 10;
  x->b[11] = 10;
  x->b[-1] = 10;
  wrap(x);
}
`
Verification of A#adm succeeded.
Verification of A_wrong1#adm failed.
testcase(18,15) : error VC8012: invariant(b[10] > 0) of A_wrong1 is not admissible.
Verification of A_wrong2#adm failed.
testcase(25,15) : error VC8012: invariant(b[10] > 0) of A_wrong2 is not admissible.
Verification of foo succeeded.
Verification of fooWrong1 failed.
testcase(47,3) : error VC8507: Assertion 'x->b[10] is writable' did not verify.
testcase(48,3) : error VC8507: Assertion 'x->b[11] is writable' did not verify.
testcase(49,3) : error VC8507: Assertion 'x->b[-1] is writable' did not verify.
`
#include <vcc.h>

struct A {
  int a;
  int b;
};

struct B {
  struct A x;
  struct A y;
  int z;
};

void foo()
{
  struct B *b, *c;

  assume(mutable(b) && mutable(c));

  assert(set_in(&b->z, extent(b)));
  assert(set_in(&b->x, extent(b)));
  assert(set_in(&b->x.a, extent(b)));
  assert(set_in(&b->y, extent(b)));
  assert(set_in(&b->y.b, extent(b)));

  assert(set_in(&b->y.b, extent(c)));
}
`
Verification of foo failed.
testcase(26,12) : error VC9500: Assertion '_vcc_set_in(&b->y.b,_vcc_extent(c))' did not verify.
`
#include <vcc.h>

struct A {
  int x;
  int y;
};


void fooFail(struct A *a)
  writes(&a->x)
{
  while (true)
    writes(&a->x,&a->y)
  { a->x = 0; }
}

void fooOk(struct A *a)
  writes(&a->x,&a->y)
{
  while (true)
    writes(&a->x,&a->y)
  { a->x = 0; }
}

void fooOkWrap(struct A *a)
  writes(a)
  requires(wrapped(a))
{
  unwrap(a);
  while (true)
    writes(&a->x,&a->y)
  { a->x = 0; }
}


void fooFailWrap(struct A *a)
  writes(a)
  requires(wrapped(a))
{
  int z;
  unwrap(a);
  wrap(a);
  while (true)
    writes(&a->x)
  {
    z = 0;
  }
}

`
Verification of fooFail failed.
testcase(13,15) : error VC8011: writes clause of the loop might not be included writes clause of the function.
Verification of fooOk succeeded.
Verification of fooOkWrap succeeded.
Verification of fooFailWrap failed.
testcase(44,15) : error VC8011: writes clause of the loop might not be included writes clause of the function.
`
#include <vcc.h>
struct S { int a; };
struct T { int b; };

void foo()
{
  struct S *s, *s2;
  struct T *t;
  int *i;
  

  if (s == i) { 
  }

  if (s == t) { 
  }

  if (s == s2) { 
  }

  assert(s == t);
  assert((void*)s == (void*)t);
  assert(s == i);

  assert(s == (struct S*)t);
  assert((char*)s == (char*)t);
  assert(s == s2);

  // comparing against null shouldn't produce warnings
  assert(s == (void*)0);
  assert(s == (struct S*)0);
  assert((void*)0 == s);
  assert((struct S*)0 == s);
  // these should be also translated as comparing against null
  assert(s);
  assert(!s);
  assert(s ==> 1 > 0);
}

`
testcase(21,12) : warning VC9124: pointers of different types (struct S and struct T) are never equal in pure context
testcase(22,12) : warning VC9124: pointers of different types (struct S and struct T) are never equal in pure context
testcase(23,12) : warning VC9124: pointers of different types (struct S and int32_t) are never equal in pure context
Verification of foo failed.
testcase(21,12) : error VC9500: Assertion 's == t' did not verify.
`
#include <vcc2.h>

struct A {
  int f;
  volatile int g;
};

void bar(struct A *a)
  maintains(wrapped(a))
{
  atomic(a) {
    a->g = 3;
  }
}

void foo()
{
  struct A a;

  a.f = 1;
  a.g = 2;
  wrap(&a);
  assert(a.f == 1 && a.g == 2);
  bar(&a);
  assert(a.f == 1);
  assert(a.g == 2); // should fail
  unwrap(&a);

}
`
Verification of bar succeeded.
Verification of foo failed.
testcase(26,12) : error VC9500: Assertion 'a.g == 2' did not verify.
`
