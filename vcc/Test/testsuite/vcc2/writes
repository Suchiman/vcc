#include <vcc2test.h>

void foo0(int *p)
  requires(mutable(p))
{
  *p = 7;
}

struct A {
  int x;
};

void foo1(struct A *a)
  requires(mutable(a))
{
  a->x = 7;
}

void foo2(struct A *a)
  writes(a)
  requires(mutable(a))
{
  a->x = 7;
}

void foo3(struct A *a)
  writes(&a->x)
  requires(mutable(a))
{
  a->x = 7;
}

void foo4(struct A *a)
  requires(wrapped(a))
  writes(a)
{
  unwrap(a);
  a->x = 7;
  wrap(a);
}

void foo5(struct A *a)
  requires(wrapped(a))
{
  unwrap(a);
  a->x = 7;
  wrap(a);
}


`
Verification of foo0 failed.
testcase(6,4) : error VC8507: Assertion 'p is writable' did not verify.
Verification of foo1 failed.
testcase(16,3) : error VC8507: Assertion 'a->x is writable' did not verify.
Verification of foo2 failed.
testcase(23,3) : error VC8507: Assertion 'a->x is writable' did not verify.
Verification of foo3 succeeded.
Verification of foo4 succeeded.
Verification of foo5 failed.
testcase(45,15) : error VC8021: 'a' is not writable before unwrapping it.
`
#include <vcc2test.h>

struct A {
  int x;
};

void foo4(struct A *a)
  requires(wrapped(a))
  writes(a)
{
  int x = 0;
  while(x++ < 3) 
    invariant(x <= 3)
    invariant(wrapped(a))
  {
    unwrap(a);
    a->x = 7;
    wrap(a);
  }
}

void foo5(struct A *a)
  requires(wrapped(a))
  writes(a)
{
  int x = 0;
  while(x++ < 3) 
    writes(set_empty())
    invariant(x <= 3)
    invariant(wrapped(a))
  {
    unwrap(a);
    a->x = 7;
    wrap(a);
  }
}

void foo6(struct A *a)
  requires(wrapped(a))
{
  int x = 0;
  while(x++ < 3) 
    writes(a)
    invariant(x <= 3)
    invariant(wrapped(a))
  {
    unwrap(a);
    a->x = 7;
    wrap(a);
  }
}
`
Verification of foo4 succeeded.
Verification of foo5 failed.
testcase(32,17) : error VC8021: 'a' is not writable before unwrapping it.
Verification of foo6 failed.
testcase(43,14) : error VC8011: writes clause of the loop might not be included writes clause of the function.
`
#include <vcc2test.h>

typedef struct A {
  int x,y,z;
} A;

A *foo( A*p)
  writes(extent(p))
  requires(is_malloc_root(p))
  ensures(is_fresh(result))
  ensures(typed(result) && mutable(result))
{
  free(p);
  return malloc(sizeof(A));
}

void donothing();

void use()
{
  A loc;
  A *p1 = malloc(sizeof(A));
  A *p2 = malloc(sizeof(A));
  A *t1, *t2;

  donothing();
  t1 = foo(p1);
  donothing();
  assert(p2 != t1);
  t2 = foo(p2);
  donothing();
  assert(t1 != t2);
  assert(t1 != &loc);
  assert(t2 != &loc);
}
`
Verification of foo succeeded.
Verification of use succeeded.
`
#include <vcc2.h>

typedef struct { int x; } A;

void update_after_wrap(A* p)
  writes(extent(p))
{
  set_owns(p, set_empty());
  wrap(p);
  p->x = 12;
}
`
Verification of update_after_wrap failed.
testcase(10,3) : error VC8507: Assertion 'p->x is writable' did not verify.
`
#include "vcc2.h"

struct DESC {
	int a,b,c;
};

struct DESC2 {
	int a;
	struct DESC d1;
	struct DESC d2;
};

void test_wr(struct DESC2 *d)
    writes(extent(d))
{
	assert(mutable(d));
	assert(mutable(&d->a));
	assert(mutable(&d->d1));
	assert(mutable(&d->d1.b));
}
`
Verification of test_wr succeeded.
`
#include "vcc2.h"

#define UINT32 unsigned int

#define MAX_GPX 10

typedef union pte_t {
    struct {
        unsigned reserved_9_0:10;    /* bits [9:0] */
        unsigned p:1;    /* bit [10] */
        unsigned v:1;    /* bit [11] */
        unsigned ppx:20;    /* bits [31:12] */
    };            /* PTE fields */
    backing_member 
        UINT32 uint32;    /* complete word */
} pte_t;

void test1(UINT32 *mem)
requires(is_thread_local_array(mem, 100))
{
   UINT32 b;
   b = mem[0];
}

void test2(UINT32 *mem)
requires(is_thread_local_array(mem, 100))
{
    pte_t tmp;
    tmp.uint32 = mem[0];
}
`
Verification of test1 succeeded.
Verification of test2 succeeded.
`
#include <stdlib.h>
#include "vcc2.h"

#define UINT32 unsigned int

#define MAX_GPX 10

typedef union pte_t {
    struct {
        unsigned reserved_9_0:10;    /* bits [9:0] */
        unsigned p:1;    /* bit [10] */
        unsigned v:1;    /* bit [11] */
        unsigned ppx:20;    /* bits [31:12] */
    };            /* PTE fields */
    backing_member 
        UINT32 uint32;    /* complete word */
} pte_t;


ispure UINT32 ptea(UINT32 pto, UINT32 vpx)
requires(vpx<0x100000)
returns(((pto%0x100000) << 10) + vpx); 


void test1( UINT32 *gm, UINT32 pto) 
    requires(is_thread_local_array(gm, (MAX_GPX+1)*1024))
{  
    pte_t hpte, gpte;

	assert(is_thread_local_array(gm, (MAX_GPX+1)*1024));

    gpte = (*(pte_t*)(&gm[ptea(pto, 0)])); 
		    
    assert(is_thread_local_array(gm, (MAX_GPX+1)*1024));

} 

void test2( UINT32 *gm, UINT32 pto) 
    requires(is_thread_local_array(gm, (MAX_GPX+1)*1024))
{  
    pte_t hpte, gpte;

	assert(is_thread_local_array(gm, (MAX_GPX+1)*1024));

    if ((ptea(pto, 0) >> 10) > MAX_GPX)    
		hpte.v = 0;    
	else {
            assert(is_thread_local_array(gm, (MAX_GPX+1)*1024));
            gpte = (*(pte_t*)(&gm[ptea(pto, 0)])); 
		    
            assert(is_thread_local_array(gm, (MAX_GPX+1)*1024));
    }
  
} 
`
Verification of test1 failed.
testcase(32,13) : error VC8512: Assertion '*(pte_t*)(&gm[ptea(pto, 0)]) is thread local' did not verify.
Verification of test2 succeeded.
`
#include <vcc2.h>

typedef struct { int x; } A;

void writes_p(A* p)
  writes(p)
{
  p->x = 12;
}

void writes_singleton_p(A* p)
  writes(set_singleton(p))
{
  p->x = 12;
}
`
Verification of writes_p failed.
testcase(8,3) : error VC8507: Assertion 'p->x is writable' did not verify.
Verification of writes_singleton_p failed.
testcase(14,3) : error VC8507: Assertion 'p->x is writable' did not verify.
`
#include "vcc2.h"

struct A {
int x;
};

struct A *get_a()
  ensures(mutable(result))
  ensures(is_fresh(result));

void foo()
{
  int x;
  struct A *a;

  while(x>0) {
    x--;
    a = get_a();
    a->x = 20;
  }
}

void foo2()
{
  int x;
  struct A *a;

  while(x>0) 
    writes(set_empty())
  {
    x--;
    a = get_a();
    a->x = 20;
  }
}
`
Verification of foo succeeded.
Verification of foo2 succeeded.
`
#include <vcc2.h>

typedef unsigned int UINT32;

typedef union pte_t {
    struct {
        unsigned reserved_9_0:10;    /* bits [9:0] */
        unsigned p:1;    /* bit [10] */
        unsigned v:1;    /* bit [11] */
        unsigned ppx:20;    /* bits [31:12] */
    };            /* PTE fields */
    backing_member 
        UINT32 uint32;    /* complete word */
} pte_t;


void test1(pte_t *arr)
{
    pte_t pte;
    UINT32 n;
    n = 0;
    
    while(n < 100)
      invariant(mutable(&pte.uint32))
//      writes(&pte.uint32)
    {
        pte.ppx = n;
        n++;
    }
}

void test2(pte_t *arr)
requires(is_mutable_array(arr, 100))
writes(array_range(arr, 100))
{
    pte_t pte;
    UINT32 n;
    n = 0;
    
    while(n < 100)
    invariant(is_mutable_array(arr, 100))
    writes(array_range(arr, 100))
      writes(&pte.uint32)
    {
        pte.ppx = n;
        n++;
    }
}

void test3(pte_t *arr)
requires(is_mutable_array(arr, 100))
writes(array_range(arr, 100))
{
    UINT32 n;
    n = 0;
    while(n < 100)
    invariant(is_mutable_array(arr, 100))
    writes(array_range(arr, 100))
    {
        arr[n].uint32 = n;
        n++;
    }
}


void test4(UINT32 *arr)
requires(is_mutable_array(arr, 100))
writes(array_range(arr, 100))
{
    UINT32 n;
    n = 0;
    while(n < 100)
    invariant(is_mutable_array(arr, 100))
    writes(array_range(arr, 100))
    {
        arr[n] = n;
        n++;
    }
}
`
Verification of test1 succeeded.
Verification of test2 succeeded.
Verification of test3 succeeded.
Verification of test4 succeeded.
`
#include <vcc2.h>
#include <stdlib.h>

struct vcc(claimable) S {
  volatile int c;
};

void foo(struct S **s) 
  writes(s)
{
//  spec( claim_t c;)
  struct S *a = (struct S *)malloc(sizeof(struct S) * 10);
  struct S *b = &a[0];
  wrap(b);
//  speconly(c = claim(b, true);)
  free((void *)as_array(a, 10));
//  atomic (c, b) {
//    b->c = 1;
//  }
}
`
Verification of foo failed.
testcase(16,3) : error VC8510: Assertion '_vcc_extent(p) is writable in call to free((void *)_vcc_as_array(a, 10))' did not verify.
`
#include <vcc2.h>

struct S {
  int x;
};

void bar(struct S *a, struct S *b)
  requires(thread_local(b))
  requires(typed(b))
  requires(a != b)
  writes(extent(a))
{
  a->x = 1;
  a->x = b->x;
}

void foo(int *a, int *b)
    requires(thread_local(b))
    requires(a != b)
    writes(a)
{
    *a = 5;
    *a = *b;
}
`
Verification of bar succeeded.
Verification of foo succeeded.
`
#include <vcc2test.h>

struct A { int x,y; };

struct B {
  struct A a1;
  struct A a2;
  int z;
};

void foo(struct B *b)
  requires(extent_mutable(b))
{
  assert(mutable(b));
  assert(mutable(&b->a1));
  assert(mutable(&b->a2));
}

struct B *alloc_B()
  ensures(extent_is_fresh(result) && extent_mutable(result))
{
  return (struct B*)malloc(sizeof(struct B));
}

void baz()
{
  struct B *b;

  b = alloc_B();
  b->z = 12;
  b->a1.y = 12;
  b->a2.x = 12;
}

struct C {
  struct A a[10];
};

struct C *alloc_C()
  ensures(extent_is_fresh(result) && extent_mutable(result))
{
  return (struct C*)malloc(sizeof(struct C));
}

void baz_C()
{
  struct C *b;

  b = alloc_C();
  b->a[1].x = 12;
}

void fail()
{
  struct B *b;
  assert(mutable(b) ==> extent_mutable(b));
}


void ok()
{
  struct A *b;
  assert(mutable(b) ==> extent_mutable(b));
}

void ok2(struct B *b)
  writes(extent(b))
{
  assert(extent_mutable(b));
}

`
Verification of foo succeeded.
Verification of alloc_B succeeded.
Verification of baz succeeded.
Verification of alloc_C succeeded.
Verification of baz_C succeeded.
Verification of fail failed.
testcase(56,12) : error VC9500: Assertion '_vcc_mutable(b) ==> _vcc_extent_mutable(b)' did not verify.
Verification of ok succeeded.
Verification of ok2 succeeded.
`
