`/newsyntax
#include <vcc.h>

void foo0(int *p)
  _(requires \mutable(p))
{
  *p = 7;
}

struct A {
  int x;
};

void foo1(struct A *a)
  _(requires \mutable(a))
{
  a->x = 7;
}

void foo2(struct A *a)
  _(writes a)
  _(requires \mutable(a))
{
  a->x = 7;
}

void foo3(struct A *a)
  _(writes &a->x)
  _(requires \mutable(a))
{
  a->x = 7;
}

void foo4(struct A *a)
  _(requires \wrapped(a))
  _(writes a)
{
  _(unwrap a)
  a->x = 7;
  _(wrap a)
}

void foo5(struct A *a)
  _(requires \wrapped(a))
{
  _(unwrap a)
  a->x = 7;
  _(wrap a)
}


`
Verification of foo0 failed.
testcase(6,4) : error VC8507: Assertion 'p is writable' did not verify.
Verification of foo1 failed.
testcase(16,3) : error VC8507: Assertion 'a->x is writable' did not verify.
Verification of foo2 failed.
testcase(23,3) : error VC8507: Assertion 'a->x is writable' did not verify.
Verification of foo3 succeeded.
Verification of foo4 succeeded.
Verification of foo5 failed.
testcase(45,26) : error VC8021: 'a' is not writable before unwrapping it.
`
`/newsyntax
#include <vcc.h>

struct A {
  int x;
};

void foo4(struct A *a)
  _(requires \wrapped(a))
  _(writes a)
{
  int x = 0;
  while(x++ < 3) 
    _(invariant x <= 3)
    _(invariant \wrapped(a))
  {
    _(unwrap a)
    a->x = 7;
    _(wrap a)
  }
}

void foo5(struct A *a)
  _(requires \wrapped(a))
  _(writes a)
{
  int x = 0;
  while(x++ < 3) 
    _(writes {})
    _(invariant x <= 3)
    _(invariant \wrapped(a))
  {
    _(unwrap a)
    a->x = 7;
    _(wrap a)
  }
}

void foo6(struct A *a)
  _(requires \wrapped(a))
{
  int x = 0;
  while(x++ < 3) 
    _(writes a)
    _(invariant x <= 3)
    _(invariant \wrapped(a))
  {
    _(unwrap a)
    a->x = 7;
    _(wrap a)
  }
}
`
Verification of foo4 succeeded.
Verification of foo5 failed.
testcase(32,28) : error VC8021: 'a' is not writable before unwrapping it.
Verification of foo6 failed.
testcase(43,28) : error VC8011: writes clause of the loop might not be included writes clause of the function.
`
`/newsyntax
#include <stdlib.h>
#include <vcc.h>

typedef struct A {
  int x,y,z;
} A;

A *foo( A*p)
  _(writes \extent(p))
  _(requires \malloc_root(p))
  _(ensures \result == NULL || \fresh(\result))
  _(ensures \result == NULL || (\result->\valid && \mutable(\result)))
{
  free(p);
  return malloc(sizeof(A));
}

void donothing();

void useA()
{
  A loc;
  A *p1 = malloc(sizeof(A));
  A *p2 = malloc(sizeof(A));
  A *t1, *t2;

  if (p1 != NULL && p2 != NULL) {
    donothing();
    t1 = foo(p1);
    if (t1 != NULL) {
      donothing();
      _(assert p2 != t1)
      t2 = foo(p2);
      if (t2 != NULL) {
        donothing();
        _(assert t1 != t2)
        _(assert t1 != &loc)
        _(assert t2 != &loc)
      }
    }
  }
}
`
Verification of foo succeeded.
Verification of useA succeeded.
`
`/newsyntax
#include <vcc.h>

typedef struct { int x; } A;

void update_after_wrap(A* p)
  _(writes \extent(p))
{
  _(ghost p->\owns =  {});
  _(wrap p)
  p->x = 12;
}
`
Verification of update_after_wrap failed.
testcase(10,3) : error VC8507: Assertion 'p->x is writable' did not verify.
`
`/newsyntax
#include "vcc.h"

struct DESC {
	int a,b,c;
};

struct DESC2 {
	int a;
	struct DESC d1;
	struct DESC d2;
};

void test_wr(struct DESC2 *d)
    _(writes \extent(d))
{
	_(assert \mutable(d))
	_(assert \mutable(&d->a))
	_(assert \mutable(&d->d1))
	_(assert \mutable(&d->d1.b))
}
`
Verification of test_wr succeeded.
`
`/newsyntax
#include "vcc.h"

#define UINT32 unsigned int

#define MAX_GPX 10

typedef union pte_t {
    struct {
        unsigned reserved_9_0:10;    /* bits [9:0] */
        unsigned p:1;    /* bit [10] */
        unsigned v:1;    /* bit [11] */
        unsigned ppx:20;    /* bits [31:12] */
    };            /* PTE fields */
    _(backing_member) 
        UINT32 uint32;    /* complete word */
} pte_t;

void test1(UINT32 *mem)
_(requires \thread_local_array(mem, 100))
{
   UINT32 b;
   b = mem[0];
}

void test2(UINT32 *mem)
_(requires \thread_local_array(mem, 100))
{
    pte_t tmp;
    tmp.uint32 = mem[0];
}
`
Verification of test1 succeeded.
Verification of test2 succeeded.
`
`/newsyntax
#include <stdlib.h>
#include "vcc.h"

#define UINT32 unsigned int

#define MAX_GPX 10

typedef union pte_t {
    struct {
        unsigned reserved_9_0:10;    /* bits [9:0] */
        unsigned p:1;    /* bit [10] */
        unsigned v:1;    /* bit [11] */
        unsigned ppx:20;    /* bits [31:12] */
    };            /* PTE fields */
    _(backing_member) 
        UINT32 uint32;    /* complete word */
} pte_t;


_(pure) UINT32 ptea(UINT32 pto, UINT32 vpx)
_(requires vpx<0x100000)
_(returns ((pto%0x100000) << 10) + vpx); 


void test1( UINT32 *gm, UINT32 pto) 
    _(requires \thread_local_array(gm, (MAX_GPX+1)*1024))
{  
    pte_t hpte, gpte;

	_(assert \thread_local_array(gm, (MAX_GPX+1)*1024))

    gpte = (*(pte_t*)(&gm[ptea(pto, 0)])); 
		    
    _(assert \thread_local_array(gm, (MAX_GPX+1)*1024))

} 

void test2( UINT32 *gm, UINT32 pto) 
    _(requires \thread_local_array(gm, (MAX_GPX+1)*1024))
{  
    pte_t hpte, gpte;

	_(assert \thread_local_array(gm, (MAX_GPX+1)*1024))

    if ((ptea(pto, 0) >> 10) > MAX_GPX)    
		hpte.v = 0;    
	else {
            _(assert \thread_local_array(gm, (MAX_GPX+1)*1024))
            gpte = (*(pte_t*)(&gm[ptea(pto, 0)])); 
		    
            _(assert \thread_local_array(gm, (MAX_GPX+1)*1024))
    }
  
} 
`
Verification of test1 failed.
testcase(32,13) : error VC8512: Assertion '*(pte_t*)(&gm[ptea(pto, 0)]) is thread local' did not verify.
Verification of test2 succeeded.
`
`/newsyntax
#include <vcc.h>

typedef struct { int x; } A;

void writes_p(A* p)
  _(writes p)
{
  p->x = 12;
}

void writes_singleton_p(A* p)
  _(writes {p})
{
  p->x = 12;
}
`
Verification of writes_p failed.
testcase(8,3) : error VC8507: Assertion 'p->x is writable' did not verify.
Verification of writes_singleton_p failed.
testcase(14,3) : error VC8507: Assertion 'p->x is writable' did not verify.
`
`/newsyntax
#include "vcc.h"

struct A {
int x;
};

struct A *get_a()
  _(ensures \mutable(\result))
  _(ensures \fresh(\result));

void foo()
{
  int x;
  struct A *a;

  while(x>0) {
    x--;
    a = get_a();
    a->x = 20;
  }
}

void foo2()
{
  int x;
  struct A *a;

  while(x>0) 
    _(writes {})
  {
    x--;
    a = get_a();
    a->x = 20;
  }
}
`
Verification of foo succeeded.
Verification of foo2 succeeded.
`
`/newsyntax
#include <vcc.h>

typedef unsigned int UINT32;

typedef union pte_t {
    struct {
        unsigned reserved_9_0:10;    /* bits [9:0] */
        unsigned p:1;    /* bit [10] */
        unsigned v:1;    /* bit [11] */
        unsigned ppx:20;    /* bits [31:12] */
    };            /* PTE fields */
    _(backing_member) 
        UINT32 uint32;    /* complete word */
} pte_t;


void test1(pte_t *arr)
{
    pte_t pte;
    UINT32 n;
    n = 0;
    
    while(n < 100)
      _(invariant \mutable(&pte.uint32))
//      writes(&pte.uint32)
    {
        pte.ppx = n;
        n++;
    }
}

void test2(pte_t *arr)
_(requires \mutable_array(arr, 100))
_(writes \array_range(arr, 100))
{
    pte_t pte;
    UINT32 n;
    n = 0;
    
    while(n < 100)
    _(invariant \mutable_array(arr, 100))
    _(writes \array_range(arr, 100))
      _(writes &pte.uint32)
    {
        pte.ppx = n;
        n++;
    }
}

void test3(pte_t *arr)
_(requires \mutable_array(arr, 100))
_(writes \array_range(arr, 100))
{
    UINT32 n;
    n = 0;
    while(n < 100)
    _(invariant \mutable_array(arr, 100))
    _(writes \array_range(arr, 100))
    {
        arr[n].uint32 = n;
        n++;
    }
}


void test4(UINT32 *arr)
_(requires \mutable_array(arr, 100))
_(writes \array_range(arr, 100))
{
    UINT32 n;
    n = 0;
    while(n < 100)
    _(invariant \mutable_array(arr, 100))
    _(writes \array_range(arr, 100))
    {
        arr[n] = n;
        n++;
    }
}
`
Verification of test1 succeeded.
Verification of test2 succeeded.
Verification of test3 succeeded.
Verification of test4 succeeded.
`
`/newsyntax
#include <vcc.h>
#include <stdlib.h>

_(claimable) struct S {
  volatile int c;
};

void foo(struct S **s) 
  _(writes s)
{
  struct S *a = (struct S *)malloc(sizeof(struct S) * 10);
  struct S *b = &a[0];
  if (a != NULL) {
    _(wrap b)
    free((void *)(void[10])a);
  }
}
`
Verification of foo failed.
testcase(15,5) : error VC8510: Assertion '\extent(p) is writable in call to free((void *)(void[10])a)' did not verify.
`
`/newsyntax
#include <vcc.h>

struct S {
  int x;
};

void bar(struct S *a, struct S *b)
  _(requires \thread_local(b))
  _(requires b->\valid)
  _(requires a != b)
  _(writes \extent(a))
{
  a->x = 1;
  a->x = b->x;
}

void foo(int *a, int *b)
    _(requires \thread_local(b))
    _(requires a != b)
    _(writes a)
{
    *a = 5;
    *a = *b;
}
`
Verification of bar succeeded.
Verification of foo succeeded.
`
`/newsyntax
#include <stdlib.h>
#include <vcc.h>

struct A { int x,y; };

struct B {
  struct A a1;
  struct A a2;
  int z;
};

void foo(struct B *b)
  _(requires \extent_mutable(b))
{
  _(assert \mutable(b))
  _(assert \mutable(&b->a1))
  _(assert \mutable(&b->a2))
}

struct B *alloc_B()
  _(ensures \result == NULL || (\extent_fresh(\result) && \extent_mutable(\result)))
{
  return (struct B*)malloc(sizeof(struct B));
}

void baz()
{
  struct B *b;

  b = alloc_B();
  if (b != NULL) {
    b->z = 12;
    b->a1.y = 12;
    b->a2.x = 12;
  }
}

struct C {
  struct A a[10];
};

struct C *alloc_C()
  _(ensures \result == NULL || (\extent_fresh(\result) && \extent_mutable(\result)))
{
  return (struct C*)malloc(sizeof(struct C));
}

void baz_C()
{
  struct C *b;

  b = alloc_C();
  if (b != NULL) b->a[1].x = 12;
}

void fail()
{
  struct B *b;
  _(assert \mutable(b) ==> \extent_mutable(b))
}


void ok()
{
  struct A *b;
  _(assert \mutable(b) ==> \extent_mutable(b))
}

void ok2(struct B *b)
  _(writes \extent(b))
{
  _(assert \extent_mutable(b))
}

`
Verification of foo succeeded.
Verification of alloc_B succeeded.
Verification of baz succeeded.
Verification of alloc_C succeeded.
Verification of baz_C succeeded.
Verification of fail failed.
testcase(59,26) : error VC9500: Assertion '\mutable(b) ==> \extent_mutable(b)' did not verify.
Verification of ok succeeded.
Verification of ok2 succeeded.
`
`/newsyntax
#include "vcc.h"


typedef struct s1{
    int dummy;
    _(ghost volatile bool b[int];)
    _(invariant \approves(\this->\owner, b))
} s1;

struct SX { int x; } ;

s1 S;

void f()
_(maintains \wrapped(&S))
;

void f2(struct SX *sx)
_(maintains \wrapped(&S))
_(writes sx)
;

void t1()
_(maintains \wrapped(&S))
_(requires \forall int i; (&S)->b[i])
{
    _(assert (\forall int i; (&S)->b[i]))
    
    f();  
    _(assert \forall int i; (&S)->b[i])
    //error VC9500: Assertion '__forall(int i; (&S)->b[i])' did not verify.
}

void okSX(struct SX *sx)
_(writes sx)
_(maintains \wrapped(&S))
_(requires \forall int i; (&S)->b[i])
{
    _(assert (\forall int i; (&S)->b[i]))
    f2(sx);  
    _(assert \forall int i; (&S)->b[i])
}

`
Verification of t1 succeeded.
Verification of okSX succeeded.
`