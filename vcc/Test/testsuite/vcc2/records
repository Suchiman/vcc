
#include <vcc2.h>

struct S {
  int a;
  int b;
};

void foo() {
  struct S s = { .a = 5, .b = 10 };
  assert(s.a == 5);
  assert(s.b == 10);
}
`
Verification of foo succeeded.
`
#include <vcc2.h>

struct S {
  int a;
  int b;
};

void foo() {
  struct S s = { .b = 10, .a = 5  };
  assert(s.a == 5);
  assert(s.b == 10);
}
`
Verification of foo succeeded.
`
#include <vcc2.h>

struct S {
  int a;
};

void foo() {
  spec(struct S s = { .b = 10, .a = 5  };)
  assert(s.a == 5);
}
`
testcase(8,35) : error VC0000: 'S' does not contain a definition for 'b'.
`


#include <vcc2.h>

struct S {
  int a;
  int b;
};

int foo(struct S s) 
  ensures(result == s.a + s.b);
  
void bar() {
  int x = foo( (struct S) { .a = 10, .b = 20 } );
  assert(x == 30);
}
`
Verification of bar succeeded.
`

#include <vcc2.h>

struct S {
  int a;
  int b;
};

int foo(struct S s) 
  ensures(result == s.a + s.b);
  
void bar() {
  struct S s = { .a = 10, .b = 20 };
  int x = foo( s / { .b = 5 });
  assert(x == 15);
}

`
Verification of bar succeeded.
`
#include <vcc2.h>

struct vcc(record) S {
  int a;
  int b;
};

spec(struct S foo(struct S s0) 
  ensures(result == s0 / { .a = 10 })
{
  return s0 / { .a = 10 };
}
)

void bar() {
  spec(struct S s = { 1, 2 };)
  speconly(s = foo(s);)
  assert(s.a == 10);
  assert(s.b == 2);
}

void baz(struct S s)
{
  assert(s.a <= 0x7fffffff);
}


spec(struct S foo2(int k, struct S s0) 
  ensures(result == (k ? s0 / { .a = 10 } : s0 / { .b = 10 }))
{
  if (k)
    return s0 / { .a = 10 };
  else
    return s0 / { .b = 10 };
}
)
`
Verification of foo succeeded.
Verification of bar succeeded.
Verification of baz succeeded.
Verification of foo2 succeeded.
`
#include <vcc2.h>

struct vcc(record) S {
  int a;
  int b;
};

spec(struct S foo(struct S s0) 
  ensures(result == s0 / { .a = 11 })
{
  return s0 / { .a = 10 };
}
)

void bar() {
  spec(struct S s = { 1, 2 };)
  speconly(s = foo(s);)
  assert(s.a == 10);
  assert(s.b == 2);
}

void baz(struct S s)
{
  assert(s.a <= 0x7ffffff0);
}


spec(struct S foo2(int k, struct S s0) 
  ensures(result == (k ? s0 / { .a = 10 } : s0 / { .b = 10 }))
{
  if (k)
    return s0 / { .a = 10 };
  else
    return s0 / { .a = 10 };
}
)
`
Verification of foo failed.
testcase(8,83) : error VC9501: Post condition 'result == s0 / { .a = 11 }' did not verify.
testcase(8,53) : error VC9599: (related information) Location of post condition.
Verification of bar failed.
testcase(18,12) : error VC9500: Assertion 's.a == 10' did not verify.
Verification of baz failed.
testcase(24,12) : error VC9500: Assertion 's.a <= 0x7ffffff0' did not verify.
Verification of foo2 failed.
testcase(28,153) : error VC9501: Post condition 'result == (k ? s0 / { .a = 10 } : s0 / { .b = 10 })' did not verify.
testcase(28,61) : error VC9599: (related information) Location of post condition.
`
#include <vcc2test.h>

struct A {
  int z;
};

spec(
struct vcc(record) S {
  int dummy;
  struct A *a;
  int b;
  obj_t o;
  int map[int];
};
)

spec(struct S foo(struct A *a, struct S s0) 
  ensures(result == s0 / { .a = a })
{
  return s0 / { .a = a };
}
)

void bar() {
  spec(struct S s = { 1 };)
  struct A a;

  assert(s.a == NULL);
  assert(s.b == 0);

  speconly(s = foo(&a, s);)
  assert(s.a == &a);
  assert(s.b == 0);

  speconly( s = s / { .o = &a }; )
  assert(s.o == &a);

  speconly( s.map = lambda(int x; true; x + 1); )
  assert(s.map[2] == 3);
}
`
Verification of foo succeeded.
Verification of bar succeeded.
`
#include <vcc2test.h>

spec(
struct vcc(record) S {
  int a;
  int b;
};
)

spec(
struct vcc(record) T {
  struct S s;
  int c;
};
)

void bar() {
  spec(struct T t;)

  speconly(
    t.c = 10;
    t.s.a = 20;
    t.s.b = 21;

    assert(t.c == 10);
    assert(t.s.a == 20);
    assert(t.s.b == 21);

    t = t / { .s = t.s / { .b = 30 } };
    t = t / { .c = 20 };

    assert(t.s.b == 30);
    assert(t.c == 20);
    assert(t.s.a == 20);
  )
}
`
Verification of bar succeeded.
`
#include "vcc2.h"

union vcc(record) S {
	struct {
		unsigned int b1 : 1;
		unsigned int b2 : 1;
		unsigned int b3 : 6;
		unsigned int b5 : 1;
		unsigned int b6 : 1;
		unsigned int b7 : 22;
	};
	backing_member unsigned int AsUINT;
};

spec(union S foo(union S s0)
  ensures(result == s0 / { .b1 = 1 })
{
  return s0 / { .b1 = 1 };
}

)

void bar() {
  spec(union S s;)
  speconly(s = (union S) { .b1 = 0, .b2 = 1, .b7 = 10 };)
  speconly(s = foo(s);)

  assert(s.b1 == 1);
  assert(s.b7 == 10);
  assert(s.b2 == 1);

}
`
Verification of foo succeeded.
Verification of bar succeeded.
`
#include <vcc.h>

typedef struct vcc(record) R
{
	int Register0;
	int Register1;
};

struct S {
	int data;
	int data2;
	
	spec(struct R rec;)

	invariant(rec.Register0 == data && rec.Register1 == data2)
};


void foo(struct S *s) 
  maintains(wrapped(s))
  writes(s)
{
  assert(s->data == s->rec.Register0);
  assert(s->data2 == s->rec.Register1);
  expose(s) {
    int tmp = s->data;
    s->data = s->data2;
    s->data2 = tmp;
    s->rec = s->rec / { .Register0 = s->rec.Register1, .Register1 = s->rec.Register0 };
  }
}
`
Verification of S#adm succeeded.
Verification of foo succeeded.
`
#include "vcc2.h"
typedef unsigned __int64 uint64;
typedef unsigned int uint;

spec (
    typedef struct vcc(record) Core{
        uint64 RIP;
        uint64 R[uint];
    } Core;
)

#define let(x, X, y, f) exists (X x; x == (y) && (f))

spec (
ispure bool mov_reg_excp(uint regidx, uint64 data, Core c)
    returns (regidx >= 8);
)

spec (
ispure Core mov_reg(uint regidx, uint64 data, Core c)
    requires (!mov_reg_excp(regidx, data, c))
    ensures
    (
        let (c1, Core, c / {.R = lambda(uint i; i < 8 ; i == regidx ? data : c.R[i])},
        result == c1)
    )
;
)

spec (
void test_mov_reg()
{
    Core c;
    c = mov_reg(1, 16, c);
    assert(c.R[1] == 16);
}
)
`
Verification of test_mov_reg succeeded.
`