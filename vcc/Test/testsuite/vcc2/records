
#include <vcc.h>

struct S {
  int a;
  int b;
};

void foo() {
  struct S s = { .a = 5, .b = 10 };
  assert(s.a == 5);
  assert(s.b == 10);
}
`
Verification of foo succeeded.
`
#include <vcc.h>

struct S {
  int a;
  int b;
};

void foo() {
  struct S s = { .b = 10, .a = 5  };
  assert(s.a == 5);
  assert(s.b == 10);
}
`
Verification of foo succeeded.
`
#include <vcc.h>

struct S {
  int a;
};

void foo() {
  spec(struct S s = { .b = 10, .a = 5  };)
  assert(s.a == 5);
}
`
testcase(8,35) : error VC0000: 'S' does not contain a definition for 'b'.
`


#include <vcc.h>

struct S {
  int a;
  int b;
};

int foo(struct S s) 
  ensures(result == s.a + s.b);
  
void bar() {
  int x = foo( (struct S) { .a = 10, .b = 20 } );
  assert(x == 30);
}
`
Verification of bar succeeded.
`

#include <vcc.h>

struct S {
  int a;
  int b;
};

int foo(struct S s) 
  ensures(result == s.a + s.b);
  
void bar() {
  struct S s = { .a = 10, .b = 20 };
  int x = foo( s / { .b = 5 });
  assert(x == 15);
}

`
Verification of bar succeeded.
`
#include <vcc.h>

struct vcc(record) S {
  int a;
  int b;
};

spec(struct S foo(struct S s0) 
  ensures(result == s0 / { .a = 10 })
{
  return s0 / { .a = 10 };
}
)

void bar() {
  spec(struct S s = { 1, 2 };)
  speconly(s = foo(s);)
  assert(s.a == 10);
  assert(s.b == 2);
}

void baz(struct S s)
{
  assert(s.a <= 0x7fffffff);
}


spec(struct S foo2(int k, struct S s0) 
  ensures(result == (k ? s0 / { .a = 10 } : s0 / { .b = 10 }))
{
  if (k)
    return s0 / { .a = 10 };
  else
    return s0 / { .b = 10 };
}
)
`
Verification of foo succeeded.
Verification of bar succeeded.
Verification of baz succeeded.
Verification of foo2 succeeded.
`
#include <vcc.h>

struct vcc(record) S {
  int a;
  int b;
};

spec(struct S foo(struct S s0) 
  ensures(result == s0 / { .a = 11 })
{
  return s0 / { .a = 10 };
}
)

void bar() {
  spec(struct S s = { 1, 2 };)
  speconly(s = foo(s);)
  assert(s.a == 10);
  assert(s.b == 2);
}

void baz(struct S s)
{
  assert(s.a <= 0x7ffffff0);
}


spec(struct S foo2(int k, struct S s0) 
  ensures(result == (k ? s0 / { .a = 10 } : s0 / { .b = 10 }))
{
  if (k)
    return s0 / { .a = 10 };
  else
    return s0 / { .a = 10 };
}
)
`
Verification of foo failed.
testcase(11,3) : error VC9501: Post condition 'result == s0 / { .a = 11 }' did not verify.
testcase(9,13) : error VC9599: (related information) Location of post condition.
Verification of bar failed.
testcase(18,12) : error VC9500: Assertion 's.a == 10' did not verify.
Verification of baz failed.
testcase(24,12) : error VC9500: Assertion 's.a <= 0x7ffffff0' did not verify.
Verification of foo2 failed.
testcase(34,5) : error VC9501: Post condition 'result == (k ? s0 / { .a = 10 } : s0 / { .b = 10 })' did not verify.
testcase(29,13) : error VC9599: (related information) Location of post condition.
`
#include <vcc2test.h>

struct A {
  int z;
};

spec(
struct vcc(record) S {
  int dummy;
  struct A *a;
  int b;
  obj_t o;
  int map[int];
};
)

spec(struct S foo(struct A *a, struct S s0) 
  ensures(result == s0 / { .a = a })
{
  return s0 / { .a = a };
}
)

void bar() {
  spec(struct S s = { .dummy = 1 };)
  struct A a;

  assert(s.a == NULL);
  assert(s.b == 0);

  speconly(s = foo(&a, s);)
  assert(s.a == &a);
  assert(s.b == 0);

  speconly( s = s / { .o = &a }; )
  assert(s.o == &a);

  speconly( s.map = lambda(int x; true; x + 1); )
  assert(s.map[2] == 3);
}
`
Verification of foo succeeded.
Verification of bar succeeded.
`
#include <vcc2test.h>

spec(
struct vcc(record) S {
  int a;
  int b;
};
)

spec(
struct vcc(record) T {
  struct S s;
  int c;
};
)

void bar() {
  spec(struct T t;)

  speconly(
    t.c = 10;
    t.s.a = 20;
    t.s.b = 21;

    assert(t.c == 10);
    assert(t.s.a == 20);
    assert(t.s.b == 21);

    t = t / { .s = t.s / { .b = 30 } };
    t = t / { .c = 20 };

    assert(t.s.b == 30);
    assert(t.c == 20);
    assert(t.s.a == 20);
  )
}
`
Verification of bar succeeded.
`
#include "vcc.h"

union vcc(record) S {
	struct {
		unsigned int b1 : 1;
		unsigned int b2 : 1;
		unsigned int b3 : 6;
		unsigned int b5 : 1;
		unsigned int b6 : 1;
		unsigned int b7 : 22;
	};
	backing_member unsigned int AsUINT;
};

spec(union S foo(union S s0)
  ensures(result == s0 / { .b1 = 1 })
{
  return s0 / { .b1 = 1 };
}

)

void bar() {
  spec(union S s;)
  speconly(s = (union S) { .b1 = 0, .b2 = 1, .b7 = 10 };)
  speconly(s = foo(s);)

  assert(s.b1 == 1);
  assert(s.b7 == 10);
  assert(s.b2 == 1);

}
`
Verification of foo succeeded.
Verification of bar succeeded.
`
#include <vcc.h>

typedef struct vcc(record) R
{
	int Register0;
	int Register1;
};

struct S {
	int data;
	int data2;
	
	spec(struct R rec;)

	invariant(rec.Register0 == data && rec.Register1 == data2)
};


void foo(struct S *s) 
  maintains(wrapped(s))
  writes(s)
{
  assert(s->data == s->rec.Register0);
  assert(s->data2 == s->rec.Register1);
  expose(s) {
    int tmp = s->data;
    s->data = s->data2;
    s->data2 = tmp;
    s->rec = s->rec / { .Register0 = s->rec.Register1, .Register1 = s->rec.Register0 };
  }
}
`
Verification of S#adm succeeded.
Verification of foo succeeded.
`
#include "vcc.h"
typedef unsigned __int64 uint64;
typedef unsigned int uint;

spec (
    typedef struct vcc(record) Core{
        uint64 RIP;
        uint64 R[uint];
    } Core;
)

#define let(x, X, y, f) exists (X x; x == (y) && (f))

spec (
ispure bool mov_reg_excp(uint regidx, uint64 data, Core c)
    returns (regidx >= 8);
)

spec (
ispure Core mov_reg(uint regidx, uint64 data, Core c)
    requires (!mov_reg_excp(regidx, data, c))
    ensures
    (
        let (c1, Core, c / {.R = lambda(uint i; i < 8 ; i == regidx ? data : c.R[i])},
        result == c1)
    )
;
)

spec (
void test_mov_reg()
{
    Core c;
    c = mov_reg(1, 16, c);
    assert(c.R[1] == 16);
}
)
`
Verification of test_mov_reg succeeded.
`
#include <vcc.h>

struct vcc(record) S {
  int a;
  int b;
};

spec(
ispure
int foo(struct S s) 
  ensures(result == unchecked(s.a + s.b))
{
  return unchecked(s.a + s.b);
}
)

spec(ispure
int bar(int a, int b)
  ensures(result == unchecked(a+b))
{
  struct S s = {a,b};
  return foo(s);
}
)
`
Verification of foo succeeded.
Verification of bar succeeded.
`
#include "vcc.h"

typedef struct vcc(record) State {
    int x;
} State;

typedef struct vcc(claimable) Container {
    spec (volatile State s;)
    volatile int a;
} Container;

void test(Container *c spec(claim_t claim))
    requires (wrapped(claim))
    requires (valid_claim(claim))
    requires (claims (claim, closed(c)))
{
    atomic(c, claim)
        writes(c)
    {
        c->a = 0;
        speconly(
            c->s = c->s / {.x = 1};
        )
    }
}
`
Verification of test succeeded.
`
#include <vcc2.h>

struct vcc(record) R
{
	int x;
};

struct S
{
	volatile struct R r;

	invariant(approves(owner(this),r))
};


void test(struct S *s)
maintains(wrapped(s))
writes(s)
{
	atomic(s)
	{
		bump_volatile_version(s);
		s->r.x = 2;
	}
}
`
Verification of test succeeded.
`
#include "vcc.h"

struct vcc(record) Y {
  unsigned state;
};

struct vcc(record) Z {
  int dummy;
  spec(struct Y X;)
  invariant(X.state==0)
};
`
testcase(7,1) : error VC9698: type 'Z' is marked as a record type and thus must not declare invariants
testcase(10,15)-(10,25) : (Location of symbol related to previous error.)
`
#include "vcc.h"

struct vcc(record) X {
    bool Y[unsigned];   
}; 

void foo() {
  struct X x;
  x.Y[5] = false;
  assert(x.Y[5] == false);
}
`
Verification of foo succeeded.
`#include <vcc.h>

struct vcc(record) R
{
	int x;
};

struct Rc
{
  int a;
	spec(struct R r;)
};

void test(struct Rc *s)
  writes(s)
  maintains(wrapped(s))
  ensures(unchanged(s->r))
{
  expose(s) {
    speconly(s->r = s->r / {.x = s->r.x };)
	}
}
`
Verification of test succeeded.
`
#include <vcc.h>

struct vcc(record) S {
  int a;
};

struct vcc(record) T {
  struct S s;
};

void foo(spec(struct T t)) {
  spec(struct T s;)
  speconly(s = t / { .s = t.s / { .a = 5 } };)
  assert(s == t / { .s = t.s / { .a = 5 } });
}
`
Verification of foo succeeded.
`
#include <vcc.h>

struct vcc(record) S {
  int a;
  int b;
};


struct vcc(record) T {
  struct S s;
  struct S s1;
  int c;
};

spec(ispure struct T foo()
  ensures(result == (struct T) { .s = { .a = 10, .b = 20 }, .c = 20, .s1 = {2, 4}}) {
  return (struct T) { .s = { .a = 10, .b = 20 }, .c = 20, .s1 = { 2, 4 } };
}
)
`
Verification of foo succeeded.
`
#include "vcc.h"

struct vcc(record) X {
  int a:10;
  int b:22;
}; 

void foo() {
  struct X x;
  x.a = 5;
  assert(x.a == 5);
} 
`
Verification of foo succeeded.
`
#include "vcc.h"

struct vcc(record) S {
    int a;
    int b;
};

void foo() {
    spec(struct S wa = {.a = 5, .b = 10};)
    speconly(wa /= { .a = 3 };)
    assert(wa.a == 3 && wa.b == 10);
}

`
Verification of foo succeeded.
`

#include <vcc.h>

struct T {
  int a;
};

struct vcc(record) R {
  int a;
};

spec (typedef int M[int];)

struct vcc(record) S {
  int a;
  spec(mathint m0[int];)  
  spec(bool m1[int];)
  spec(int m2[int];)
  spec(void *m3[int];)
  spec(struct T m4[int];)
  spec(struct R m5[int];)
  spec(M m6[int];)
  spec(int m7[int][int];)
  spec(ptrset m8[int];)
};

void foo() {
  struct S a;
  assert(a.m0[0] == 0);
  assert(!a.m1[0]);
  assert(a.m2[0] == 0);
  assert(a.m3[0] == (void *)0);
  assert(a.m4[0].a == 0);
  assert(a.m5[0].a == 0); 
  assert(a.m6[0][0] == 0);
  assert(a.m7[0][0] == 0);
  assert(set_eq(a.m8[0], set_empty()));
}
`
Verification of foo succeeded.
`
#include "vcc.h"

spec(typedef struct vcc(record) R {
    int x;
} R;)

spec(typedef struct vcc(record) S {
  int y;
} S;)

spec(void foo(R abs, S conc)
{
    assert(abs==abs.x);
    assert(abs == conc);
})
`
testcase(13,14) : error VC0000: Operator '==' cannot be applied to operands of type 'R' and '__int32'.
testcase(14,14) : error VC0000: Operator '==' cannot be applied to operands of type 'R' and 'S'.
`
#include "vcc.h"

spec(typedef struct vcc(record) R {
    int x[int];
} R;)

spec(void foo(R abs)
{
    assert(abs==abs.x);
})
`
testcase(9,14) : error VC0000: Operator '==' cannot be applied to operands of type 'R' and 'System.Diagnostics.Contracts.CodeContract.Map<int, int>'.
`#include "vcc.h"

spec(typedef bool M[bool];)

spec(typedef struct vcc(record) R {
    M m;
} R;)

spec(R foo(R r)
  returns(r / { .m = lambda(bool j; true; true)})
{
  return r / { .m = lambda(bool j; true; true)};
};)
`
Verification of foo succeeded.
`
#include "vcc.h"

spec(typedef unsigned map_t[unsigned];)

spec(ispure map_t upd(map_t m,unsigned y)
    returns(lambda(unsigned x; true; x==y ? 0 : m[x]));)

spec(ispure map_t abs(unsigned *m, unsigned z)
    reads(set_universe())
    returns(lambda(unsigned x; true; x < z ? m[x] : 0));)

void trg(unsigned *m, unsigned z)
    requires(z)
    requires(typed(as_array(m,z)))
    writes(m+0)
{
    m[0] = 0;
    assert(abs(m,z)==upd(old(abs(m,z)),0));
}

spec(typedef struct vcc(record) x { map_t m; } rec_t;)

spec(ispure rec_t rec_upd(rec_t r,unsigned y)
    returns(r / { .m = lambda(unsigned x; true; x==y ? 0 : r.m[x]) });)

spec(ispure rec_t rec_abs(unsigned *m, unsigned z)
    reads(set_universe())
    returns((rec_t) { .m = lambda(unsigned x; true; x < z ? m[x] : 0) });)

void trg2(unsigned *m, unsigned z)
    requires(z)
    requires(typed(as_array(m,z)))
    writes(m+0)
{
    m[0] = 0;
    //assert(rec_abs(m,z).m==rec_upd(old(rec_abs(m,z)),0).m);
    assert(rec_abs(m,z)==rec_upd(old(rec_abs(m,z)),0));
}
`
Verification of trg succeeded.
Verification of trg2 succeeded.
`
