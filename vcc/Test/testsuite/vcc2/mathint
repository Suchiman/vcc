#include "vcc2.h"

void foo() {
  spec(mathint a = 10;)
  spec(mathint b = a - 5;)
  assert(a + b == 15);
}

void foo1() {
  spec(mathint a = 10;)
  spec(mathint b = a / 5;)
  assert(a * b == 20);
}

void foo2(spec(mathint i)) {
  spec(mathint a = 10;)
  spec(mathint b = a / i;)
}

void foo3(spec(mathint i)) {
  spec(mathint a = 10;)
  spec(mathint b = a % i;)
}

void foo4(spec(mathint i)) 
  requires(i != 0)
{
  spec(mathint a = 10;)
  spec(mathint b = a / i;)
}

void foo5(unsigned long a, unsigned long b) {
  spec(mathint sum = ((mathint)a + (mathint)b);)
  assert(sum >= 0);
  spec(unsigned long j = (unsigned long)sum;)
}

void foo5_1(unsigned long a, unsigned long b) {
  spec(mathint sum = a + b;)
  assert(sum >= 0);
  spec(unsigned long j = (unsigned long)sum;)
}

void foo6(unsigned long a, unsigned long b) 
  requires(a < 1000 && b < 2000)
{
  spec(mathint sum = ((mathint)a + (mathint)b);)
  assert(sum >= 0);
  spec(unsigned long j = (unsigned long)sum;)
}

struct S {
  unsigned __int64 a;
  unsigned __int64 b;
  spec(mathint c;)
  invariant(c == (mathint)a + (mathint)b)
};


void bar(struct S *s)
  writes(s)
  maintains(wrapped(s))
{
  expose(s) {
    if (s->a < 20000) { s->a++; speconly(s->c = s->c+1;) }
    if (s->b < 20000) { s->b++; speconly(s->c = s->c+1;) }
  }
}

`
Verification of S#adm succeeded.
Verification of foo succeeded.
Verification of foo1 succeeded.
Verification of foo2 failed.
testcase(17,42) : error VC8519: Assertion 'i != 0 (in division by zero)' did not verify.
Verification of foo3 failed.
testcase(22,42) : error VC8519: Assertion 'i != 0 (in division by zero)' did not verify.
Verification of foo4 succeeded.
Verification of foo5 failed.
testcase(35,52) : error VC8518: Assertion 'sum fits range of uint32_t' did not verify.
Verification of foo5_1 failed.
testcase(39,40) : error VC8004: a + b might overflow.
Verification of foo6 succeeded.
Verification of bar succeeded.
`
#include <vcc.h>
spec(
mathint plus(mathint x, mathint y)
  requires(x>=0 && y>=0)
  ensures(result == x + y)
{
  spec(mathint z = x+y;)
  while (x>0)
    invariant(y == z - x)
    invariant(x >= 0)
    {
      x-= 1;
      y+= 1;
    }
  return y;
}
) 
`
Verification of plus succeeded.
`
#include <vcc.h>
spec(ispure mathint mod(mathint a, mathint b) ensures(result == 12); )
void foo()
{
assert(forall(unsigned a, b; mod(a + b, b) == 12));
}
`
Verification of foo succeeded.
`