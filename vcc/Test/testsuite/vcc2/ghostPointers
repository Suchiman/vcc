
void foo() {
  int i, ^p;
  p = &i;
}
`
testcase(4,7) : error VC0000: Cannot implicitly convert type 'int*' to 'int^'.
`

void foo() {
  int i, ^p;
  p = (int ^)&i;
}
`
testcase(4,7) : error VC0000: Cannot convert type 'int*' to 'int^'.
`
void foo(int ^p) {
  int *q = p;
}
`
testcase(2,12) : error VC0000: Cannot implicitly convert type 'int^' to 'int*'.
`
void foo(int ^p) {
  int *q = (int *)p;
}
`
testcase(2,12) : error VC0000: Cannot convert type 'int^' to 'int*'.
`
void foo(int ^p) {
  void *q = p;
}
`
testcase(2,13) : error VC0000: Cannot implicitly convert type 'int^' to 'void*'.
`
void foo(void ^p) {
  void *q = p;
}
`
testcase(2,13) : error VC0000: Cannot implicitly convert type 'void^' to 'void*'.
`
void foo(int *p) {
  void ^q = p;
}
`
testcase(2,13) : error VC0000: Cannot implicitly convert type 'int*' to 'void^'.
`
#include <vcc.h>

struct S {
  int a;
  spec(int b;)
};

void foo() {
  spec(int i;)
  spec(int ^p;)
  p = &i;
}

void bar(struct S *s) {
  spec(int ^p;)
  p = &s->b;
}

void baz(struct S ^s) {
  spec(int ^p;)
  p = &s->a;
}
`
Verification of foo succeeded.
Verification of bar succeeded.
Verification of baz succeeded.
`
#include <vcc.h>

struct S {
  int a;
  spec(int b;)
};

struct T {
  struct S s;
  spec(struct S r;)
};

void foo(struct T *p) {
  spec(int ^i1 = &(p->s.b);)
  spec(int ^i1 = &(p->r.a);)
}

void bar(struct T ^p) {
  spec(int ^i1 = &(p->s.a);)
}
`
Verification of foo succeeded.
Verification of bar succeeded.
`
#include <vcc.h>

struct S {
  int a;
  spec(int b;)
};

struct T {
  struct S s;
  spec(struct S r;)
};

void foo(struct T *p) {
  spec(int *i1 = &(p->s.b);)
  spec(int *i1 = &(p->r.a);)
}

void bar(struct T ^p) {
  spec(int *i1 = &(p->s.a);)
}
`
testcase(14,29) : error VC0000: Cannot implicitly convert type 'int^' to 'int*'.
testcase(15,29) : error VC0000: Cannot implicitly convert type 'int^' to 'int*'.
testcase(19,29) : error VC0000: Cannot implicitly convert type 'int^' to 'int*'.
`

#include <vcc.h>

struct S {
  int a;
  spec(int b;)
  spec(int ^p;)
  invariant(p != &b)
};

struct T {
  int a;
  spec(int b;)
  spec(int ^p;)
  invariant(p == &b)
};
`
Verification of S#adm succeeded.
Verification of T#adm succeeded.
`

#include "vcc2.h"

typedef struct _LTH_THREAD
{
	int dummy;
} LTH_THREAD, *PLTH_THREAD;


typedef struct _LCPU_PLS
{
	PLTH_THREAD volatile SchDeferredList;
  invariant(SchDeferredList == (void *)0)
} LCPU_PLS, *PLCPU_PLS;

`
Verification of _LCPU_PLS#adm succeeded.
`
#include "vcc.h"

struct S {
    int dummy;
    def_group(a)
    in_group(a) int b;
};

struct T {
    int dummy;
    spec(struct S ^s;)
    invariant(keeps(s))
    invariant(keeps(s::a))
};
`
Verification of T#adm succeeded.
`
#include "vcc.h"
spec(struct S {
    int a;
    spec(struct S ^s;)
    invariant(s==this)
};)
`
Verification of S#adm succeeded.
`
int foo()
{
  int ^a = (void *)0;
}
`
Verification of foo succeeded.
`
int foo()
{
  int ^a;
  if (a == (void *)0) { 
  }
  
  if (a != (void *)0) { 
  }
}
`
Verification of foo succeeded.
`
#include "vcc.h"

spec(struct S { int a; };)

void foo() {
    spec(struct S s1, s2;)
    assume(deep_eq(s1,s2));
    assume(shallow_eq(s1,s2));
    assert(deep_eq(s1,s2));
}
`
Verification of foo succeeded.
`