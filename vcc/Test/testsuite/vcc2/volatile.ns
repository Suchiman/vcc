`/newsyntax
#include "vcc.h"

typedef struct _s {
  int dummy;
  _(invariant dummy==5)
} s, *ps;

struct t {
  int dummy2;
  volatile s x;
  _(invariant dummy2==5)
};

`
Verification of _s#adm succeeded.
Verification of t#adm succeeded.
Verification of volatile#_s#adm succeeded.
`
`/newsyntax
typedef __int32 INT32;
typedef INT32 volatile VINT32;

#include "vcc.h"

typedef struct _A {

VINT32 a;
INT32 volatile b;

} A, *PA;


void foo(PA inp)
_(requires \wrapped(inp))
{
	_(atomic inp){
		inp->a = 0;
  }
  _(atomic inp) {
		inp->b = 0;
	}
}

`
Verification of foo succeeded.
`
`/newsyntax
#include <vcc.h>

typedef struct Goo {
      volatile int f[10];
      _(invariant f[0] == \old(f[0]))
} Goo;

void foo(Goo *g _(ghost \claim c))
  _(always c, g->\consistent)
{
  _(atomic c, g) {
    g->f[1] = 1;
  }
}

void fooShouldFail(Goo *g _(ghost \claim c))
  _(always c, g->\consistent)
{
  _(atomic c, g) {
    g->f[0] = 1;
  }
}
`
Verification of Goo#adm succeeded.
Verification of foo succeeded.
Verification of fooShouldFail failed.
testcase(19,29) : error VC8524: Assertion 'chunk f[0] == \old(f[0]) of invariant of g holds after atomic' did not verify.
`
`/newsyntax
#include <vcc.h>
#include <limits.h>
typedef unsigned int UINT;

typedef _(claimable) struct Client {
	volatile bool flag;					// true when choosing a ticket
	_(ghost \object bakery;)					// the bakery this client is in
	_(invariant \on_unwrap(\this, \inv(bakery)))				// don't destroy the client while the bakery is running
	_(invariant \approves(\this->\owner,flag))
	_(invariant \approves(bakery,flag))	// changes to the fields require checking the bakery invariants
} Client;

typedef _(claimable) _(dynamic_owns) struct Bakery {
	UINT N;						// number of clients
	Client *c;					// pointer to array of clients
	_(invariant \forall UINT i; i<N ==> (&c[i])->\consistent  && (&c[i])->\valid && (c[i].bakery==\this))
} Bakery;

#define cl (&server->c[idx])	// defined rather than declared as a local so we can use it in the contract (replace with let someday)

void BakeryAcquire(Bakery *server, UINT idx _(ghost \claim sc))
_(requires \wrapped(sc) && \claims(sc,server->\consistent))  // need evidence that nobody will destroy the server
_(requires idx < server->N && \wrapped(cl))			// must own a client of the server
_(writes cl)
{	
	_(atomic sc,server,cl) {
		cl->flag = 1;
		_(bump_volatile_version cl)
	}
}
`
Verification of Client#adm succeeded.
Verification of Bakery#adm succeeded.
Verification of BakeryAcquire succeeded.
`