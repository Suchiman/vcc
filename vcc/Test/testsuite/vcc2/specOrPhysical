#include "vcc.h"

typedef unsigned __int64 uint64_t;

void foo() {
    uint64_t a, *b;
    a = (uint64_t) b;
    assert(a >= 0);
}
`
Verification of foo succeeded.
`
#include "vcc.h"

struct S {
  int a;
  spec(int b;)
};

void foo() {
  struct S s;
  struct S *p = &s;
  assert(typed_phys(p));
  assert(typed_phys(&p->a));
  assert(typed_spec(&p->b));
}
`
Verification of foo succeeded.
`
#include "vcc.h"

struct S {
  int a;
  spec(int b;)
};

void foo(struct S *p) 
  requires(wrapped(p))
{
  assert(typed(p));
  assert(typed_phys(p));
}

spec (
void bar(struct S ^p) 
  requires(wrapped(p))
{
  assert(typed(p));
  assert(typed_spec(p));
}
)
`
Verification of foo succeeded.
Verification of bar succeeded.
`
#include "vcc2test.h"
void foo()
{
  spec(char *xyz[char*];)
  spec(int foo[int*];)
  char arr[10];
  int x = 20;
  char *p = (char *)malloc(10);
  assume(p != NULL);
  spec(xyz = lambda(char *c; c != 0; c + 1);)
  assert(typed(&arr));
  assert(typed(&arr[1]));
  assert(typed_phys(&arr));
  assert(typed_phys(&arr[1]));
  assert(typed(&p));
  assert(typed(&p[1]));
  assert(typed_phys(&p));
  assert(typed_phys(&p[9]));
}
`
Verification of foo succeeded.
`
#include <vcc.h>

struct S {
  int a;
};

struct T {
  struct S *p;
  spec(struct S ^q;)
  invariant(keeps(p,q))
};

void foo(struct T *t) 
  writes(t)
  maintains(wrapped(t))
{
  expose(t) {
    assert(typed(t->p));
    assert(typed_phys(t->p));
    assert(typed(t->q));
    assert(typed_spec(t->q));
  }
}
`
Verification of T#adm succeeded.
Verification of foo succeeded.
`#include <vcc.h>

struct A {
  int x;
};

struct B {
  int dummy;
  spec( struct A ^a; )

  invariant(typed_spec(this) && a->x == 12)
};


void foo()
{
spec( struct B ^b; )
spec(
  b = spec_malloc<struct B>();
  b->a = spec_malloc<struct A>();
  b->a->x = 12;
  wrap(b);
)
}

struct B2 {
  int dummy;
  spec( struct A ^a; )

  invariant(typed_spec(this) && a->x == 12)
};

isadmissibilitycheck
void adm_B2(struct B2* x)
{
  havoc_others(x);
}
`
Verification of B#adm failed.
testcase(11,43) : error VC8012: invariant(a->x == 12) of B is not admissible.
Verification of B2#adm succeeded.
Verification of foo succeeded.
Verification of adm_B2 failed.
testcase(37,1) : error VC8012: invariant(a->x == 12) of B2 is not admissible.
`
#include <vcc.h>

struct vcc(claimable) S {
  int a;
};

void foo(struct S *s)
  writes(extent(s))
{
  claimp(c;)
  wrap(s);
  spec(c = claim(s, true);)
  assert(typed_spec(c));
}
`
Verification of foo succeeded.
`
#include <vcc.h>

struct S {
  int a;
};

spec(
void foo(spec(out struct S ^p))
  ensures(wrapped(p))
{
  struct S ^result = spec_malloc<struct S>();
  wrap(result);
  p = result;
}
)

spec(
struct S ^foo1()
  ensures(wrapped(result))
{
  struct S ^result = spec_malloc<struct S>();
  wrap(result);
  return result;
}
)

spec(
void bar() {
  struct S ^x;
  foo(spec(out x));
  assert(wrapped(x));
  assert(typed(x));
  assert(typed_spec(x));
}
)

spec(
void bar1() {
  struct S ^x;
  x = foo1();
  assert(wrapped(x));
  assert(typed(x));
  assert(typed_spec(x));
}
)
`
Verification of foo succeeded.
Verification of foo1 succeeded.
Verification of bar succeeded.
Verification of bar1 succeeded.
`#include "vcc.h"

struct S {
    int a;
    int b;
};

void foo(struct S *s)
    requires(wrapped(s))
{
    assert(typed(&s->b) && typed_phys(&s->b));
}

`
Verification of foo succeeded.
`
#include <vcc2.h>

struct S {
  int a;
};

void bar(struct S *p) 
  requires(typed(p))
  ensures(typed_phys(p))
{
  assert(typed_phys(p));
}

void foo(obj_t o) 
  requires(wrapped(o))
  requires(is(o, struct S))
  ensures(typed_phys(o))
{
  struct S *p;
  assert(typed(o));
  p = (struct S *)o;
  bar(p); 
}
`
Verification of bar succeeded.
Verification of foo failed.
testcase(21,19) : error VC8535: Assertion 'o is in physical pointer range (in cast)' did not verify.
`

#include <vcc.h>

struct S {
  int a;
  vcc(as_array) int c[5];
};

struct T {
  int a;
  int c[5];
};

void foo(struct S *s)
  requires(wrapped(s))
{
  assert(typed(s));
  assert(typed_phys(s));
  assert(typed_phys(&s->a));
  assert(typed_phys(&s->c[4]));
}

void bar(struct T *s)
  requires(wrapped(s))
{
  assert(typed(s));
  assert(typed_phys(s));
  assert(typed_phys(&s->a));
  assert(typed_phys(&s->c[4]));
}
`
Verification of foo succeeded.
Verification of bar succeeded.
`
#include <vcc.h>

void foo() {
  spec(int a[5];)
  spec(int ^p = &a[0];)
  assert(typed_spec(p));
} 
`
Verification of foo succeeded.
`
#include<vcc.h>

typedef struct  c{
int b;
}c;

typedef struct vcc(dynamic_owns) d{
    c *cc;
    spec(
        c arr[3];
        )
    c iarr[3];
    invariant(keeps(cc))
}d;

void foo(d *dd)
requires(wrapped(dd))
writes(dd)
requires(forall(int i; i >= 0 && i < 3; set_in(&dd->arr[i], owns(dd))))
requires(forall(int i; i >= 0 && i < 3; set_in(&dd->iarr[i], owns(dd))))
{
    unwrap(dd);
    
    set_owns(dd, set_difference(owns(dd),array_members(dd->iarr, 3)));
    set_owns(dd, set_difference(owns(dd),array_members(dd->arr, 3)));
}
`
Verification of d#adm succeeded.
Verification of foo succeeded.
`
