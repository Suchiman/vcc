#include <vcc2.h>

struct VS {
  volatile int x;
  volatile int y;
  spec(volatile obj_t yappr;)
  volatile int z;
  spec(obj_t zappr;)
  volatile int w;
  int nv;

  invariant(approves(owner(this), x))
  invariant(approves(yappr, y))
  invariant(approves(yappr, yappr))
  invariant(approves(zappr, z))
};

struct Q {
  struct VS vs;

  invariant(keeps(&vs))
  invariant(vs.x == 12)
  invariant(vs.y == 12)
  invariant(vs.yappr == this)
  invariant(vs.z == 12)
  invariant(vs.nv == 12)
  invariant(vs.zappr == this)
};

struct Qfail1 {
  struct VS vs;

  invariant(keeps(&vs))
  invariant(vs.w == 12)
};

struct Qfail2 {
  struct VS vs;

  invariant(keeps(&vs))
  invariant(vs.y == 12)
};

struct Qfail3 {
  struct VS vs;

  invariant(vs.x == 12)
};

void foo1(struct VS *vs)
  requires(wrapped(vs))
{
  atomic(vs) {
    vs->w = 10;
  }
}

void foo2(struct VS *vs)
  requires(wrapped(vs))
  writes(vs)
{
  atomic(vs) {
    vs->x = 10;
    bump_volatile_version(vs);
  }
}

void foo2fail1(struct VS *vs)
  requires(wrapped(vs))
  writes(vs)
{
  atomic(vs) {
    vs->x = 10;
  }
}

void foo2fail2(struct VS *vs)
  requires(wrapped(vs))
{
  atomic(vs) {
    vs->x = 10;
    bump_volatile_version(vs);
  }
}
`
Verification of VS#adm succeeded.
Verification of Q#adm succeeded.
Verification of Qfail1#adm failed.
testcase(34,15) : error VC8012: invariant(vs.w == 12) of Qfail1 is not admissible.
Verification of Qfail2#adm failed.
testcase(41,15) : error VC8012: invariant(vs.y == 12) of Qfail2 is not admissible.
Verification of Qfail3#adm failed.
testcase(47,15) : error VC8012: invariant(vs.x == 12) of Qfail3 is not admissible.
Verification of foo1 succeeded.
Verification of foo2 succeeded.
Verification of foo2fail1 failed.
testcase(72,21) : error VC8524: Assertion 'chunk _vcc_approves(_vcc_owner(__this), x) of invariant of vs holds after atomic' did not verify.
Verification of foo2fail2 failed.
testcase(82,5) : error VC8510: Assertion 'vs is writable in call to _vcc_bump_volatile_version(vs)' did not verify.
`
#include <vcc2.h>

struct VS {
  volatile int x;
  volatile int y;
  spec(volatile obj_t yappr;)
  volatile int z;
  spec(obj_t zappr;)
  volatile int w;
  int nv;

  invariant(approves(owner(this), x))
  invariant(approves(yappr, y))
  invariant(approves(yappr, yappr))
  invariant(approves(zappr, z))
};

struct A { int x; }; 

void writeVS(struct VS *vs)
  maintains(wrapped(vs))
  writes(vs);

void writeA(struct A *a)
  maintains(wrapped(a))
  writes(a);

void foo1(struct VS *vs)
  requires(wrapped(vs))
  requires(vs->x == 10)
{
  struct A a;
  wrap(&a);
  writeA(&a);
  assert(skip_wf(vs->x == 10));
}

void foo2(struct VS *vs)
  requires(wrapped(vs))
  requires(vs->y == 10)
  requires(vs->yappr == me())
{
  struct A a;
  wrap(&a);
  writeA(&a);
  assert(skip_wf(vs->y == 10));
}

void foo1fail(struct VS *vs)
  requires(wrapped(vs))
  requires(vs->x == 10)
  writes(vs)
{
  writeVS(vs);
  assert(skip_wf(vs->x == 10));
}

// the axioms about versions should only hold for closed objects:
void foo1fail2(struct VS *vs)
  requires(mutable(vs))
  writes(&vs->x)
  requires(vs->x == 10)
{
  vs->x = 12;
  assert(skip_wf(vs->x == 10));
}

void foo1fail3(struct VS *vs)
  requires(mutable(vs))
  writes(&vs->y)
  requires(vs->y == 10)
  requires(vs->yappr == me())
{
  vs->y = 12;
  assert(skip_wf(vs->y == 10));
}

`
Verification of VS#adm succeeded.
Verification of foo1 succeeded.
Verification of foo2 succeeded.
Verification of foo1fail failed.
testcase(55,12) : error VC9500: Assertion '_vcc_in_state(_vcc_skip_wf(), vs->x == 10)' did not verify.
Verification of foo1fail2 failed.
testcase(65,12) : error VC9500: Assertion '_vcc_in_state(_vcc_skip_wf(), vs->x == 10)' did not verify.
Verification of foo1fail3 failed.
testcase(75,12) : error VC9500: Assertion '_vcc_in_state(_vcc_skip_wf(), vs->y == 10)' did not verify.
`
#include <vcc2.h>

struct VS1 {
  volatile int y;
  spec(volatile obj_t yappr;)

  invariant(approves(yappr, y))
};


struct VS2 {
  volatile int y;
  spec(struct VS1 * yappr;)

  invariant(approves(yappr, y))
};


struct VS3 {
  volatile int y;
  spec(obj_t yappr;)
  bool f;

  invariant(f ==> approves(yappr, y))
};

`
testcase(7,15) : error VC9672: volatile field 'yappr' is an approver, but not a self-approver
testcase(15,15) : error VC9673: approver field 'yappr' should have obj_t type, it has 'struct VS1*'
testcase(24,21) : error VC9671: approves(...) can only be used as a top-level invariant
`
#include <vcc2.h>

struct A { spec(obj_t x;) int y; };

struct VS1 {
  struct A a;

  volatile int y;
  spec(obj_t yappr;)

  invariant(approves(yappr, y + 1))
  invariant(approves(a.x, y))
};
`
testcase(11,15) : error VC9669: approves(...) needs this->field as the second parameter
testcase(12,15) : error VC9670: approves(...) needs owner(this) or this->field as the first parameter
`
#include "vcc2.h"

struct A {
  def_group(B)
  in_group(B) int x;
  inv_group(B, approves(owner(this), x))
};

`
`
#include <vcc2test.h>

struct VS {
  volatile int y;
  spec(volatile obj_t yappr;)

  invariant(approves(yappr, y))
  invariant(approves(yappr, yappr))
};

struct Dummy1 {
  int dummy;
};

void foo1(struct Dummy1 *d, struct VS *vs claimp(c))
  always(c, closed(d) && closed(vs) && vs->yappr == d)
{
  atomic(vs, c) {
    vs->y = 10;
  }
}

void foo2(struct VS *vs claimp(c))
  always(c, closed(vs) && vs->yappr == NULL)
{
  atomic(vs, c) {
    vs->y = 10;
  }
}
`
Verification of VS#adm succeeded.
Verification of foo1 succeeded.
Verification of foo2 succeeded.
`
#include <vcc2.h>

struct t{
    def_group(A, vcc(claimable))

    in_group(A) volatile int a;
    inv_group(A, approves(owner(this), a))

    int b;
    invariant(b == a)

    def_group(C, vcc(claimable))
    in_group(C) volatile int c;

    int d;

    invariant(keeps(this::A, this::C))
};

void test(struct t *p)
requires(wrapped(p))
writes(p)
{
    unwrap(p);

    p->b = 0;
    atomic(p::A)
    {

        begin_update();
        speconly(bump_volatile_version(p::A);)
        p->a = 0;
    }
    wrap(p);
}


void test1(struct t *p)
requires(wrapped(p))
writes(p)
{
    unwrap(p);

    atomic(p::C)
    {
        begin_update();
        p->c = 0;
    }
    wrap(p);
}
`
Verification of t#adm succeeded.
Verification of test succeeded.
Verification of test1 succeeded.
`
