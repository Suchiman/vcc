#include "vcc.h"

typedef int* pint;

spec(int foo(int map[pint], int* p)
{
  return map[p];
})

spec(int foo2(int map[obj_t], int* p)
{
  return map[p];
})

void bar(int* p)
{
  spec(int map[pint];)
  speconly(map[p] = 12;)
}

struct A {
  int q;
  spec( int m[int]; )
};

void baz(struct A *a)
  requires(thread_local(a))
  writes(&a->m)
{
  speconly(a->m[12] = 11;)
}
`
Verification of foo succeeded.
Verification of foo2 succeeded.
Verification of bar succeeded.
Verification of baz succeeded.
`
#include "vcc.h"

void foo()
{
  spec(char *xyz[char*];)
  spec(int foo[int*];)
  char arr[10];
  int x = 20;

  speconly(xyz = lambda(char *c; c != 0; c + 1);)
  speconly(foo = lambda(int *p; typed(p) && *p < 100; *p + 1);)
  
  assert(xyz[&arr[1]] == &arr[2]);
  assert(foo[&x] == 21);
}

void fail1()
{
  spec(int foo[int*];)
  int x = 120;

  speconly(foo = lambda(int *p; typed(p) && *p < 100; *p + 1);)
  assert(foo[&x] == 121);
}

void fail2()
{
  spec(int foo[int*];)
  int x = 20;

  speconly(foo = lambda(int *p; typed(p) && *p < 100; *p + 1);)
  assert(foo[&x] == 22);
}

`
Verification of foo succeeded.
Verification of fail1 failed.
testcase(23,12) : error VC9500: Assertion 'foo[&x] == 121' did not verify.
Verification of fail2 failed.
testcase(32,12) : error VC9500: Assertion 'foo[&x] == 22' did not verify.
`
#include "vcc.h"

void foo(int *map[int])
{
  assert(is(map[3], int));
}


void bar(obj_t map[int])
{
  assert(is(map[3], int));
}
`
Verification of foo succeeded.
Verification of bar failed.
testcase(11,12) : error VC9500: Assertion '_vcc_is(map[3], (_vcc_typeof((int*)0)))' did not verify.
`
#include <Vcc2.h>

struct S {
  int a;
  int b;
  int c;
};

void foo() {
  struct S a[int];
  struct S s = {1,2,3};
  a[1] = s;
  assert(a[1].a == 1);
  assert(a[1].b == 2);
  assert(a[1].c == 3);
}
`
Verification of foo succeeded.
`
#include <vcc.h>

#ifdef VERIFY 
typedef int MAP[int];
#endif

struct S {
  int i;
  spec(MAP m;)
};

void foo(struct S *s, int j)
  writes(s)
  maintains(wrapped(s))
  ensures(s->m == lambda(int n; true; n == j ? 0 : old(s->m)[n]))
{
  expose(s) {
    speconly(s->m[j] = 0;)
  }
}
`
Verification of foo succeeded.
`
#include <vcc.h>

#ifdef VERIFY 
typedef int MAP[int];
#endif

struct S {
  int i;
  spec(MAP m;)
};

spec(ispure MAP MyLambda(MAP oldMap, int j)
  ensures(result == lambda(int n; true; n == j ? 0 : oldMap[n]));
)

void foo(struct S *s, int j)
  writes(s)
  maintains(wrapped(s))
  ensures(forall(int i; s->m[i] == MyLambda(old(s->m), j)[i]))
{
  expose(s) {
    speconly(s->m[j] = 0;)
  }
}
`
Verification of foo succeeded.
`
#include <vcc.h>

struct S {
  int i;
  spec(int m[int];)
};

void foo(struct S *s)
  writes(s)
  maintains(wrapped(s)) {
  expose(s) {
    speconly((s->m[1]) = 2;)
  }
}
`
Verification of foo succeeded.
`


#include <vcc.h>

typedef unsigned __int64 UINT64;

typedef bool BITMAP[UINT64];

spec(
ispure BITMAP ToBitMap(UINT64 n);
)

axiom(forall(UINT64 x; forall(UINT64 i; i < 64 ==> !ToBitMap(x)) ==> x == 0));
`
testcase(13,78) : error VC0000: Operator '!' cannot be applied to operand of type 'System.Diagnostics.Contracts.CodeContract.Map<ulong, bool>'.
`
#include <vcc.h>

#ifdef VERIFY 
typedef int MAP[int];
#endif

struct S {
  int i;
  spec(MAP m;)
};

void foo(struct S *s, int j)
  writes(s)
  maintains(wrapped(s))
  ensures(forall(int i; s->m[i] == lambda(int n; true; n == j ? 0 : old(s->m)[n])[i]))
{
  expose(s) {
    speconly(s->m[j] = 0;)
  }
}
`
Verification of foo succeeded.
`
#include<vcc.h>

spec(int G[void *];)

struct S {
 spec(int M[void *];)
 int a;
};

void foo(struct S *s) { }
`
Verification of foo succeeded.
`
#include "vcc.h"

void xxx(unsigned i) {
   spec(bool map1[unsigned];) 
   spec(bool map2[unsigned];) 
   speconly(map2 = ((i==2)? map1: map2);)
}

void bar(unsigned i) {
   spec(bool map[unsigned];) 
   speconly(map = (lambda(unsigned j; true; i==j || map[j]));)
   //error VC9600: OOPS: error in expr
}


void works(unsigned i) {
   spec(unsigned map[unsigned];) 
   speconly(map = (lambda(unsigned j; true; ((i==j)? i: (map[j]))));)
}
`
Verification of xxx succeeded.
Verification of bar succeeded.
Verification of works succeeded.
`
#include "vcc.h"

void foo() {
    spec(bool map[unsigned][unsigned];)
    speconly(map = (lambda(unsigned i; true; (lambda(unsigned j; true; j==i))));)
    assert(map[3][3]);
    assert(!map[3][2]);
    assert(forall(unsigned i; map[i][i]));
    assert(forall(unsigned i,j; i!=j ==> !map[i][j]));
}
`
Verification of foo succeeded.
`

#include <vcc.h>

struct Foo {
    unsigned dummy;
};

void foo(unsigned i) {
   spec(struct Foo map1[unsigned];) 
   spec(struct Foo map2[unsigned];) 
   speconly(map2 = ((i==2)? map1: map2);)
}
`
Verification of foo succeeded.
`

#include <vcc.h>

struct S {
  int a;
  spec(bool M[unsigned __int64];)
  invariant(M == lambda(unsigned __int64 x; x < 100; is((struct S *)x, struct S)))
};

void foo(struct S *s) {}

`
Verification of S#adm succeeded.
Verification of foo succeeded.
`
#include "vcc.h"

void foo() {
    spec(int map[int][unsigned];)
    speconly(map = lambda(int x; unsigned y; true; 42);)
    assert(map[2][3] == 42);
}
`
Verification of foo succeeded.
`
#include "vcc.h"

typedef struct _TEST{
  int dummy;
  spec(claim_t a;)
} TEST, *PTEST;


spec(
ispure bool Fun(PTEST a claimp(c))
  reads(a) 
  requires(typed(a))
  requires(thread_local(a))
  ensures(result == (a->a == c))
{
  return a->a == c;
}
)

void foo(PTEST a)
{
  spec(bool m[claim_t] = lambda(claim_t cl; true; Fun(a, cl));)
} 
`
Verification of Fun succeeded.
Verification of foo succeeded.
Verification of Fun#reads succeeded.
`#include "vcc.h"

void foo(int x) {
    spec(int map[int];)
    spec(int i;)
    assume(forall(int j; (j|x)==42));
    assert((i|x)==42);
    speconly(i = map[3];)
    // We lose $in_range_i4() here, so the following assert doesn't verify...
    assert((i|x)==42);
}

typedef unsigned __int64 UINT64;
spec( typedef UINT64 MAP[UINT64]; )

spec(
void foo2(MAP m) {
  assert(m[0] >= 0);
})
`
Verification of foo succeeded.
Verification of foo2 succeeded.
`
#include "vcc.h"

void foo() {
spec(int map[int];)
speconly(map = lambda(int , x; true; 42);)
} 
`
testcase(5,60) : error VC0000: Identifier expected.
`
#include "vcc.h"

void foo() {
  spec(int XY[int][int];)
  speconly(XY[3][4] = 42;)
  assert(XY[3][4] == 42);
}

void bar() {
  spec(int XY[int][int][int];)
  speconly(XY[3][4][5] = 42;)
  assert(XY[3][4][5] == 42);
}
`
Verification of foo succeeded.
Verification of bar succeeded.
`
#include "vcc.h"

void foo() {
  spec(bool mapmap[int][int];)
  spec(bool map[int] = lambda(int j; true; exists(int i; mapmap[i][j]));)
}
`
Verification of foo succeeded.
`
#include "vcc.h"

struct T {
    int dummy;
    spec(bool Y[int];)
};

spec(ispure bool takes_quantified_variable(int l)
    reads(set_universe())
    returns(true);)

void foo(struct T *t)
    requires(wrapped(t))
{
    spec(bool Z[int];)
    spec(bool Y[int];)
    Z = lambda(int l; true; t->Y[l] || takes_quantified_variable(l));
}
`
Verification of foo succeeded.
`
#include "vcc.h"

struct vcc(record) S {
    int a;
};

void foo()
{
    spec(struct S map2[int];)
    speconly(map2 = lambda(int x; true; (struct S) { .a = x });)
    assert(map2[4].a == 4);
}
`
Verification of foo succeeded.
`
#include "vcc.h"

struct vcc(record) S {
    int a;
    int b;
};

void foo()
{
    spec(struct S t, map[int];)
    speconly(t.b = 20;)
    speconly(map = lambda(int x; true; t / { .a = x });)
    assert(map[4].a == 4);
    assert(map[4].b == 20);
}
`
Verification of foo succeeded.
`
#include "vcc.h"

spec(
typedef struct S_str {
unsigned int id;
} S_t;
)

spec(
struct abs_str {
bool Sset[S_t];

invariant(Sset == lambda(S_t s; true ; s.id < 42))
} abs;
) 
`
testcase(3,25) : error VC9702: Illegal type 'struct S_str' in map domain.
`
#include "vcc.h"

struct S { int d; };

void foo() {
spec(struct S X[unsigned];)
speconly(X[0].d = 42;)
}
`
testcase(7,41) : error VC0000: Illegal update of map 'X'.
`
#include <vcc.h>

void foo() {
  spec(int a[int] = lambda(int i; true; i);)
  spec(int b[int] = lambda(int i; true; i);)
  assert(a == b);
}

void bar() {
  spec(int a[int][int] = lambda(int i; int j; true; i);)
  spec(int b[int][int] = lambda(int i; int j; true; i);)
  assert(a == b);
}
`
Verification of foo succeeded.
Verification of bar succeeded.
`
#include "vcc.h"

struct X { int a; };

void foo() {
    spec(void *f[int];)
    speconly(f[0] = (void*)0;)
    assert(f[0]==(void*)0);
    speconly(f = lambda(int x; true; (void*)0);)
    assert(forall(int x; f[x] == (void*)0));
}
`
Verification of foo succeeded.
`