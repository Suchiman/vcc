`/newsyntax
#include <vcc.h>


_(claimable) struct A {
  int x;
  volatile int vol_x;
};

struct B {
  int y;
  struct A *a;
  _(ghost \claim ca)

  _(invariant \mine(ca) && \claims(ca, (\when_claimed(a))->\closed))
  _(invariant y == _(by_claim ca)(a->x))
};

void write_int(int *x)
  _(writes x);

void ok1(struct A*a _(ghost \claim c))
  _(always c, a->\closed)
{ 
  int q;
  int z = _(by_claim c)(a->x);
  int zz;

  write_int(&q);
  zz = _(by_claim c)(a->x);
  _(assert  z == zz)
}


void fail1(struct A*a, struct A*b _(ghost \claim c))
  _(always c, b->\closed)
{ 
  int z = _(by_claim c)(a->x);
}

void fail2(struct A*a _(ghost \claim c))
  _(always c, a->\closed)
  _(writes c)
  _(requires c->\claim_count == 0)
{ 
  int z;
  
  _(ghost \destroy_claim(c, {}));
  z = _(by_claim c)(a->x);
  _(assume \false)
}

struct B_fail1 {
  int y;
  struct A *a;
  _(ghost \claim ca)

  _(invariant \claims(ca, (\when_claimed(a))->\closed))
  _(invariant y == _(by_claim ca)(a->x))
};

struct B_fail2 {
  int y;
  struct A *a;
  _(ghost \claim ca)

  _(invariant \mine(ca))
  _(invariant y == _(by_claim ca)(a->x))
};


struct B_fail3 {
  int y;
  struct A *a;
  _(ghost \claim ca)

  _(invariant \mine(ca))
  _(invariant y == a->vol_x)
};

struct vcc_attr("no_infer", "always_by_claim") B_may_fail1 {
  int y;
  struct A *a;
  _(ghost \claim ca)

  _(invariant \mine(ca) && \claims(ca, (\when_claimed(a))->\closed))
  _(invariant y == a->x)
};

vcc_attr("no_infer", "always_by_claim")
void may_fail1(struct A*a _(ghost \claim c))
  _(always c, a->\closed)
{ 
  int z = a->x;
}


void fail3(struct A*a, struct A*b _(ghost \claim c))
  _(always c, b->\closed)
{ 
  int z = a->x;
}

`
Verification of B#adm succeeded.
Verification of B_fail1#adm failed.
testcase(58,29) : error VC8012: invariant(y == __specification(by_claim ca)(a->x)) of B_fail1 is not admissible.
Verification of B_fail2#adm failed.
testcase(67,29) : error VC8012: invariant(y == __specification(by_claim ca)(a->x)) of B_fail2 is not admissible.
Verification of B_fail3#adm failed.
testcase(77,29) : error VC8012: invariant(y == a->vol_x) of B_fail3 is not admissible.
Verification of B_may_fail1#adm failed.
testcase(86,29) : error VC8012: invariant(y == a->x) of B_may_fail1 is not admissible.
Verification of ok1 succeeded.
Verification of fail1 failed.
testcase(37,39) : error VC8509: Assertion 'object a is claimed by c (in by_claim(c, a))' did not verify.
Verification of fail2 failed.
testcase(48,35) : error VC8508: Assertion 'c is a valid claim (in by_claim(c, a))' did not verify.
Verification of may_fail1 failed.
testcase(93,11) : error VC8512: Assertion 'a->x is thread local' did not verify.
Verification of fail3 failed.
testcase(100,11) : error VC8512: Assertion 'a->x is thread local' did not verify.
`
`/newsyntax
#include <vcc.h>


_(claimable) struct A {
  int x;
  volatile int vol_x;
};

struct B_fail1 {
  int y;
  struct A *a;
  _(ghost \claim ca)

  _(invariant \mine(ca) && \claims(ca, (\when_claimed(a))->\closed))
  _(invariant y == _(by_claim ca)(a->vol_x))
};

void fail1(struct A*a _(ghost \claim c))
  _(always c, a->\closed)
{ 
  int z = _(by_claim c)(a->vol_x);
}

void fail2(struct A*a, int *x _(ghost \claim c))
  _(always c, a->\closed)
{ 
  int z = _(by_claim c)(*x);
}
`
testcase(15,34) : error VC9629: by_claim(...) can only refer to a non-volatile field
testcase(6,3)-(6,21) : (Location of symbol related to previous error.)
testcase(21,11) : error VC9629: by_claim(...) can only refer to a non-volatile field
testcase(6,3)-(6,21) : (Location of symbol related to previous error.)
testcase(27,11) : error VC9628: by_claim(...) expects field or embedded array reference as a second parameter
`
`/newsyntax
#include <vcc.h>


_(claimable) struct A {
  int x;
  volatile int vol_x;
};

struct B {
  int y;
  struct A *a;
  _(ghost \claim ca)

  _(invariant \mine(ca) && \claims(ca, (\when_claimed(a))->\closed))
  _(invariant y == a->x)
};

void write_int(int *x)
  _(writes x);

void ok1(struct A*a _(ghost \claim c))
  _(always c, a->\closed)
{ 
  int q;
  int z = a->x;
  int zz;

  write_int(&q);
  zz = a->x;
  _(assert  z == zz)
}

vcc_attr("no_infer", "always_by_claim")
void ok2(struct A*a _(ghost \claim c))
  _(requires \always_by_claim(c, a))
  _(always c, a->\closed)
{
  int q;
  int z = a->x;
  int zz;

  write_int(&q);
  zz = a->x;
  _(assert  z == zz)
}


vcc_attr("no_infer", "always_by_claim")
void ok3(struct A*a _(ghost \claim c))
  _(always c, a->\closed)
{
  int q;
  int z;
  int zz;

  _(assert \always_by_claim(c, a))
  z = a->x;

  write_int(&q);
  zz = a->x;
  _(assert  z == zz)
}

vcc_attr("no_infer", "always_by_claim")
struct B2 {
  int y;
  struct A *a;
  _(ghost \claim ca)
 
  _(invariant \always_by_claim(ca, a))
  _(invariant \mine(ca) && \claims(ca, (\when_claimed(a))->\closed))
  _(invariant y == a->x)
};

`
Verification of B#adm succeeded.
Verification of B2#adm succeeded.
Verification of ok1 succeeded.
Verification of ok2 succeeded.
Verification of ok3 succeeded.
`
`/newsyntax
#include <vcc.h>


_(claimable) struct A {
  int x;
  volatile int vol_x;
};


void fail1(struct A*a _(ghost \claim c))
  _(always c, a->\closed)
  _(writes c)
  _(requires c->\claim_count == 0)
{ 
  int z;

  _(ghost \destroy_claim(c, {}));
  z = a->x;
  _(assume \false)
}

void fail2(struct A*a,struct A*b _(ghost \claim c))
  _(always c, b->\closed)
  _(requires \always_by_claim(c, a))
{ 
  int z;
  z = a->x;
}

`
Verification of fail1 failed.
testcase(18,7) : error VC8508: Assertion 'c is a valid claim (in by_claim(c, a))' did not verify.
Verification of fail2 failed.
testcase(27,7) : error VC8509: Assertion 'object a is claimed by c (in by_claim(c, a))' did not verify.
`
`/newsyntax
#include <vcc.h>

struct A {
  unsigned x:1;
  unsigned y:1;
};

struct B {
  struct A a;
   _(ghost \claim c;) 
  _(invariant \mine(c))
  _(invariant \claims(c, (&a)->\closed))
  _(invariant _(by_claim c)(a.x) == 1)
};

struct B2 {
  struct A a;
   _(ghost \claim c;) 
  _(invariant \mine(c))
  _(invariant \claims(c, (&a)->\closed))
  _(invariant a.x == 1)
};
`
Verification of B#adm succeeded.
Verification of B2#adm succeeded.
`
`/newsyntax
#include <vcc.h>

typedef _(claimable) struct _TH_PROCESS {
  int x;
} *PTH_PROCESS;


void ThpCreateThread(PTH_PROCESS Process _(ghost \claim c))
  _(always c, Process->\closed)
  _(writes c)
{
  _(assert _(by_claim c)(Process->x) == 0)
}
`
Verification of ThpCreateThread failed.
testcase(12,26) : error VC9500: Assertion '__specification(by_claim c)(Process->x) == 0' did not verify.
`
`/newsyntax
#include "vcc.h"
 
typedef struct _mailbox {
int data;
} mailbox;

vcc_attr("no_infer", "always_by_claim")
typedef _(dynamic_owns) struct _pls {
int data;
_(group ipi)
_(:ipi) 
mailbox mbox[2];
_(invariant :ipi \depends(\this->\owner, \this))
_(ghost \claim c)
_(invariant \mine(c) &&
\claims(c, (&ghost)->\closed))
_(invariant &(_(by_claim c)(onepls))->mbox[1] \in \this->\owns)
_(invariant &(_(by_claim c)(kpr[1]))->mbox[1] \in \this->\owns)
} pls, *ppls;

vcc_attr("no_infer", "always_by_claim")
typedef _(dynamic_owns) _(claimable) struct _owner {
int data;
_(invariant \gemb(&onepls) \in \this->\owns)
//invariant(set_in((struct pls::ipi *)onepls, owns(this)))
_(invariant \gemb(&kpr) \in \this->\owns)
_(invariant \forall int i; 0 <= i && i < 2 ==> ((struct pls::ipi *)kpr[i] \in \this->\owns))
_(invariant kpr[0] != kpr[1])
} owner;

ppls onepls;
ppls kpr[2];
owner ghost;
`
Verification of _pls#adm succeeded.
Verification of _pls##ipi#adm succeeded.
Verification of _owner#adm succeeded.
`
`/newsyntax
#include <vcc.h>

struct S {
  int x;
};


void foo( _(ghost \claim c) )
  _(writes c) // doesn't really make sense but...
  _(maintains \wrapped(c));

void bar(struct S *s _(ghost \claim c))
  _(always c, s->\closed)
  _(writes c)
{
  int tmp = _(by_claim c)(s->x);
  foo(_(ghost c));
  _(assert tmp == _(by_claim c)(s->x))
}
`
Verification of bar succeeded.
`
`/newsyntax
#include "vcc.h"

_(claimable) struct S {
    int *x;
    _(invariant \mine((void[3])x))
    _(invariant ((void[3])x)->\valid)
};

vcc_attr("no_infer", "always_by_claim")
void foo(struct S *s _(ghost \claim c))
    _(always c, s->\closed)
{
    _(atomic c,s) {}
    _(assert \is_array(s->x, 3))
    _(assert s->x==_(by_claim c)(s->x))
    _(assert s->x[2] == _(by_claim c)(s->x[2]))
    _(assert \unchanged(s->x[2]))
}
`
Verification of S#adm succeeded.
Verification of foo succeeded.
`
`/newsyntax
#include <stdlib.h>
#include <vcc.h>

typedef _(claimable) _(volatile_owns) struct _SPIN_LOCK
{
  volatile int Lock;
  _(ghost \object protected_obj)
  _(invariant !Lock ==> \mine(protected_obj))
} SPIN_LOCK;

void Acquire(SPIN_LOCK *SpinLock _(ghost \claim access_claim))   
  _(always access_claim, SpinLock->\closed)
  _(ensures \wrapped(SpinLock->protected_obj))
  _(ensures \fresh(SpinLock->protected_obj))
  ;

void Release(SPIN_LOCK *SpinLock _(ghost \claim access_claim))
  _(writes SpinLock->protected_obj)
  _(always access_claim, SpinLock->\closed)
  _(requires access_claim != SpinLock->protected_obj)
  _(requires \wrapped(SpinLock->protected_obj))
  ;

_(claimable) struct LockedArray {
  _(as_array) int arr[10];
  SPIN_LOCK Lock;
  _(invariant \mine(&Lock))
  _(invariant Lock.protected_obj == (void[10])arr)
};

void WriteArr(struct LockedArray *larr, unsigned int pos, int val _(ghost \claim cl))
  _(always cl, larr->\closed)
  _(requires pos < 10)
{
  Acquire(&larr->Lock _(ghost cl));
  _(unwrapping (void[10])(larr->arr)) {
    larr->arr[pos] = val;
  }
  Release(&larr->Lock _(ghost cl));
}
`
Verification of _SPIN_LOCK#adm succeeded.
Verification of LockedArray#adm succeeded.
Verification of WriteArr succeeded.
`
