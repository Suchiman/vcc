#include <vcc.h>


struct vcc(claimable) A {
  int x;
  volatile int vol_x;
};

struct B {
  int y;
  struct A *a;
  spec(claim_t ca;)

  invariant(keeps(ca) && claims(ca, closed(when_claimed(a))))
  invariant(y == by_claim(ca, a->x))
};

void write_int(int *x)
  out_param(x);

void ok1(struct A*a claimp(c))
  always(c, closed(a))
{ 
  int q;
  int z = by_claim(c, a->x);
  int zz;

  write_int(&q);
  zz = by_claim(c, a->x);
  assert( z == zz );
}


void fail1(struct A*a, struct A*b claimp(c))
  always(c, closed(b))
{ 
  int z = by_claim(c, a->x);
}

void fail2(struct A*a claimp(c))
  always(c, closed(a))
  writes(c)
  requires(ref_cnt(c) == 0)
{ 
  int z;
  
  unclaim(c);
  z = by_claim(c, a->x);
  assume(false);
}

struct B_fail1 {
  int y;
  struct A *a;
  spec(claim_t ca;)

  invariant(claims(ca, closed(when_claimed(a))))
  invariant(y == by_claim(ca, a->x))
};

struct B_fail2 {
  int y;
  struct A *a;
  spec(claim_t ca;)

  invariant(keeps(ca))
  invariant(y == by_claim(ca, a->x))
};


struct B_fail3 {
  int y;
  struct A *a;
  spec(claim_t ca;)

  invariant(keeps(ca))
  invariant(y == a->vol_x)
};

struct vcc_attr("no_infer", "always_by_claim") B_may_fail1 {
  int y;
  struct A *a;
  spec(claim_t ca;)

  invariant(keeps(ca) && claims(ca, closed(when_claimed(a))))
  invariant(y == a->x)
};

vcc_attr("no_infer", "always_by_claim")
void may_fail1(struct A*a claimp(c))
  always(c, closed(a))
{ 
  int z = a->x;
}


void fail3(struct A*a, struct A*b claimp(c))
  always(c, closed(b))
{ 
  int z = a->x;
}

`
Verification of B#adm succeeded.
Verification of B_fail1#adm failed.
testcase(58,15) : error VC8012: invariant(y == _vcc_in_state(_vcc_by_claim(ca), a->x)) of B_fail1 is not admissible.
Verification of B_fail2#adm failed.
testcase(67,15) : error VC8012: invariant(y == _vcc_in_state(_vcc_by_claim(ca), a->x)) of B_fail2 is not admissible.
Verification of B_fail3#adm failed.
testcase(77,15) : error VC8012: invariant(y == a->vol_x) of B_fail3 is not admissible.
Verification of B_may_fail1#adm failed.
testcase(86,15) : error VC8012: invariant(y == a->x) of B_may_fail1 is not admissible.
Verification of ok1 succeeded.
Verification of fail1 failed.
testcase(37,43) : error VC8509: Assertion 'object a is claimed by c (in by_claim(c, a))' did not verify.
Verification of fail2 failed.
testcase(48,39) : error VC8508: Assertion 'c is a valid claim (in by_claim(c, a))' did not verify.
Verification of may_fail1 failed.
testcase(93,11) : error VC8512: Assertion 'a->x is thread local' did not verify.
Verification of fail3 failed.
testcase(100,11) : error VC8512: Assertion 'a->x is thread local' did not verify.
`
#include <vcc.h>


struct vcc(claimable) A {
  int x;
  volatile int vol_x;
};

struct B_fail1 {
  int y;
  struct A *a;
  spec(claim_t ca;)

  invariant(keeps(ca) && claims(ca, closed(when_claimed(a))))
  invariant(y == by_claim(ca, a->vol_x))
};

void fail1(struct A*a claimp(c))
  always(c, closed(a))
{ 
  int z = by_claim(c, a->vol_x);
}

void fail2(struct A*a, int *x claimp(c))
  always(c, closed(a))
{ 
  int z = by_claim(c, *x);
}
`
testcase(15,20) : error VC9629: by_claim(...) can only refer to a non-volatile field
testcase(6,3)-(6,21) : (Location of symbol related to previous error.)
testcase(21,11) : error VC9629: by_claim(...) can only refer to a non-volatile field
testcase(6,3)-(6,21) : (Location of symbol related to previous error.)
testcase(27,11) : error VC9628: by_claim(...) expects field or embedded array reference as a second parameter
`
#include <vcc.h>


struct vcc(claimable) A {
  int x;
  volatile int vol_x;
};

struct B {
  int y;
  struct A *a;
  spec(claim_t ca;)

  invariant(keeps(ca) && claims(ca, closed(when_claimed(a))))
  invariant(y == a->x)
};

void write_int(int *x)
  out_param(x);

void ok1(struct A*a claimp(c))
  always(c, closed(a))
{ 
  int q;
  int z = a->x;
  int zz;

  write_int(&q);
  zz = a->x;
  assert( z == zz );
}

vcc_attr("no_infer", "always_by_claim")
void ok2(struct A*a claimp(c))
  requires(always_by_claim(c, a))
  always(c, closed(a))
{
  int q;
  int z = a->x;
  int zz;

  write_int(&q);
  zz = a->x;
  assert( z == zz );
}


vcc_attr("no_infer", "always_by_claim")
void ok3(struct A*a claimp(c))
  always(c, closed(a))
{
  int q;
  int z;
  int zz;

  assert(always_by_claim(c, a));
  z = a->x;

  write_int(&q);
  zz = a->x;
  assert( z == zz );
}

vcc_attr("no_infer", "always_by_claim")
struct B2 {
  int y;
  struct A *a;
  spec(claim_t ca;)
 
  invariant(always_by_claim(ca, a))
  invariant(keeps(ca) && claims(ca, closed(when_claimed(a))))
  invariant(y == a->x)
};

`
Verification of B#adm succeeded.
Verification of B2#adm succeeded.
Verification of ok1 succeeded.
Verification of ok2 succeeded.
Verification of ok3 succeeded.
`
#include <vcc.h>


struct vcc(claimable) A {
  int x;
  volatile int vol_x;
};


void fail1(struct A*a claimp(c))
  always(c, closed(a))
  writes(c)
  requires(ref_cnt(c) == 0)
{ 
  int z;

  unclaim(c);
  z = a->x;
  assume(false);
}

void fail2(struct A*a,struct A*b claimp(c))
  always(c, closed(b))
  requires(always_by_claim(c, a))
{ 
  int z;
  z = a->x;
}

`
Verification of fail1 failed.
testcase(18,7) : error VC8508: Assertion 'c is a valid claim (in by_claim(c, a))' did not verify.
Verification of fail2 failed.
testcase(27,7) : error VC8509: Assertion 'object a is claimed by c (in by_claim(c, a))' did not verify.
`
#include <vcc.h>

struct A {
  unsigned x:1;
  unsigned y:1;
};

struct B {
  struct A a;
  spec( claim_t c; )
  invariant(keeps(c))
  invariant(claims(c, closed(&a)))
  invariant(by_claim(c, a.x) == 1)
};

struct B2 {
  struct A a;
  spec( claim_t c; )
  invariant(keeps(c))
  invariant(claims(c, closed(&a)))
  invariant(a.x == 1)
};
`
Verification of B#adm succeeded.
Verification of B2#adm succeeded.
`
#include <vcc.h>

typedef struct vcc(claimable) _TH_PROCESS {
  int x;
} *PTH_PROCESS;


void ThpCreateThread(PTH_PROCESS Process claimp(c))
  always(c, closed(Process))
  writes(c)
{
  assert(by_claim(c, Process->x) == 0);
}
`
Verification of ThpCreateThread failed.
testcase(12,12) : error VC9500: Assertion '_vcc_in_state(_vcc_by_claim(c), Process->x) == 0' did not verify.
`
#include "vcc.h"
 
typedef struct _mailbox {
int data;
} mailbox;

vcc_attr("no_infer", "always_by_claim")
typedef struct vcc(dynamic_owns) _pls {
int data;
def_group(ipi)
in_group(ipi) 
mailbox mbox[2];
inv_group(ipi, depends(owner(this), this))
spec(claim_t c;)
invariant(keeps(c) &&
claims(c, closed(&ghost)))
invariant(set_in(&by_claim(c, onepls)->mbox[1],owns(this)))
invariant(set_in(&by_claim(c, kpr[1])->mbox[1],owns(this)))
} pls, *ppls;

vcc_attr("no_infer", "always_by_claim")
typedef struct vcc(dynamic_owns) vcc(claimable) _owner {
int data;
invariant(set_in(gemb(&onepls),owns(this)))
//invariant(set_in((struct pls::ipi *)onepls, owns(this)))
invariant(set_in(gemb(&kpr),owns(this)))
invariant(forall(int i; 0 <= i && i < 2; set_in((struct pls::ipi *)kpr[i], owns(this))))
invariant(kpr[0] != kpr[1])
} owner;

ppls onepls;
ppls kpr[2];
owner ghost;
`
Verification of _pls#adm succeeded.
Verification of _pls##ipi#adm succeeded.
Verification of _owner#adm succeeded.
`
#include <vcc.h>

struct S {
  int x;
};


void foo( claimp(c) )
  writes(c) // doesn't really make sense but...
  maintains(wrapped(c));

void bar(struct S *s claimp(c))
  always(c, closed(s))
  writes(c)
{
  int tmp = by_claim(c, s->x);
  foo(spec(c));
  assert(tmp == by_claim(c, s->x));
}
`
Verification of bar succeeded.
`
#include "vcc.h"

struct vcc(claimable) S {
    int *x;
    invariant(keeps(as_array(x,3)))
    invariant(typed(as_array(x,3)))
};

vcc_attr("no_infer", "always_by_claim")
void foo(struct S *s claimp(c))
    always(c, closed(s))
{
    atomic (c,s) {}
    assert(is_array(s->x, 3));
    assert(s->x==by_claim(c,s->x));
    assert(s->x[2] == by_claim(c,s->x[2]));
    assert(unchanged(s->x[2]));
}
`
Verification of S#adm succeeded.
Verification of foo succeeded.
`