`/newsyntax
#include <vcc.h>

struct S {
  int a;
  int b;
};

struct T {
  _(inline) struct S S1;
  struct S S2;
  _(invariant \mine(&S2))
};

void foo(struct S *s) 
  _(reads s)
  _(requires s->\valid)
{ 
}
void fooByVal(struct S s) 
  _(requires s.a == s.b)
{ 
}

void bar(struct T *t) 
  _(requires \wrapped(t))
  _(writes t)
{
  _(unwrapping t) {
    foo(&t->S2);
  }
}

void barByVal(struct T *t) 
  _(requires \wrapped(t))
  _(requires t->S2.a == t->S2.b)
  _(writes t)
{
  _(unwrapping t) {
    fooByVal(t->S2);
  }
}

`
Verification of T#adm succeeded.
Verification of foo succeeded.
Verification of fooByVal succeeded.
Verification of bar succeeded.
Verification of barByVal succeeded.
`
`/newsyntax
#include <vcc.h>

	struct S {
		int a;
		int b;
	};

	struct T {
		_(inline) struct S S1[5];
		struct S S2;
		_(invariant \mine(&S2))
	};

void foo(struct S *s) 
  _(reads s)
  _(requires s->\valid)
{ 
}
void fooByVal(struct S s) 
  _(requires s.a == s.b)
{ 
}

void bar(struct T *t) 
  _(requires \wrapped(t))
  _(writes t)
{
  _(unwrapping t) {
    foo(&t->S2);
  }
}

void barByVal(struct T *t) 
  _(requires \wrapped(t))
  _(requires t->S2.a == t->S2.b)
  _(writes t)
{
  _(unwrapping t) {
    fooByVal(t->S2);
  }
}

`
Verification of T#adm succeeded.
Verification of foo succeeded.
Verification of fooByVal succeeded.
Verification of bar succeeded.
Verification of barByVal succeeded.
`
`/newsyntax
#include <vcc.h>

struct A {
	int a;
	int b;
};

struct B {
	_(inline) struct A x;
};

struct C {
	_(inline) struct B y;
};

struct D {
	_(inline) struct C z;
};

void foo(struct C *p) 
  _(writes \extent(p))
  _(ensures p->y.x.a == p->y.x.b)
{
	p->y.x.a = p->y.x.b;
}

void bar(struct D *p) 
  _(writes \extent(p))
  _(ensures p->z.y.x.a == p->z.y.x.b)
{
	p->z.y.x.a = p->z.y.x.b;
}
`
Verification of foo succeeded.
Verification of bar succeeded.
`
`/newsyntax
#include <vcc.h>

union U {
  struct {
    int a : 16;
    int b : 16;
  };
  
  _(backing_member) int AsInt;
};


struct S {
  _(inline) union U u;
  int dummy;
};

void foo(struct S *p) 
  _(writes p)
  _(maintains \wrapped(p))
{
  union U u;
  _(unwrap p)
  p->u = u;
  _(wrap p)
}
`
Verification of foo succeeded.
`
`/newsyntax
#include <vcc.h>

struct U {
  int a;
  int b;
};


struct S {
  _(inline) struct U u;	
  int dummy;
};

void foo(struct S *p) 
  _(writes p)
  _(maintains \wrapped(p))
{
  struct U u;
  _(unwrap p)
  p->u = u;
  _(wrap p)
}
`
testcase(20,3) : error VC9679: Field 'u' has been inlined and cannot be referred to as such; refer to its nested fields instead
`
`/newsyntax
#include <vcc.h>
typedef unsigned __int8 byte;
struct S1 { 
  int A1;
  struct { 
    int A2;
    struct S3 { 
      int A3;
    } _(s3); 
  } _(s2); 
}; 

void foo1() {
    byte x[sizeof(struct S1)];
    _(from_bytes (struct S1*)x, \false)
    _(assume 0) // avoid stack-free check here
}


void foo3() {
    byte x[sizeof(struct S3)];
    _(from_bytes (struct S3*)x, \false)
    _(assume 0) // avoid stack-free check here
}
`
Verification of foo1 succeeded.
Verification of foo3 succeeded.
`
`/newsyntax
#include <vcc.h>
typedef unsigned __int8 byte;
struct S1 { 
  int A1;
  struct { 
    int A2;
    struct S3 { 
      int A3;
    }; 
  }; 
}; 

void foo1() {
    byte x[sizeof(struct S1)];
    _(from_bytes (struct S1*)x, \false)
    _(assume 0) // avoid stack-free check here
}


void foo3() {
    byte x[sizeof(struct S3)];
    _(from_bytes (struct S3*)x, \false)
    _(assume 0) // avoid stack-free check here
}
`
Verification of foo1 succeeded.
Verification of foo3 succeeded.
`