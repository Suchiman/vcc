#include "vcc2test.h"

struct A {
  volatile int x;
  invariant(depends(owner(this),this))
};

void OldInInvCheckInLoop()
{ 
  int x;
  while (unchecked(x++)) 
  {
    struct A *a;
    a = malloc(sizeof(*a));
    if (a != NULL) wrap(a);
  }
}
`
Verification of A#adm succeeded.
Verification of OldInInvCheckInLoop succeeded.
`
#include "vcc.h"

struct vcc(dynamic_owns) _X
{
	int a;
	invariant(a > 0 ==> set_in(&a, owns(this)))
};
`
testcase(6,37) : warning VC9104: primitive pointers are unlikely to be in the owns set
Verification of _X#adm succeeded.
`
#include <vcc.h>

struct A {
  int f;
  struct B *b;
  int g;

  invariant(f == b->f + b->g)
};

struct B {
  int f;
  struct A *b;
  int g;

  invariant(f == b->f + b->g)
};

`
Verification of A#adm failed.
testcase(8,15) : error VC8012: invariant(f == b->f + b->g) of A is not admissible.
Verification of B#adm failed.
testcase(16,15) : error VC8012: invariant(f == b->f + b->g) of B is not admissible.
`
#include "vcc.h"
typedef unsigned __int64 UINT64, *PUINT64;
typedef struct vcc(volatile_owns) vcc(dynamic_owns) _rwkey{
  int data;
  on_unwrap(unchanged(closed(this)) || inv2(&ghost))
  //on_unwrap(closed(&ghost) ==> inv2(&ghost))
  invariant((!old(closed(this)) && (closed(this))) ==> inv2(&ghost))// needed for admissibility without having b => closed(rwkey) in ghost
  invariant(unchanged(owns(this)) || inv2(&ghost))
} rwkey;

typedef struct vcc(volatile_owns) vcc(dynamic_owns) _rwkey2{
  int data;
  invariant(unchanged(closed(this)) || inv2(&ghost))
  invariant(unchanged(owns(this)) || inv2(&ghost))
} rwkey2;


typedef struct vcc(dynamic_owns) p
{

    def_group(Ipi, vcc(claimable))
   
    spec(claim_t IpiClaim;) 
    invariant(set_in(IpiClaim, owns(this)))
    invariant(claims(IpiClaim, closed(this::Ipi) && closed(&ghost))) 
    in_group(Ipi)
    UINT64 CpuNumber;
    in_group(Ipi)
    spec( rwkey read[64];)
    in_group(Ipi)
    spec( rwkey write[64];)

    invariant(forall(UINT64 i; i < 64; set_in(&read[i], owns(this))))
    invariant(forall(UINT64 i; i < 64; set_in(&write[i], owns(this))))

    in_group(Ipi)
    volatile bool flag;
    inv_group(Ipi, unchanged(flag) || inv2(&ghost))
		
	  }p, *pp;

pp kpr[64];

typedef struct vcc(claimable) vcc(dynamic_owns)_ownerkpr{
    invariant(this == &ghost)
    volatile int i;
    invariant(unchanged(i))
    int dummy;
    invariant(set_in(gemb(&kpr),owns(this)))
    invariant(closed(gemb(&kpr)))
    invariant(forall(UINT64 i; i < 64;  set_in(kpr[i]::Ipi, owns(this))))
    invariant(forall(UINT64 i; i < 64; 
    closed(kpr[i]::Ipi) && typed(kpr[i]::Ipi) && (kpr[i]->CpuNumber == i))) 
     
    invariant(forall(UINT64 i, j; i < 64 && j < 64 ;
      i != j ==> kpr[i] != kpr[j]
      ))
  

   invariant(forall(UINT64 i, j; i < 64 && j < 64 ;  
    (kpr[i]->flag) ==> closed(&kpr[i]->read[j])))

}ownerkpr;

ownerkpr ghost;

void foo() { }

void
f(
  pp currentPls,
  pp targetPls,
  int currentNumber,
  int targetNumber
  )
  requires(0 <= targetNumber && targetNumber < 64)
  requires(0 <= targetNumber && targetNumber < 64)
  
  writes(currentPls)
  requires(wrapped(currentPls))
  
  requires(currentPls == kpr[currentNumber])
  requires(targetPls == kpr[targetNumber])
{

  foo();
  unwrap(currentPls);

  assert(valid_claim(currentPls->IpiClaim));

  unwrap(&currentPls->write[targetNumber]);
}
`
Verification of _rwkey#adm succeeded.
Verification of _rwkey2#adm succeeded.
Verification of p#adm succeeded.
Verification of p##Ipi#adm succeeded.
Verification of _ownerkpr#adm succeeded.
Verification of foo succeeded.
Verification of f succeeded.
`
#include "vcc.h"

spec(ispure bool a_is_increasing(state_t s1, state_t s2, struct S *s)
    returns(in_state(s1,s->a) <= in_state(s2,s->a));)

struct S {
    volatile int a;
    invariant(a_is_increasing(old(current_state()), current_state(), this))
};
`
Verification of S#adm succeeded.
`
#include <vcc.h>

struct x {
  int dummy;
  invariant(!inv(this))
};

int f ()
{
  struct x X;
  wrap(&X);
  assert(false);
}
`
testcase(5,16) : error VC9712: Use of 'inv(...)' or 'inv2(...)' with negative polarity.
`
#include <vcc.h>

typedef unsigned int UINT;
#define N ((unsigned) 2)

typedef struct Bakery Bakery;

typedef struct vcc(claimable) Client {
	volatile bool choosing;
	spec(volatile bool waiting;)
	spec(obj_t bakery;)
	on_unwrap(inv(bakery))
	invariant(approves(owner(this),choosing))
	invariant(approves(bakery,choosing))
} Client;

typedef struct Bakery {
	Client *c;
	invariant(forall(UINT i; i<N ==> closed(&c[i]) /*&& typed(&c[i])*/ && (c[i].bakery==this)))
	invariant(forall(UINT i; i<N  ==> c[i].choosing))
} Bakery;

void client(Bakery *server, Client *cl spec(UINT idx) spec(claimp(sc)))
requires(wrapped0(sc) && idx<N && wrapped(cl))
requires(claims(sc,closed(server) && &server->c[idx]==cl))
writes(cl,sc)
{
	atomic(sc,server,cl) {
		// note: the verification goes through if waiting below is replaced with choosing
		spec(cl->waiting = 0;)
		bump_volatile_version(cl);
	}
}
`
Verification of Client#adm succeeded.
Verification of Bakery#adm succeeded.
Verification of client succeeded.
`
#include "vcc.h"
struct T;
spec(ispure bool not_inv(obj_t o)
    reads(set_universe())
    returns(!inv(o));)

spec(ispure bool _inv(obj_t o)
    reads(set_universe())
    returns(inv(o));)

struct T {
    int a;
    invariant(not_inv(this))
};

struct S {
    int a;
    invariant(_inv(this))
};
`
testcase(5,27) : error VC9712: Use of 'inv(...)' or 'inv2(...)' with negative polarity.
`