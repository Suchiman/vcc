`
#include "vcc.h"

struct A {
  unsigned size;
  int *arr;
  invariant(keeps((unsigned[size])(arr)))
  invariant(this->size > 0 && this->arr[0] > 0)
};

void foo(struct A *a)
  writes(a)
  requires(wrapped(a))
{
  unwrap(a);
  unwrap((int[a->size])a->arr);
  a->arr[0] = 5;
  wrap((int[a->size])a->arr);
  wrap(a);
}
`
Verification of A#adm succeeded.
Verification of foo succeeded.
`
#include <vcc.h>
#include <stdlib.h>

struct vcc(claimable) S {
  volatile int c;
};

void foo(struct S **s) 
  writes(s)
{
  struct S *a = (struct S *)malloc(sizeof(struct S) * 10);
  struct S *b = &a[0];
  if (a != NULL) {
    wrap(b);
    free((void *)((struct S[10])a));
  }
}
`
Verification of foo failed.
testcase(15,5) : error VC8510: Assertion '_vcc_extent(p) is writable in call to free((void *)((struct S[10])a))' did not verify.
`
#include "vcc.h"

void foo(int *a)
	maintains(wrapped((int[10])a))
	writes((int[10])a)
	ensures(domain_updated_at((int[10])a, SET(&a[1])))
{
	skinny_expose((int[10])a)
		writes(&a[1])
	{
		a[1] = 0;
	}
}
`
Verification of foo succeeded.
`
#include "vcc.h"

spec(typedef unsigned map_t[unsigned];)

spec(ispure map_t upd(map_t m,unsigned y)
    returns(lambda(unsigned x; true; x==y ? 0 : m[x]));)

spec(ispure map_t abs(unsigned *m, unsigned z)
    reads(set_universe())
    returns(lambda(unsigned x; true; x < z ? m[x] : 0));)

void trg(unsigned *m, unsigned z)
    requires(z)
    requires(typed((unsigned[z])m))
    writes(m+0)
{
    m[0] = 0;
    assert(abs(m,z)==upd(old(abs(m,z)),0));
}

spec(typedef struct vcc(record) x { map_t m; } rec_t;)

spec(ispure rec_t rec_upd(rec_t r,unsigned y)
    returns(r / { .m = lambda(unsigned x; true; x==y ? 0 : r.m[x]) });)

spec(ispure rec_t rec_abs(unsigned *m, unsigned z)
    reads(set_universe())
    returns((rec_t) { .m = lambda(unsigned x; true; x < z ? m[x] : 0) });)

void trg2(unsigned *m, unsigned z)
    requires(z)
    requires(typed((unsigned[z])m))
    writes(m+0)
{
    m[0] = 0;
    //assert(rec_abs(m,z).m==rec_upd(old(rec_abs(m,z)),0).m);
    assert(rec_abs(m,z)==rec_upd(old(rec_abs(m,z)),0));
}
`
Verification of trg succeeded.
Verification of trg2 succeeded.
`
#include "vcc.h"

void fill(void *arr, unsigned len, int fill)
    writes(array_range((int*)arr,len))
    ensures(forall(unsigned j; j < len; ((int*)arr)[j]==fill))
{
    unsigned i;
    for (i = 0; i < len; i++)
        invariant(i <= len)
        invariant(forall(unsigned j; j < i; ((int*)arr)[j]==fill))
        ((int*)arr)[i] = fill;
}

void foo(int *arr, unsigned a)
    requires(0 <= a && a < 100)
    maintains(wrapped((int[100])arr))
    writes((int[100])arr)
    ensures(forall(unsigned j; {sk_hack(match_ulong(j))} j < 100;
        j < a ? unchanged(arr[j]) : arr[j]==42))
{
    unwrap((int[100])arr);
    fill(arr+a, 100-a, 42);
    // doesn't help: assert(forall(unsigned j; a <= j; arr+j == (((int*)((void*)arr))+a)+(j-a)));
    assert(forall(unsigned j; {match_ulong(j)} a <= j; arr+j == (arr+a)+(j-a)));
    wrap((int[100])arr);
}

void bar(int *arr, unsigned a, unsigned b)
    requires(a && a < b && b < 100)
    maintains(wrapped((int[100])arr))
    writes((int[100])arr)
    ensures(forall(unsigned j; {sk_hack(match_ulong(j))} j < 100; a <= j && j < b ? arr[j]==42 : unchanged(arr[j])))
{
    unwrap((int[100])arr);
    fill(arr+a, b-a, 42);
    wrap((int[100])arr);
    assert(forall(unsigned j; {match_ulong(j)} a <= j; arr+j == (arr+a)+(j-a)));
}
`
Verification of fill succeeded.
Verification of foo succeeded.
Verification of bar succeeded.
`
#include "vcc.h"

spec(ispure bool foo(int *arr, unsigned c)
    reads(set_universe())
    returns(mutable((int[c])arr) ==> is_mutable_array(arr,c))
{ 
  return mutable((int[c])arr) ==> is_mutable_array(arr,c); 
} )
`
Verification of foo succeeded.
`
#include "vcc.h"

void works(int *a, int *b)
    maintains(wrapped((int[42])a))
    maintains(wrapped((int[42])b))
    writes((int[42])a)
    requires(a!=b) // apparently sufficient for framing here
    ensures(forall(unsigned i; i < 42; unchanged(b[i])))
    ensures(forall(unsigned i; i < 42; i ? unchanged(a[i]) : a[i]==5))
{
    unwrap((int[42])a);
    a[0] = 5;
    wrap((int[42])a);
}

void set_5_at_0(unsigned *a)
    maintains(is_mutable_array(a,42))
    writes(a+0)
    ensures(*a==5)
{
    a[0] = 5;
}

struct vcc(dynamic_owns) X {
  int y;
};

void problematic(unsigned *a, unsigned *b)
    maintains(wrapped((int[42])a))
    maintains(wrapped((int[42])b))
    writes((int[42])a)
    requires(a!=b)
    ensures(forall(unsigned i; i < 42; unchanged(b[i])))
    ensures(forall(unsigned i; i < 42; i ? unchanged(a[i]) : a[i]==5))
{
    assert(in_domain((int[42])b,(int[42])b));
    unwrap((int[42])a);
    set_5_at_0(a);
    wrap((int[42])a);
}
`
Verification of works succeeded.
Verification of set_5_at_0 succeeded.
Verification of problematic succeeded.
`
#include <vcc2test.h>

struct foo {
    vcc(as_array) unsigned int arr[20];
    int y;

    invariant(keeps((int[20])arr))
    invariant(y >= 0 ==> forall(unsigned int x; x < 20; arr[x] == x))
};
	
void init()
{
  struct foo *pf;
  pf = (struct foo *)malloc(sizeof(struct foo));
  if (pf != NULL) {
    pf->y = -1;
    wrap((int[20])pf->arr);
    wrap(pf);
  }
}

void i2(struct foo *f)
writes(extent(f))
{
  f->y = -1;
  wrap((int[20])f->arr);
  wrap(f);
}
struct fail1 {
  vcc(as_array) unsigned int arr[10];
  invariant(arr[0] == 7) // you don't own it
};
`
Verification of foo#adm succeeded.
Verification of fail1#adm failed.
testcase(31,15) : error VC8012: invariant(arr[0] == 7) of fail1 is not admissible.
Verification of init succeeded.
Verification of i2 succeeded.
`
#include <vcc.h>

void foo() {
  int a[5];
}


void fooShouldFail() {
  int a[5];
  wrap((int[5])a);
}

void bar() {
  int a[5];
  wrap((int[5])a);
  unwrap((int[5])a);
}
`
Verification of foo succeeded.
Verification of fooShouldFail failed.
testcase(9,9) : error VC9502: Call 'stack_free(&res__vcc_stack_alloc#2)' did not verify.
testcase(0,0) : error VC9599: (related information) Precondition: 'the extent of the object being reclaimed is mutable'.
Verification of bar succeeded.
`
#include <vcc2test.h>

void foo(int *arr)
  requires(mutable((int[100])arr))
  requires(is_object_root((int[100])arr))
  writes(extent((int[100])arr))
{
  split_array((int[100])arr, 50);
  split_array((int[50])(arr+50), 25);
  split_array((int[50])arr, 25);
  split_array((int[25])(arr+25), 10);
}
`
Verification of foo succeeded.
`
