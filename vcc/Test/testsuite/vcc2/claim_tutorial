`/newsyntax
#include <vcc.h>

_(atomic_inline) int InterlockedCompareExchange(volatile int *Destination, int Exchange, int Comparand) {
  if (*Destination == Comparand) {
    *Destination = Exchange;
    return Comparand;
  } else {
    return *Destination;
  }
}

_(claimable) struct A {
  volatile int x;
  _(invariant  \old(\this->x) == \this->x || \old(\this->x) + 1 == \this->x)
};
void LockFreeIncr(struct A *a _(ghost \claim c))
  _(writes c)
  _(always c, a->\consistent)
{
  int y;
  int z;
  _(ghost  \claim c1, c2;)
  _(atomic c,a) {
    y = a->x;
    _(ghost  c1 = \make_claim({c}, y <= a->x);)
  }
  if (y >= 0x7fffffff) return;
  _(atomic c, c1, a) {
    InterlockedCompareExchange(&a->x, y+1, y);
    _(ghost  c2 = \make_claim({c}, y < a->x);)
  }
  _(atomic c, c2, a) {
    z = a->x;
  }
  _(assert y < z)
}
`
Verification of A#adm succeeded.
Verification of LockFreeIncr succeeded.
`
`/newsyntax
#include <vcc.h>
_(claimable) struct A {
  volatile int x;
  _(invariant  \old(\this->x) == \this->x || \old(\this->x) + 1 == \this->x)
};
void incr(struct A *a, int *res _(ghost \claim c) _(ghost \claim ^cres))
  _(writes c, res, cres)
  _(always c, a->\consistent)
  _(ensures \claims(*cres, a->x >= \when_claimed(*res)))
{
  int val;
  _(ghost  \claim c1;)
  _(atomic c,a) {
    val = a->x;
  }
  *res = val;
  _(ghost  c1 = \make_claim({c}, \when_claimed(*res) <= a->x);)
  _(ghost  *cres = c1;)
}
`
Verification of A#adm succeeded.
Verification of incr succeeded.
`
`/newsyntax
#include <vcc.h>
_(claimable) struct A {
  volatile int x;
  _(invariant  \this->x > 0 && (\old(\this->x) == \this->x || \old(\this->x) + 1 == \this->x ))
};
void incr(struct A *a, int *res _(ghost \claim c) _(ghost \claim ^cres))
  _(writes c, res, cres)
  _(always c, a->\consistent)
  _(ensures \claims(*cres, a->x > \when_claimed(*res)))
  _(ensures \claims_object(*cres, c))
{
  int val;
  _(ghost  \claim c1;)
  _(atomic c,a) {
    val = a->x;
  }
  *res = val;
  _(ghost  c1 = \make_claim({c}, \when_claimed(*res) <= a->x);)

  *res -= 1;
  _(ghost  *cres = c1;)
}
`
Verification of A#adm succeeded.
Verification of incr succeeded.
`
`/newsyntax
#include <vcc2test.h>

_(claimable) struct A {
  volatile int x;
  _(invariant  \old(\this->x) == \this->x || \old(\this->x) + 1 == \this->x)
};

void incr(struct A *a, int *res _(ghost \claim c) _(ghost \claim ^cres))
  _(writes c, res, cres)
  _(always c, a->\consistent)
  // there will be a single new child to c
  _(ensures c->\claim_count == \old(c->\claim_count) + 1)
  // the claim we return will be child of c
  _(ensures \claims_object(*cres, c))
  // it will be wrapped
  _(ensures \wrapped(*cres))
  // it will be childless (so we'll be free to kill it)
  _(ensures (*cres)->\claim_count == 0)
  // and it will guarantee a condition about a->x
  _(ensures \claims(*cres, a->x >= \when_claimed(*res)))
  // and it was not allocated before
  _(ensures \fresh(*cres))
  // we don't free any of our out parameters
  _(ensures \unwrapped(res) && \unwrapped(cres))
{
  _(ghost  \claim c1;)
  int val;
  _(atomic c,a) {
    val = a->x;
  }
  *res = val;
  _(ghost  c1 = \make_claim({c}, \when_claimed(*res) <= a->x);)
  _(ghost  *cres = c1;)
}

void use_case()
{
  struct A *a;
  int tmp;
  _(ghost  \claim c;)
  _(ghost  \claim c2;)
  a = malloc(sizeof(*a));
  if (a != 0) {
    a->x = 0;
    _(wrap a)
    _(ghost  c = \make_claim({a}, \true);)
    incr(a, &tmp _(ghost c) _(ghost  &c2) );
    _(assert \active_claim(c2))
    _(assert tmp <= a->x)
    _(ghost \destroy_claim(c2, {c}));
    _(ghost \destroy_claim(c, {a}));
    _(unwrap a)
    free(a);
  }
}
`
Verification of A#adm succeeded.
Verification of incr succeeded.
Verification of use_case succeeded.
`