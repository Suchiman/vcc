#include <Vcc2.h>

template<typename T> void foo(T* t)
  requires(wrapped(t));
  
struct S {
  int a;
};
  
void bar(struct S *s) 
  requires(wrapped(s))
{
  foo(s);
}
`
Verification of bar succeeded.
`

#include <Vcc2.h>

template<typename T> void foo(T* t)
  requires(wrapped(t));
  
struct S {
  int a;
};
  
void bar(struct S *s) 
{
  foo(s);
}
`
Verification of bar failed.
testcase(13,3) : error VC9502: Call 'foo(s)' did not verify.
testcase(5,14) : error VC9599: (related information) Precondition: '_vcc_wrapped(t)'.
`
#include <Vcc2.h>

template<typename T, typename S> void foo(T* t, S*s)
  requires(wrapped(t) && wrapped(s));
  
struct Q {
  int a;
};
  
struct P {
  int a;
};
  
void bar(struct Q *q)
  requires(wrapped(q))
{
  foo(q,q);
}

void bar1(struct Q *q, struct P *p)
  requires(wrapped(q) && wrapped(p))
{
  foo(q,p);
}
`
Verification of bar succeeded.
Verification of bar1 succeeded.
`
#include <Vcc2.h>

template<typename T> void foo(T* t)
{
  T *s = t;
  T q = *s;
}
`
testcase(6,3) : error VC9693: Cannot declare local 'q' of generic type 'T'
testcase(6,9) : error VC9691: Expression '*s' is of generic type 'T'; only pointers to generic types are supported.
`
#include <Vcc2.h>

template<typename T> void foo(T t)
{
  T* s = &t;
}
`
testcase(3,22) : error VC9693: Cannot declare parameter 't' of generic type 'T'
`
#include <Vcc2.h>

template<typename T> void foo(T* t);

void bar(int *p) {
  foo(p);
}
`
Verification of bar succeeded.
`
#include <Vcc2.h>

template<typename T> void foo(T* t);

void bar(int **p) {
  foo(p);
}
`
Verification of bar succeeded.
`
#include <vcc2.h>

struct B{ int x; };

struct A {
	struct B *b;
	invariant(keeps(b))
};


template<typename T>void blah(T **p)
    writes(p);

void foo(struct A *a)
	requires(mutable(a))
	writes(extent(a))
{
	blah(nospeccast(void **, &a->b));
}
`
Verification of A#adm succeeded.
Verification of foo succeeded.
`
#include <vcc2.h>

struct P { int a; };
struct Q { int b; };

template<typename S, typename T>void blah(void *s, void *t)
  out_param((S*)s)
  out_param((T*)t);


void foo() {
  struct P p;
  struct Q q;
	generic_instance(blah, <struct P, struct Q>)((void *)&p, (void *)&q);
}
`
Verification of foo succeeded.
`

#include <vcc.h>

struct S { int a; };
struct T { 
  int b;
  spec(struct S *p;)
};

spec(template<typename T> T *bar();)

void foo() 
  writes(set_empty())
{
  struct T t;
  spec(t.p = bar<struct S>();)
}
`
Verification of foo succeeded.
`
#include "vcc.h"

typedef unsigned __int8 uint8_t;

template<typename T>
bool
zero(
    void *a,
    unsigned n
    )
    requires(n==sizeof(T))
    // Currently translates to "requires P#n == 0;" to Boogie, function
    // call_zero verifies when this is changed to "requires P#n ==
    // $sizeof(^^TV#T);"
    writes(array_range((uint8_t *)a, n))
    ensures(*((uint8_t*)a)==0)
    ensures(forall(unsigned i; i < n ==> ((uint8_t *)a)[i] == 0))
    ;

struct S { int a, b, c; };

void call_zero(struct S *s)
    requires(is_object_root(s))
    writes(extent(s))
{
    to_bytes(s);
    zero<struct S>((void*) s, sizeof(*s));
    from_bytes(s, false);
}
`
Verification of call_zero succeeded.
`
#include "vcc.h"

void *
CompareAndSwapPointer(
    void volatile ** Destination,
    void * Exchange,
    void * Comperand
    );

#ifdef VERIFY
template<typename T>
vcc(atomic_inline)
T *
CompareAndSwapPointer(
    T volatile** Destination,
    T* Exchange,
    T* Comperand
    )
{
    T *result = *Destination;
    if (*Destination == Comperand)
        *Destination = Exchange;
    return result;
}
#endif

struct S { int dummy; };

void foo() {
    struct S *a, *b, *c;

    CompareAndSwapPointer<struct S>(&a, b, c);

}
`
Verification of foo succeeded.
`
#include "vcc.h"

template<typename T> bool foo(T *x)
    writes(array_range(x,sizeof(T)/4));

vcc_attr("no_infer", "weak_out_param")
void bar(int *p) 
  writes(p)
{ 
  foo(p);
}
`
Verification of bar succeeded.
`
#include "vcc.h"
__specification(template<typename T> ispure size_t check() ensures(result == sizeof(T));)

void foo() { 
  assert(check<int>() == 4); 
}
`
Verification of foo succeeded.
`
#include "vcc.h"

template<typename T> void foo(int *p, T **a);

void bar() {
  int *p;
  int j;
  foo(&j, &p);
}
`
Verification of bar succeeded.
`
#include <vcc.h>

struct S {
  int a;
  int b;
};

struct T {
  int x;
  struct S s;
  int y;
};

#ifdef VERIFY
template<typename T>
T read_typed(T *t)
    requires(typed(t))
    ;
#endif

void foo(struct T *p)
  requires(wrapped(p))
{
  int i,j;
  assert(typed(&p->s));
  i = read_typed(&(p->s.a));
  assert(typed(&p->s));
  j = read_typed(&(p->s.a));
}
`
testcase(16,1) : error VC9693: Cannot return value of generic type 'T'
`

//#include <vcc.h>

template<typename T> void foo(void **p)
  __requires(*(T**)p != 0);

template<typename T> void foo(void **p)
{
}
`
Verification of foo succeeded.
`
#include"vcc.h"

struct S {
  unsigned n;
};


unsigned foo(struct S *T)
requires(wrapped(T))
{
unsigned i;
for(i=0; i<T->n; i++)

return 0;
}
`
Verification of foo succeeded.
`