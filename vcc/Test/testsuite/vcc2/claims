#include <vcc.h>

struct Counter {
  volatile int count;
  invariant( unchanged(count) || count == old(count) + 1 )
};

int foo(struct Counter *cnt spec(claim_t cl) spec(claim_t ^res))
  writes(res, cl)
  requires(wrapped(cl) && claims(cl, closed(cnt)))
  ensures(wrapped(*res) && claims(*res, cnt->count >= result - 1 ))
{
  int y;
  spec( claim_t x; )

  atomic(cl,cnt) {
    y = cnt->count;
    speconly( x = claim(cl, cnt->count >= y);)
  }

  speconly( *res = x; )

  return y;
}

int fooFail1(struct Counter *cnt spec(claim_t cl) spec(claim_t ^res))
  writes(res)
  requires(wrapped(cl) && claims(cl, closed(cnt)))
  ensures(wrapped(*res) && claims(*res, cnt->count >= result - 1 ))
{
  int y;
  spec( claim_t x; )

  atomic(cl,cnt) {
    y = cnt->count;
    speconly( x = claim(cl, cnt->count >= y);)
  }

  speconly( *res = x; )

  return y;
}

int fooFail2(struct Counter *cnt spec(claim_t cl) spec(claim_t ^res))
  writes(res, cl)
  requires(wrapped(cl) && claims(cl, closed(cnt)))
  ensures(wrapped(*res) && claims(*res, cnt->count >= result + 1 ))
{
  int y;
  spec( claim_t x; )

  atomic(cl,cnt) {
    y = cnt->count;
    speconly( x = claim(cl, cnt->count >= y);)
  }

  speconly( *res = x; )

  return y;
}

int fooFail3(struct Counter *cnt spec(claim_t cl) spec(claim_t ^res))
  writes(res, cl)
  requires(wrapped(cl) && claims(cl, closed(cnt)))
  ensures(wrapped(*res) && claims(*res, cnt->count >= 0 ))
{
  int y;
  spec( claim_t x; )

  atomic(cl,cnt) {
    y = cnt->count;
    speconly( x = claim(cl, cnt->count >= 0);)
  }

  speconly( *res = x; )

  return y;
}

int fooFail4(struct Counter *cnt spec(claim_t cl) spec(claim_t ^res))
  writes(res, cl)
  requires(wrapped(cl) && claims(cl, true))
{
  int y;
  spec( claim_t x; )

  atomic(cl,cnt) {
    y = cnt->count;
  }

  return y;
}

int fooFail5(struct Counter *cnt spec(claim_t cl) spec(claim_t ^res))
  writes(res, cl)
  requires(wrapped(cl) && claims(cl, closed(cnt)))
  ensures(wrapped(*res) && claims(*res, cnt->count >= result - 1 ))
{
  int y;
  spec( claim_t x; )

  atomic(cl,cnt) {
    y = cnt->count;
    speconly( x = claim(cl, cnt->count == y);)
  }

  speconly( *res = x; )

  return y;
}


`
Verification of Counter#adm succeeded.
Verification of foo succeeded.
Verification of fooFail1 failed.
testcase(36,50) : error VC8008: cl is non-writable and its owner is not listed in atomic(...) (and thus is impossible to claim).
Verification of fooFail2 failed.
testcase(59,3) : error VC9501: Post condition '_vcc_wrapped(*res) && _vcc_claims(*res, cnt->count >= result + 1 )' did not verify.
testcase(47,13) : error VC9599: (related information) Location of post condition.
Verification of fooFail3 failed.
testcase(72,50) : error VC8520: Assertion 'chunk cnt->count >= 0 of the claim initially holds' did not verify.
Verification of fooFail4 failed.
testcase(87,24) : error VC8527: Assertion 'cnt is closed (for atomic(...))' did not verify.
Verification of fooFail5 failed.
testcase(104,50) : error VC8521: Assertion 'chunk cnt->count == y of the claim holds after a step of the machine' did not verify.
`
#include <vcc.h>

vcc(atomic_inline) int InterlockedCompareExchange(volatile int *Destination, int Exchange, int Comparand) {
  if (*Destination == Comparand) {
    *Destination = Exchange;
    return Comparand;
  } else {
    return *Destination;
  }
}

struct A {
  volatile int x;
  invariant( old(this->x) == this->x || old(this->x) + 1 == this->x )
};

void LockFreeIncr(struct A *a claimp(c))
  writes(c)
  always(c, closed(a))
{
  int y;
  int z;
  spec( claim_t c1, c2; )

  atomic(c,a) {
    y = a->x;
    //speconly( c1 = claim(c, y <= a->x); )
  }
  
  if (y >= 0x7fffffff) return;

  atomic(c, a) {
    InterlockedCompareExchange(&a->x, y+1, y);
    speconly( c2 = claim(c, y < a->x); )
  }
}
`
Verification of A#adm succeeded.
Verification of LockFreeIncr failed.
testcase(34,51) : error VC8520: Assertion 'chunk y < a->x of the claim initially holds' did not verify.
`
#include <vcc.h>

struct A {
  volatile int x;
  invariant( old(this->x) == this->x || old(this->x) + 1 == this->x )
};

void LockFreeIncr(struct A *a claimp(c))
  writes(c)
  always(c, closed(a))
{
  int y;
  int z;
  spec( claim_t c1, c2; )

  atomic(c,a) {
    y = a->x;
    speconly( c1 = claim(c, y <= a->x); )
  }
  
  if (y >= 0x7fffffff) {
    unclaim(c1, c, c);
    return;
  }
}
`
Verification of A#adm succeeded.
Verification of LockFreeIncr failed.
testcase(22,5) : error VC8010: object c might equal c.
`
#include <vcc.h>

vcc(atomic_inline) int InterlockedCompareExchange(volatile int *Destination, int Exchange, int Comparand) {
  if (*Destination == Comparand) {
    *Destination = Exchange;
    return Comparand;
  } else {
    return *Destination;
  }
}

struct A {
  volatile int x;
  invariant( old(this->x) == this->x || old(this->x) + 1 == this->x )
};

void LockFreeIncr(struct A *a claimp(c))
  writes(c)
  always(c, closed(a))
  ensures(ref_cnt(c) == old(ref_cnt(c)))
{
  int y;
  int z;
  spec( claim_t c1, c2; )

  atomic(c,a) {
    y = a->x;
    speconly( c1 = claim(c, y <= a->x); )
  }
  
  if (y >= 0x7fffffff) {
    unclaim(c1, c);
    return;
  }

  atomic(c, c1, a) {
    InterlockedCompareExchange(&a->x, y+1, y);
    speconly( c2 = claim(c, y < a->x); )
  }

  atomic(c, c2, a) {
    z = a->x;
  }

  assert(y < z);

  unclaim(c1, c);
}
`
Verification of A#adm succeeded.
Verification of LockFreeIncr failed.
testcase(48,1) : error VC9501: Post condition '_vcc_ref_cnt(c) == __old(_vcc_ref_cnt(c))' did not verify.
testcase(20,13) : error VC9599: (related information) Location of post condition.
`
#include <vcc.h>

struct vcc(claimable) A {
  volatile int x;
  invariant( old(this->x) == this->x || old(this->x) + 1 == this->x )
};

void foo(struct A *a claimp(c))
  writes(c)
  requires(wrapped(c) && claims(c, closed(a)))
{
  unclaim(c);
}

void foo2(struct A *a claimp(c))
  requires(wrapped(c) && claims(c, closed(a)))
  requires(ref_cnt(c) == 0)
{
  unclaim(c);
}

void foo4(struct A *a claimp(c))
  writes(c, a)
  requires(wrapped(c) && claims(c, closed(a)))
  requires(ref_cnt(c) == 0)
{
  unclaim(c, a);
}

void foo6(struct A *a claimp(c))
  writes(c)
  requires(wrapped(c) && claims(c, closed(a)))
  requires(ref_cnt(c) == 0 && claims_obj(c, a))
{
  unclaim(c, a);
}

void foo7(struct A *a claimp(c))
  writes(c, a)
  requires(wrapped(c) && claims(c, closed(a)))
  requires(ref_cnt(c) == 0 && claims_obj(c, a))
{
  unclaim(c, a, a);
}

void ok1(struct A *a claimp(c))
  writes(c)
  requires(wrapped(c) && claims(c, closed(a)))
  requires(ref_cnt(c) == 0)
{
  unclaim(c);
}


void ok2(struct A *a claimp(c))
  writes(c, a)
  requires(wrapped(c) && claims(c, closed(a)))
  requires(ref_cnt(c) == 0 && claims_obj(c, a))
{
  unclaim(c, a);
}

void ok3(struct A *a, struct A *b claimp(c))
  writes(c, a, b)
  requires(wrapped(c) && claims(c, closed(a)))
  requires(ref_cnt(c) == 0 && claims_obj(c, a) && claims_obj(c, b) && a != b)
{
  unclaim(c, a, b);
}

void foo8(struct A *a, struct A *b claimp(c))
  writes(c, a, b)
  requires(wrapped(c) && claims(c, closed(a)))
  requires(ref_cnt(c) == 0 && claims_obj(c, a) && claims_obj(c, b))
{
  unclaim(c, a, b);
}

`
Verification of A#adm succeeded.
Verification of foo failed.
testcase(12,3) : error VC9502: Call '_vcc_unclaim(c)' did not verify.
testcase(0,0) : error VC9599: (related information) Precondition: 'the claim has no outstanding references'.
Verification of foo2 failed.
testcase(19,3) : error VC8523: Assertion 'the disposed claim c is writable' did not verify.
Verification of foo4 failed.
testcase(27,3) : error VC8522: Assertion 'object a was claimed by c' did not verify.
Verification of foo6 failed.
testcase(35,3) : error VC8008: a is non-writable and its owner is not listed in atomic(...) (and thus is impossible to unclaim).
Verification of foo7 failed.
testcase(43,3) : error VC8010: object a might equal a.
Verification of ok1 succeeded.
Verification of ok2 succeeded.
Verification of ok3 succeeded.
Verification of foo8 failed.
testcase(76,3) : error VC8010: object a might equal b.
`
#include <vcc.h>

struct vcc(claimable) A {
  volatile int x;
  invariant( old(this->x) == this->x || old(this->x) + 1 == this->x )
};

struct A2 {
  volatile int x;
  invariant( old(this->x) == this->x || old(this->x) + 1 == this->x )
};

void kill_A(struct A *a)
  writes(a)
  requires(wrapped(a))
{
  unwrap(a);
}

void kill_A2(struct A2 *a)
  writes(a)
  requires(wrapped(a))
{
  unwrap(a);
}

void kill_A_ok(struct A *a)
  writes(a)
  requires(wrapped(a) && ref_cnt(a) == 0)
{
  unwrap(a);
}

void claim_A(struct A *a)
  writes(a)
  requires(wrapped(a))
{
spec( 
  claim_t c = claim(a, true);
)
}


void claim_A2(struct A2 *a)
  writes(a)
  requires(wrapped(a))
{
spec( 
  claim_t c = claim(a, true);
)
}
`
Verification of A#adm succeeded.
Verification of A2#adm succeeded.
Verification of kill_A failed.
testcase(17,3) : error VC9502: Call '_vcc_unwrap(a)' did not verify.
testcase(0,0) : error VC9599: (related information) Precondition: 'the object has no outstanding claims'.
Verification of kill_A2 succeeded.
Verification of kill_A_ok succeeded.
Verification of claim_A succeeded.
Verification of claim_A2 failed.
testcase(48,34) : error VC8009: type of object a was not marked with vcc(claimable).
`
#include <vcc.h>

struct vcc(claimable) A {
  volatile int x;
  invariant( old(x) == x )
};

void ClaimsValidOnlyInFullStops(struct A *a claimp(c))
  always(c, closed(a) && a->x == 22)
{
  int y;
  int z;

  atomic(c,a) {
    a->x = 17;
    assert(valid_claim(c) || !valid_claim(c));
    assert(false);
  }
}

void RequiresIsNotEnough(struct A *a)
  requires(closed(a))
{
  atomic(a) {
  }
}
`
Verification of A#adm succeeded.
Verification of ClaimsValidOnlyInFullStops failed.
testcase(17,14) : error VC9500: Assertion '((bool)0)' did not verify.
Verification of RequiresIsNotEnough failed.
testcase(24,21) : error VC8527: Assertion 'a is closed (for atomic(...))' did not verify.
`
#include <vcc.h>

struct Node {
    struct Node *next;

    invariant( depends(owner(this), this) )
};


typedef struct Node *PNode;
struct Stack {
    volatile PNode hd;
};

bool push(struct Node *n, struct Stack *s claimp(c))
    always (c, closed(s))
    requires (mutable(n) && owns(n) == set_empty())
    writes (n, n->next)
{
	atomic(c) {
            set_closed_owner(n, s);

	}
}
`
Verification of Node#adm succeeded.
Verification of push failed.
testcase(21,13) : error VC8532: Assertion 's is atomically updated in call to _vcc_set_closed_owner(n, s)' did not verify.
`
#include <vcc.h>

struct Node {
    struct Node *next;

    invariant( depends(owner(this), this) )
};


typedef struct Node *PNode;
struct Stack {
    volatile PNode hd;
};

bool t1(struct Stack *s claimp(c))
    always (c, closed(s))
{
	atomic(c, s) {
	   wrap(s);
	}
}

bool t2(struct Stack *s claimp(c))
    always (c, closed(s))
{
	atomic(c, s) {
	   unwrap(s);
	}
}

void foo () { }

bool t3(struct Stack *s claimp(c))
    always (c, closed(s))
{
	atomic(c, s) {
		foo();
	}
}
`
testcase(19,5) : error VC9626: static_wrap(...) cannot be used inside atomic update/read
testcase(27,5) : error VC9626: static_unwrap(...) cannot be used inside atomic update/read
testcase(37,3) : error VC9627: ordinary functions like foo(...) cannot be used inside atomic update/read
`
#include <vcc.h>

struct vcc(claimable) A {
  spec(claim_t c;)
  int x;
};

void foo(struct A *a, struct A *b)
  writes(extent(a), extent(b))
  requires(a != b)
{
  speconly(
    set_owns(a, set_empty());
    wrap(a);
    b->c = claim(a, true);
  )
}
`
Verification of foo succeeded.
`
#include <vcc.h>

struct A {
  spec(claim_t c;)
  int x;
};

void foo(struct A *a, struct A *b)
  writes(extent(a), extent(b))
  requires(a != b)
{
  spec(claim_t c;)
  assert(c == claim(a, true));
}
`
testcase(13,17) : error VC9652: claim(...) used in pure context
`
#include <vcc.h>

struct vcc(claimable) S {
  int x;
};


void foo(struct S *s)
  writes(s)
  maintains(wrapped0(s))
{
  expose(s) {
    s->x = 12;
  }
}
`
Verification of foo succeeded.
`
#include <vcc.h>

struct A {
  volatile int x;
};

struct B {
  struct A *a;
  spec(claim_t c;)
  invariant(keeps(c) && closed(c))
  invariant(claims(c, this->a->x > 0))
  invariant(a->x > 0)
};


`
Verification of B#adm failed.
testcase(12,15) : error VC8012: invariant(a->x > 0) of B is not admissible.
`
#include "vcc.h"

void foo(obj_t O) requires(is_claimable(O)) { }    

`
Verification of foo succeeded.
`#include "vcc.h"

typedef struct  vcc(claimable) A {

        volatile bool a;
        invariant(a)
} *PA;



void foo2(PA x)
writes(x)
requires(mutable(x))
{
        spec(claim_t tmp;)
        speconly(
                tmp = claim(x, x->a);
                //tmp = claim(x, x->a && closed(x)); //is also accepted by vcc
        )
}
`
Verification of A#adm succeeded.
Verification of foo2 failed.
testcase(17,23) : error VC8528: Assertion 'object x is closed before claiming it' did not verify.
`
#include "vcc.h"

typedef unsigned __int64 UINT64;

typedef union _CONC
{
	volatile struct
    {
        UINT64 c1;
    };

    backing_member UINT64 AsUINT64;
} CONC;

struct DESC {
	def_group(Group)
	invariant(keeps(this::Group))

	in_group(Group) CONC o;
	
	spec(in_group(Group) claim_t c;)
	inv_group(Group, keeps(c) && claims(c, closed(&o)))
};

void update_o(struct DESC *d)
	maintains(wrapped(d::Group))
	writes(d::Group)
{
	expose(d::Group){
	atomic(d->c, &d->o){
		assert(valid_claim(d->c));
		begin_update();
		d->o.c1 = 1;
	}}
}
`
Verification of DESC#adm succeeded.
Verification of DESC##Group#adm succeeded.
Verification of update_o succeeded.
`#include <vcc.h>
 
struct vcc(claimable) Foo
{
    int x;
};
 
void foo(struct Foo *o claimp(c))
  always(c,closed(o))
  writes(o)
  ensures(false)
{
  spec(claim_t c1;)
  atomic(c,o) {
    speconly(c1 = claim(o, false);)
  }
  assert(false);
}
`
Verification of foo failed.
testcase(15,50) : error VC8520: Assertion 'chunk ((bool)0) of the claim initially holds' did not verify.
`
#include <vcc.h>
 
struct vcc(claimable) Foo
{
  invariant(true)
    int x;
};
 
void foo(struct Foo *o claimp(c))
  always(c,closed(o))
  writes(o)
  ensures(false)
{
  spec(claim_t c1;)

  speconly(c1 = claim(o, false);)
  assert(false);
}
`
Verification of Foo#adm succeeded.
Verification of foo failed.
testcase(16,48) : error VC8520: Assertion 'chunk ((bool)0) of the claim initially holds' did not verify.
`
#include "vcc2test.h"

struct vcc(claimable) S {
  volatile int x;
};

void foo()
{
   
   struct S *sp = (struct S *)malloc(sizeof(struct S));
   spec(claim_t c;)
   if (sp != NULL) { 
     wrap(sp);
     atomic(sp) {
       sp->x = 10;
       speconly( c = claim(sp, sp->x > 0); )
     }
   }
}

void bar()
{
   
   struct S *sp = (struct S *)malloc(sizeof(struct S));
   int q;

   spec(claim_t c;)

   if (sp != NULL) {
     wrap(sp);
     atomic(sp) {
       q = 10;
       sp->x = 10;
       speconly( c = claim(sp, q == 9 && sp->x > 0); )
       q = 9;
     }
   }
}

`
Verification of foo failed.
testcase(16,53) : error VC8521: Assertion 'chunk sp->x > 0 of the claim holds after a step of the machine' did not verify.
Verification of bar failed.
testcase(34,53) : error VC8521: Assertion 'chunk sp->x > 0 of the claim holds after a step of the machine' did not verify.
`
#define PVOID void*
#define NULL ((void*)0)

#include "vcc.h"

typedef struct TH *PTH;

typedef struct GLOBAL_STATE 
{
	int dummy;
	spec(volatile PVOID ThreadState[PTH];)
	
} GLOBAL_STATE, *PGLOBAL_STATE;

GLOBAL_STATE SchGlobalState;


 void MoveFromEvent(PTH Thread claimp(lh_nchange))
   always(lh_nchange, closed(&SchGlobalState))
 {
 
	atomic(lh_nchange, &SchGlobalState)
	{
		begin_update();
		speconly(SchGlobalState.ThreadState = lambda(PTH e; true; NULL);)
	}
 }
`
Verification of MoveFromEvent succeeded.
`#include <vcc.h>

struct vcc(volatile_owns) A {
  int x;
};

struct B { int y; };

void foo();

void bar(struct A *a, struct B *b)
  requires(wrapped(a) && set_in(b, owns(a)))
{
  assert(in_domain(a, a));
  assert(in_domain(b, a));
  assume(b->y == 10);
  foo();
  assert(in_domain(b, a));
  assert(b->y == 10);
}
`
Verification of bar failed.
testcase(15,12) : error VC9500: Assertion '_vcc_in_domain(b,a)' did not verify.
`
#include <vcc.h>

struct vcc(claimable) FooBar {
  int x;
};

void f(struct FooBar *b claimp(cc))
  requires(wrapped(b))
  requires(closed(cc))
  writes(b)
{
  spec(claim_t c;)

  speconly(
    c = claim(b, true);
    assert(c != cc);
  )
}
`
Verification of f succeeded.
`
#include "vcc.h"

void foo() {
    unsigned i;
    spec(claim_t c;)
    assert(claims(c,1));
    assert(claims(&c,1));
    assert(claims(&i,1));
}
`
testcase(7,26) : error VC0000: Cannot implicitly convert type '_vcc_claim_struct^^' to '_vcc_claim_struct^'.
testcase(8,26) : error VC0000: Cannot implicitly convert type 'uint*' to '_vcc_claim_struct^'.
`#include <vcc.h>

#define NULL ((void *)0)

typedef __int32 INT32;

typedef struct vcc(claimable) vcc(volatile_owns) _RTL_SPIN_LOCK
{
    volatile INT32 Lock;
    spec(volatile obj_t protected_obj;)
    invariant(protected_obj!=NULL ==> (Lock == 0 || Lock == 1))
    invariant(old(protected_obj)!=NULL ==> unchanged(protected_obj))
    invariant(!Lock && protected_obj!=NULL ==> set_in(protected_obj, owns(this)))

} RTL_SPIN_LOCK, *PRTL_SPIN_LOCK;

void
RtlAcquireSpinLock(
    PRTL_SPIN_LOCK SpinLock
    claimp(c)
    )
    always(c,closed(SpinLock) && SpinLock->protected_obj!=NULL)
    ensures(wrapped(SpinLock->protected_obj))
    ensures(is_fresh(SpinLock->protected_obj))
    ;


struct S {
  int a;
};

struct T {

  struct S s;
  RTL_SPIN_LOCK L;
  spec(claim_t Claim;)
  
  invariant(keeps(&L, Claim))
  invariant(claims(Claim, closed(&L) && L.protected_obj == &s))
};

void foo(struct T *p claimp(c))
  always(c, closed(p))
{
  assert(claims_claim(c, p->Claim));
  RtlAcquireSpinLock(&p->L spec(c));
}


`
Verification of _RTL_SPIN_LOCK#adm succeeded.
Verification of T#adm succeeded.
Verification of foo succeeded.
`
#include <vcc.h>

struct A {
  volatile int x;
  invariant(x == 0)
};

void foo(struct A *a, struct A *aa)
  requires(wrapped(aa) && wrapped(a) && aa != a)
{
  struct A *a0;

  a0 = a;
  atomic(a0) {
    a0 = aa;
    a0->x = 12;
    a0 = a;
  }
}
`
Verification of A#adm succeeded.
Verification of foo failed.
testcase(16,5) : error VC8507: Assertion 'a0->x is writable' did not verify.
`
#include <vcc.h>

struct vcc(volatile_owns) A {
  int x;
};

void foo(struct A *a, struct A *aa)
  requires(wrapped(aa) && wrapped(a) && aa != a)
  writes(a)
{
  atomic(aa) {
    set_closed_owner(a, aa);
  }
}

void foo2(struct A *a, struct A *aa)
  requires(wrapped(aa) && wrapped(a) && aa != a)
  writes(a)
{
  struct A *aa2 = aa;
  atomic(aa) {
    set_closed_owner(a, aa2);
  }
}
`
Verification of foo succeeded.
Verification of foo2 succeeded.
`
#include "vcc.h"

struct vcc(claimable) S {
    int one;
    invariant(one==1)
};

void foo(struct S *s, int y claimp(c))
    always(c,closed(s))
    requires(y==1)
    writes(c)
{
    spec(claim_t d;)
    int x;
    speconly(d = claim(c,closed(s) && s->one==1);)
    speconly(d = claim(c,closed(s) && s->one==when_claimed(1));) // warn
    x = 1;
    speconly(d = claim(c,closed(s) && s->one==when_claimed(x));) // warn
    speconly(d = claim(c,closed(s) && s->one==when_claimed(y));) // warn
}
`
testcase(16,88) : warning VC9106: 'old', 'in_state', or 'when_claimed' in '_vcc_in_state(_vcc_when_claimed(), 1)' has no effect
testcase(18,88) : warning VC9106: 'old', 'in_state', or 'when_claimed' in '_vcc_in_state(_vcc_when_claimed(), x)' has no effect
testcase(19,88) : warning VC9106: 'old', 'in_state', or 'when_claimed' in '_vcc_in_state(_vcc_when_claimed(), y)' has no effect
Verification of S#adm succeeded.
Verification of foo succeeded.
`#include <vcc.h>

struct vcc(claimable) A { int dummy; };

void foo(struct A *a claimp(c1) claimp(c2) claimp(c3))
  requires(c1 != c2 && c1 != c3 && c2 != c3)
  requires(wrapped(c1) && claims_obj(c1, a))
  requires(wrapped(c2) && claims_obj(c2, a))
  requires(wrapped(c3) && claims_obj(c3, a))
{
  assert(account_claim(c1, a));
  assert(account_claim(c2, a));
  assert(account_claim(c3, a));
  assert(ref_cnt(a) >= 3);
}

void fooFail1(struct A *a claimp(c1) claimp(c2) claimp(c3))
  requires(c1 != c2 && c1 != c3)
  requires(wrapped(c1) && claims_obj(c1, a))
  requires(wrapped(c2) && claims_obj(c2, a))
  requires(wrapped(c3) && claims_obj(c3, a))
{
  assert(account_claim(c1, a));
  assert(account_claim(c2, a));
  assert(account_claim(c3, a));
  assert(ref_cnt(a) >= 3);
}

void fooFail2(struct A *a claimp(c1) claimp(c2) claimp(c3))
  requires(c1 != c2 && c1 != c3 && c2 != c3)
  requires(wrapped(c1))
  requires(wrapped(c2) && claims_obj(c2, a))
  requires(wrapped(c3) && claims_obj(c3, a))
{
  assert(account_claim(c1, a));
  assert(account_claim(c2, a));
  assert(account_claim(c3, a));
  assert(ref_cnt(a) >= 3);
}
`
Verification of foo succeeded.
Verification of fooFail1 failed.
testcase(26,12) : error VC9500: Assertion '_vcc_ref_cnt(a) >= 3' did not verify.
Verification of fooFail2 failed.
testcase(35,12) : error VC9500: Assertion '_vcc_account_claim(c1, a)' did not verify.
`
#include <vcc.h>

struct vcc(claimable) A {
  int dummy;
};

void succeeds(struct A *a, struct A *b claimp(d))
  writes(a)
  requires(wrapped(a))
  requires(wrapped(d) && claims_obj(d, b))
{
  spec(claim_t c;)
  atomic(d, b) {
    speconly(c = claim(a, claims_obj(c,a));)
  }
}

void usedToFail(struct A *a)
  writes(a)
  requires(wrapped(a))
{
  spec(claim_t c;)
  speconly(c = claim(a, claims_obj(c,a));)
}
`
Verification of succeeds succeeded.
Verification of usedToFail succeeded.
`
#include <vcc.h>

struct vcc(claimable) Counter {
  volatile int count;
  invariant( unchanged(count) || count == old(count) + 1 )
};

int foo(struct Counter *cnt spec(claim_t cl) spec(out claim_t res))
  writes(cl)
  requires(wrapped0(cl) && claims_obj(cl, cnt))
  ensures(wrapped(res) && claims(res, cnt->count >= result - 1 ) && claims_obj(res, cnt) && is_fresh(res))
{
  int y;
  spec( claim_t x; )

  atomic(cl,cnt) {
    y = cnt->count;
    speconly( res = upgrade_claim(cl, cnt->count >= y);)
  }

  return y;
}

int fooFail1(struct Counter *cnt spec(claim_t cl) spec(out claim_t res))
  writes(cl)
  requires(wrapped(cl) && claims_obj(cl, cnt))
{
  int y;
  spec( claim_t x; )

  atomic(cl,cnt) {
    y = cnt->count;
    speconly( res = upgrade_claim(cl, cnt->count >= y);)
  }

  return y;
}

/*
// This one doesn't work because we do not get to assume the claimed properties
// of the upgraded claims in the transitivity check.
int fooOk2(struct Counter *cnt spec(claim_t cl) spec(out claim_t res))
  writes(cl)
  requires(wrapped0(cl) && claims(cl, closed(cnt)))
  ensures(wrapped0(res) && claims(res, cnt->count >= result - 1 ) && is_fresh(res))
{
  int y;
  spec( claim_t x; )

  atomic(cl,cnt) {
    y = cnt->count;
    speconly( res = upgrade_claim(cl, cnt->count >= y);)
  }

  return y;
}
*/

int fooFail2(struct Counter *cnt spec(claim_t cl) spec(out claim_t res))
  writes(cl)
  requires(wrapped0(cl) && claims(cl, closed(cnt)))
  ensures(wrapped0(res) && claims(res, cnt->count >= result - 1 ) && is_fresh(res))
{
  int y;
  spec( claim_t x; )

  atomic(cl,cnt) {
    y = cnt->count;
    speconly( res = upgrade_claim(cl, cnt->count >= y);)
  }

  assert(claims_obj(res, cnt));

  return y;
}

int fooFail3(struct Counter *cnt spec(claim_t cl) spec(out claim_t res))
  writes(cl)
  requires(wrapped(cnt))
  requires(claims_obj(cl, cnt))
  ensures(wrapped(res) && claims(res, cnt->count >= result - 1 ) && claims_obj(res, cnt) && is_fresh(res))
{
  int y;
  spec( claim_t x; )

  atomic(cnt) {
    y = cnt->count;
    speconly( res = upgrade_claim(cl, cnt->count >= y);)
  }

  return y;
}

int fooFail4(struct Counter *cnt spec(claim_t cl) spec(out claim_t res))
  requires(wrapped0(cl) && claims_obj(cl, cnt))
  ensures(wrapped(res) && claims(res, cnt->count >= result - 1 ) && claims_obj(res, cnt) && is_fresh(res))
{
  int y;
  spec( claim_t x; )

  atomic(cl,cnt) {
    y = cnt->count;
    speconly( res = upgrade_claim(cl, cnt->count >= y);)
  }

  return y;
}

void two(struct Counter *cnt1, struct Counter *cnt2 spec(claim_t cl1) spec(claim_t cl2) spec(out claim_t res))
  writes(cl1,cl2)
  requires(wrapped0(cl1) && claims_obj(cl1, cnt1) && claims(cl1, cnt1->count >= 0))
  requires(wrapped0(cl2) && claims_obj(cl2, cnt2) && claims(cl2, cnt2->count >= 0))
  ensures(wrapped0(res) && claims(res, cnt1->count + cnt2->count >= 0) && claims_obj(res, cnt1) && claims_obj(res, cnt2) && is_fresh(res))
{
  int y;
  spec( claim_t x; )

  speconly( res = upgrade_claim(cl1, cl2, cnt1->count + cnt2->count >= 0);)
}

void twoFail1(struct Counter *cnt1, struct Counter *cnt2 spec(claim_t cl1) spec(claim_t cl2) spec(out claim_t res))
  writes(cl1,cl2)
  requires(wrapped0(cl1) && claims(cl1, cnt1->count >= 0))
  requires(wrapped0(cl2) && claims_obj(cl2, cnt2) && claims(cl2, cnt2->count >= 0))
  ensures(wrapped0(res) && claims(res, cnt1->count + cnt2->count >= 0) && claims_obj(res, cnt1) && claims_obj(res, cnt2) && is_fresh(res))
{
  int y;
  spec( claim_t x; )

  speconly( res = upgrade_claim(cl1, cl2, cnt1->count + cnt2->count >= 0);)
}

`
Verification of Counter#adm succeeded.
Verification of foo succeeded.
Verification of fooFail1 failed.
testcase(33,52) : error VC8025: the claim cl has outstanding claims.
Verification of fooFail2 failed.
testcase(69,52) : error VC8521: Assertion 'chunk cnt->count >= y of the claim holds after a step of the machine' did not verify.
testcase(72,12) : error VC9500: Assertion '_vcc_claims_obj(res, cnt)' did not verify.
Verification of fooFail3 failed.
testcase(88,52) : error VC8024: the claim cl is not wrapped before upgrade.
testcase(88,52) : error VC8025: the claim cl has outstanding claims.
Verification of fooFail4 failed.
testcase(103,52) : error VC8023: cl is non-writable and (and thus is impossible to upgrade).
Verification of two succeeded.
Verification of twoFail1 failed.
testcase(130,50) : error VC8521: Assertion 'chunk cnt1->count + cnt2->count >= 0 of the claim holds after a step of the machine' did not verify.
testcase(131,1) : error VC9501: Post condition '(_vcc_wrapped(res) && _vcc_ref_cnt(res) == 0) && _vcc_claims(res, cnt1->count + cnt2->count >= 0) && _vcc_claims_obj(res, cnt1) && _vcc_claims_obj(res, cnt2) && _vcc_is_fresh(res)' did not verify.
testcase(125,13) : error VC9599: (related information) Location of post condition.
`
#include "vcc.h"

struct vcc(claimable) S { int a; };

void foo(struct S *s)
	requires(wrapped(s))
	writes(s)
{
	claimp(c;)
	speconly(c = claim(s,1);)
	unclaim(c,s);
	assert(!closed(c));
}
`
Verification of foo succeeded.
`
// Authors: Mark Hillebrand, Dirk Leinenbach (with inspiration from Ernie Cohen)
#include "vcc.h"

#define stays_unchanged(o) ((o)==when_claimed(o))
#define protects(structure,protector,expression) \
    (wrapped(structure) && ref_cnt(structure)==1 && \
    wrapped0((structure)->protector) && \
    valid_claim((structure)->protector) && claims_obj(((structure)->protector),(structure)) && \
    claims(((structure)->protector), closed(structure) && stays_unchanged(structure->protector)) && \
    claims(((structure)->protector), (expression)))

struct vcc(claimable) S {
    unsigned dummy;
    spec(volatile claim_t protector;)
    spec(volatile unsigned protected;)
    invariant(closed(old(protector)) ==> unchanged(protector) && unchanged(protected))
};

void middle(struct S *s)
    requires(protects(s,protector,s->protected==2))
    ensures(protects(s,protector,s->protected==1))
    ensures(is_fresh(s->protector))
    writes(s->protector)
{
    atomic(s) {
        assert(valid_claim(old(s->protector)));
        begin_update();
        speconly(
	  s->protected = 1;
          s->protector = upgrade_claim(s->protector, stays_unchanged(s->protector) && s->protected==1);
	)
    }
}
`
Verification of S#adm succeeded.
Verification of middle succeeded.
`
