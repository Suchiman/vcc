#include <vcc.h>

struct vcc(claimable) Counter {
  volatile int count;
  invariant( unchanged(count) || count == old(count) + 1 )
};

int foo(struct Counter *cnt spec(claim_t cl) spec(out claim_t res))
  writes(cl)
  requires(wrapped0(cl) && claims_obj(cl, cnt))
  ensures(wrapped(res) && claims(res, cnt->count >= result - 1 ) && claims_obj(res, cnt) && is_fresh(res))
{
  int y;
  spec( claim_t x; )

  atomic(cl,cnt) {
    y = cnt->count;
    spec( res = upgrade_claim(cl, cnt->count >= y);)
  }

  return y;
}

int fooFail1(struct Counter *cnt spec(claim_t cl) spec(out claim_t res))
  writes(cl)
  requires(wrapped(cl) && claims_obj(cl, cnt))
{
  int y;
  spec( claim_t x; )

  atomic(cl,cnt) {
    y = cnt->count;
    spec( res = upgrade_claim(cl, cnt->count >= y);)
  }

  return y;
}

/*
// This one doesn't work because we do not get to assume the claimed properties
// of the upgraded claims in the transitivity check.
int fooOk2(struct Counter *cnt spec(claim_t cl) spec(out claim_t res))
  writes(cl)
  requires(wrapped0(cl) && claims(cl, closed(cnt)))
  ensures(wrapped0(res) && claims(res, cnt->count >= result - 1 ) && is_fresh(res))
{
  int y;
  spec( claim_t x; )

  atomic(cl,cnt) {
    y = cnt->count;
    spec( res = upgrade_claim(cl, cnt->count >= y);)
  }

  return y;
}
*/

int fooFail2(struct Counter *cnt spec(claim_t cl) spec(out claim_t res))
  writes(cl)
  requires(wrapped0(cl) && claims(cl, closed(cnt)))
  ensures(wrapped0(res) && claims(res, cnt->count >= result - 1 ) && is_fresh(res))
{
  int y;
  spec( claim_t x; )

  atomic(cl,cnt) {
    y = cnt->count;
    spec( res = upgrade_claim(cl, cnt->count >= y);)
  }

  assert(claims_obj(res, cnt));

  return y;
}

int fooFail3(struct Counter *cnt spec(claim_t cl) spec(out claim_t res))
  writes(cl)
  requires(wrapped(cnt))
  requires(claims_obj(cl, cnt))
  ensures(wrapped(res) && claims(res, cnt->count >= result - 1 ) && claims_obj(res, cnt) && is_fresh(res))
{
  int y;
  spec( claim_t x; )

  atomic(cnt) {
    y = cnt->count;
    spec( res = upgrade_claim(cl, cnt->count >= y);)
  }

  return y;
}

int fooFail4(struct Counter *cnt spec(claim_t cl) spec(out claim_t res))
  requires(wrapped0(cl) && claims_obj(cl, cnt))
  ensures(wrapped(res) && claims(res, cnt->count >= result - 1 ) && claims_obj(res, cnt) && is_fresh(res))
{
  int y;
  spec( claim_t x; )

  atomic(cl,cnt) {
    y = cnt->count;
    spec( res = upgrade_claim(cl, cnt->count >= y);)
  }

  return y;
}

void two(struct Counter *cnt1, struct Counter *cnt2 spec(claim_t cl1) spec(claim_t cl2) spec(out claim_t res))
  writes(cl1,cl2)
  requires(wrapped0(cl1) && claims_obj(cl1, cnt1) && claims(cl1, cnt1->count >= 0))
  requires(wrapped0(cl2) && claims_obj(cl2, cnt2) && claims(cl2, cnt2->count >= 0))
  ensures(wrapped0(res) && claims(res, cnt1->count + cnt2->count >= 0) && claims_obj(res, cnt1) && claims_obj(res, cnt2) && is_fresh(res))
{
  int y;
  spec( claim_t x; )

  spec( res = upgrade_claim(cl1, cl2, cnt1->count + cnt2->count >= 0);)
}

void twoFail1(struct Counter *cnt1, struct Counter *cnt2 spec(claim_t cl1) spec(claim_t cl2) spec(out claim_t res))
  writes(cl1,cl2)
  requires(wrapped0(cl1) && claims(cl1, cnt1->count >= 0))
  requires(wrapped0(cl2) && claims_obj(cl2, cnt2) && claims(cl2, cnt2->count >= 0))
  ensures(wrapped0(res) && claims(res, cnt1->count + cnt2->count >= 0) && claims_obj(res, cnt1) && claims_obj(res, cnt2) && is_fresh(res))
{
  int y;
  spec( claim_t x; )

  spec( res = upgrade_claim(cl1, cl2, cnt1->count + cnt2->count >= 0);)
}

`
Verification of Counter#adm succeeded.
Verification of foo succeeded.
Verification of fooFail1 failed.
testcase(33,28) : error VC8025: the claim cl has outstanding claims.
Verification of fooFail2 failed.
testcase(69,28) : error VC8521: Assertion 'chunk cnt->count >= y of the claim holds after a step of the machine' did not verify.
testcase(72,12) : error VC9500: Assertion '_vcc_claims_obj(res, cnt)' did not verify.
Verification of fooFail3 failed.
testcase(88,28) : error VC8024: the claim cl is not wrapped before upgrade.
testcase(88,28) : error VC8025: the claim cl has outstanding claims.
Verification of fooFail4 failed.
testcase(103,28) : error VC8023: cl is non-writable and (and thus is impossible to upgrade).
Verification of two succeeded.
Verification of twoFail1 failed.
testcase(130,26) : error VC8521: Assertion 'chunk cnt1->count + cnt2->count >= 0 of the claim holds after a step of the machine' did not verify.
testcase(131,1) : error VC9501: Post condition '(_vcc_wrapped(res) && _vcc_ref_cnt(res) == 0) && _vcc_claims(res, cnt1->count + cnt2->count >= 0) && _vcc_claims_obj(res, cnt1) && _vcc_claims_obj(res, cnt2) && _vcc_is_fresh(res)' did not verify.
testcase(125,13) : error VC9599: (related information) Location of post condition.
`
